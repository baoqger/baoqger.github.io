<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-userland-memory-allocation-three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/10/userland-memory-allocation-three/" class="article-date">
  <time datetime="2022-10-10T08:27:46.000Z" itemprop="datePublished">2022-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/09/08/userland-memory-allocation-two/">article</a>,  we investigated how the allocated chunks are aligned and stored in the heap. This article continues to examine how to free a chunk of memory and how the freed chunks are stored in the heap. </p>
<h3 id="Hands-on-demo"><a href="#Hands-on-demo" class="headerlink" title="Hands-on demo"></a>Hands-on demo</h3><p>Let’s continue debugging the demo code shown in the last article: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">&quot;AAAABBBBCCCCDDDD&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Previously, we allocated a chunk of memory and put data in it. The next line will free this chunk. Before we run the instruction and show the demo result, let’s discuss the theory first. </p>
<p>The freed chunk will not be returned to the kernel immediately after the <code>free</code> is called. Instead, the heap <code>allocator</code> keeps track of the freed chunks in a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linked_list"><code>linked list</code></a> data structure. So the freed chunks in the linked list can be reused when the application requests new allocations again. This can decrease the performance overhead by avoiding too many system calls. </p>
<p>The <code>allocator</code> could store all the freed chunks together in a long linked list, this would work but the performance would be slow. Instead, the <code>glibc</code> maintains a series of freed linked lists called <code>bins</code>, which can speed up the allocations and frees. We will examine how <code>bins</code> work later.  </p>
<p>It is worth noting that each free chunk needs to store <code>pointers</code> to other chunks to form the linked list. That’s what we discussed in the last section, there’re two points in the <code>malloc_chunk</code> structure: <code>fd</code> and <code>bk</code>, right? Since the <code>user data</code> region of the freed chunk is free for use by the <code>allocator</code>, so it repurposes the <code>user data</code> region as the place to store the pointer. </p>
<p>Based on the above description, the following picture illustrates the exact structure of a freed chunk:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if freed                  | </span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             pointer to the next freed chunk                   |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             pointer to the previous freed chunk               |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                           ......                              .</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now step over one line in <code>gdb</code> and check chunks in the heap as follows: </p>
<img src="/images/heap-demo-heap-free.png" title="pwndbg 1" width="300px" height="200px">

<p>You can see the changes: the allocated chunk is marked as a <code>Free chunk (tcache)</code> and pointer <code>fd</code> is set(which indicates this freed chunk is inserted into a linked list). </p>
<p>The <code>tcache</code> is one kind of <code>bins</code> provided by <code>glibc</code>. The gdb <code>pwndbg</code> plugin allows you to check the content of <code>bins</code> by running command <code>bins</code> as follows:</p>
<img src="/images/heap-demo-bins.png" title="pwndbg 2" width="300px" height="200px">

<p>Note that the freed chunk(at 0x5555555592a0) is inserted into <code>tcache bins</code> as the liked list header.  </p>
<p>Note that there 5 types of bins: <code>small bins</code>, <code>large bins</code>, <code>unsorted bins</code>, <code>fast bins</code> and <code>tcache bins</code>. If you don’t know, don’t worry I will examine them in the following section. </p>
<p>According to the definition, after the second <code>malloc(100)</code> is called, the <code>allocator</code> should reuse the freed chunk in the <code>bins</code>. The following image can prove this:  </p>
<img src="/images/heap-demo-reuse-100.png" title="pwndbg 3" width="300px" height="200px">

<p>The freed chunk at 0x555555559290 is in use again and all <code>bins</code> are empty after the chunk is removed from the linked list. All right! </p>
<h3 id="Recycling-memory-with-bins"><a href="#Recycling-memory-with-bins" class="headerlink" title="Recycling memory with bins"></a>Recycling memory with bins</h3><p>Next, I want to spend a little bit of time examining why we need <code>bins</code> and how <code>bins</code> optimize chunk allocation and free. </p>
<p>If the <code>allocator</code> keeps track of all the freed chunks in a long linked list. The time complexity is <code>O(N)</code> for the allocator to find a freed chunk with fit size by traversing from the head to the tail. If the <code>allocator</code> wants to keep the chunks in order, then at least  <code>O(NlogN)</code> time is needed to sort the list by size. This slow process would have a bad impact on the overall performance of programs. That’s the reason why we need bins to optimize this process. In summary, the optimization is done on the following two aspects:</p>
<ul>
<li>High-performance data structure</li>
<li>Per-thread cache without lock contention</li>
</ul>
<h4 id="High-performance-data-structure"><a href="#High-performance-data-structure" class="headerlink" title="High-performance data structure"></a>High-performance data structure</h4><p>Take the <code>small bins</code> and <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686"><code>large bins</code></a> as a reference, they are defined as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>They are defined together in an array of linked lists and each linked list(or bin) stores chunks that are all <code>the same fixed size</code>. From <code>bins[2] to bins[63]</code> are the <code>small bins</code>, which track freed chunks less than 1024 bytes while the <code>large bins</code> are for bigger chunks.  <code>small bins</code> and <code>large bins</code> can be represented as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Doubly_linked_list"><code>double-linked list</code></a> shown below: </p>
<img src="/images/small-bins-index.png" title="pwndbg 4" width="600px" height="400px">

<p>The <code>glibc</code> provides a <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686">function</a> to calculate the <code>index</code> of the corresponding small(or large) bin in the array based on the requested <code>size</code>. Since the <code>index</code> operation of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Array_(data_structure)">array</a> is in <code>O(1)</code> time. Moreover, each bin contains chunks of the same size, so it can also take <code>O(1)</code> time to insert or remove one chunk into or from the list. As a result, the entire allocation time is optimized to  <code>O(1)</code>. </p>
<p><code>bins</code> are <code>LIFO(Last In First Out)</code> data structure. The insert and remove operations can be illustrated as follows: </p>
<img src="/images/LIFO-linked-list.png" title="pwndbg 4" width="600px" height="400px">

<p>Moreover, for <code>small bins</code> and <code>large bins</code>, if the neighbors of the current chunk are free, they are <code>merged</code> into a larger one. That’s the reason we need a <code>double-linked list</code> to allow running fast traverse both forward and backward. </p>
<p>Unlike <code>small bins</code> and <code>large bins</code>, <code>fast bins</code> and <code>tcache bins</code> chunks are <code>never merged</code> with their neighbors. In practice, the glibc <code>allocator</code> doesn’t set the <code>P</code> special flag at the start of the next chunk. This can avoid the overhead of merging chunks so that the freed chunk can be immediately reused if the same size chunk is requested. Moreover, since <code>fast bins</code> and <code>tcache bins</code> are never merged, they are implemented as a <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1678"><code>single-linked list</code></a>.</p>
<p>This can be proved by running the second <code>free</code> method in the demo code and checking the chunks in the heap as follows: </p>
<img src="/images/heap-demo-heap-free.png" title="pwndbg 1" width="300px" height="200px">

<p>First, the <code>top</code> chunk’s size is still <code>0x20d01</code> rather than <code>0x20d00</code>, which indicates the <code>P</code> bit is equal to 1. Second, the <code>Free chunk</code> only has one pointer: <code>fd</code>. If it’s in a double-linked list, both <code>fd</code> and <code>bk</code> should point to a valid address. </p>
<h4 id="Per-thread-cache-without-lock-contention"><a href="#Per-thread-cache-without-lock-contention" class="headerlink" title="Per-thread cache without lock contention"></a>Per-thread cache without lock contention</h4><p>The letter <code>t</code> in <code>tcache bins</code> represents the <code>thread</code>, which is used to optimize the performance of multi-thread programs. In multi-thread programming, the most common way solution to prevent the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition"><code>race condition</code></a> issue is using the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lock_(computer_science)"><code>lock or mutex</code></a>. Similarly, The <code>glibc</code> maintains a <code>lock</code> in the data structure for each heap. But this design comes with a performance cost: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lock_(computer_science)#:~:text=lock%20contention%3A%20this%20occurs%20whenever,lock%20held%20by%20the%20other."><code>lock contention</code></a>, which happens when one thread attempts to acquire a lock held by another thread. This means the thread can’t do any tasks. </p>
<p><code>tcache bins</code> are per-thread bins. This means if the thread has a chunk on its <code>tcache bins</code>, it can serve the allocation without waiting for the heap lock!  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examined how the userland heap allocaor works by debugging into the heap memory with gdb. The discussion is fully based on the <code>glibc</code> implementation. The design and behavior of the <code>glibc</code> heap allocator are complex but interesting, what we covered here just touches the tip of the iceberg. You can explore more by yourself. </p>
<p>Moreover, I plan to write a simple version of a heap allocator for learning and teaching purpose. Please keep watching my blog!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/10/10/userland-memory-allocation-three/" data-id="cl95b06vp002obomm7wc4gacz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-userland-memory-allocation-two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/08/userland-memory-allocation-two/" class="article-date">
  <time datetime="2022-09-08T07:43:57.000Z" itemprop="datePublished">2022-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/08/05/userland-memory-allocation-one/">article</a> gave a general overview of memory management. The story goes on. In this section, let’s break into the heap memory to see how it works basically. </p>
<h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><p>We need to first understand some terminology in the memory management field: </p>
<ul>
<li><strong>mutator</strong>: the program that modifies the objects in the heap, which is simply the user application. But I will use the term <code>mutator</code> in this article. </li>
<li><strong>allocator</strong>: the <code>mutator</code> doesn’t allocate memory by itself, it delegates this generic job to the <code>allocator</code>. At the code level, the <code>allocator</code> is generally implemented as a library. The detailed allocation behavior is fully determined by the implementations, in this article I will focus on the memory allocator in the library of <code>glibc</code>.  </li>
</ul>
<p>The relationship between the <code>mutator</code> and <code>allocator</code> is shown in the following diagram: </p>
<img src="/images/memo-allocator.png" title="memory allocator" width="400px" height="300px">

<p>There is a third component in the memory management field: the <code>garbage collector(GC)</code>. <code>GC</code> reclaims memories automatically. Since this article is talking about manual heap memory allocation in system programming, we will ignore <code>GC</code> for now. <code>GC</code> is a very interesting technical challenge, I will examine it in the future. Please keep watching my blog!</p>
<h3 id="Hands-on-demo"><a href="#Hands-on-demo" class="headerlink" title="Hands-on demo"></a>Hands-on demo</h3><p>We will use <code>gdb</code> and <code>pwndbg</code>(which is a gdb <a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg">plugin</a>) and break into the heap memory to see how it works. The <code>gdb</code> provides the functionality to extend it via <code>Python</code> plugins. <code>pwndbg</code> is the most widely used. </p>
<p>The demo code is as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">&quot;AAAABBBBCCCCDDDD&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The demo code above just allocates some memory, set the content of the memory and releases it later. And then allocate other chunks of memory again. Very simple, all right? </p>
<p>First, set a <code>breakpoint</code> at line 7(the first <code>malloc</code> call) and run the program in <code>gdb</code>. Then run <code>vmmap</code> command from <code>pwndbg</code>, which can get the process memory layout as follows: </p>
<img src="/images/heap-demo-vmmap-no-heap.png" title="pwndbg 1" width="800px" height="600px">

<p>Note that there is no <code>heap</code> segment yet before the first <code>malloc</code> call is made. After step over one line in <code>gdb</code>, check the layout again: </p>
<img src="/images/heap-demo-vmmap-has-heap.png" title="pwndbg 2" width="800px" height="600px">

<p>Now the <code>heap</code> segment is created with the size of <code>132KB</code>(21000 in hexadecimal). As described above, the kernel maps 132KB of physical memory to this process’s virtual memory and marks this 132KB block of physical memory as used to isolate other processes. This mapping routine is done via system calls like <code>brk</code>, <code>sbrk</code> and <code>mmap</code>. Please investigate these system calls yourself.</p>
<p>132KB is much bigger than the 100B(the size passed to <code>malloc</code>). This behavior can answer one question at the beginning of this article. The system calls aren’t necessary to be triggered each time when <code>malloc</code> is called. This design is aimed to decrease performance overhead. Now the 132KB heap memory is maintained by the <code>allocator</code>. Next time the application calls <code>malloc</code> again, the <code>allocator</code> will allocate memory for it. </p>
<p>Next, step one more line in <code>gdb</code> to assign value(“AAAABBBBCCCCDDDD”) to the allocated block. Let’s check the content of this 132KB heap segment with <code>heap</code> command as follows:</p>
<img src="/images/heap-demo-heap.png" title="pwndbg 3" width="300px" height="200px">

<p>There are 3 chunks. Let’s examine these chunks one by one. </p>
<p>The <code>top</code> chunk contains all the remaining memories which have not been allocated yet. In our case, the kernel maps 132KB of physical memory to this process. And 100B memory is allocated by calling <code>malloc(100)</code>, so the remaining memories are in the <code>top</code> chunk. The <code>top</code> chunk stays on the border of the heap segment, and it can grow and shrink as the process allocates more memory or release unused memory. </p>
<p>Then let’s look at the chunk with the size of 0x291. The <code>allocator</code> uses this chunk to store heap management structures. It is not important for our analysis, just skip it. </p>
<p>What we care about is the chunk in the middle with a size of <code>0x71</code>. It should be the block we requested and contains the string “AAAABBBBCCCCDDDD”. We can verify this point by checking its content:</p>
<img src="/images/heap-demo-display.png" title="pwndbg 3" width="600px" height="400px">

<p>gdb’s <a target="_blank" rel="noopener" href="https://visualgdb.com/gdbreference/commands/x"><code>x</code></a> command can display the memory contents at a given address using the specified format. <code>x/40wx 0x555555559290</code> prints 40 words(each word is 32 bits) of memories starting from 0x555555559290 in the hexadecimal format.</p>
<p>We can see that the string “AAAABBBBCCCCDDDD” is there. So our guess is correct. But the question is why the size of this chunk is <code>0x71</code>. To understand this, we need to first analyze how the <code>allocator</code> stores <code>chunk</code>. A chunk of memory is represented by the following structure: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (only if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>prev_size</code>: the size of the previous chunk only when the previous chunk is free, otherwise when the previous chunk is in use it stores the user data of the previous chunk. </li>
<li><code>size</code>: the size of the current chunk.</li>
<li><code>fd</code>: pointer to the next free chunk only when the current chunk is free, otherwise when the current chunk is in use it stores the user data.</li>
<li><code>bk</code>: pointer to the previous free chunk. Behaves in the same way as pointer <code>fd</code>.  </li>
</ul>
<p>Based on the above description, the following picture illustrates the exact structure of an allocated <code>chunk</code>: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if freed                  | </span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk: indicates the real starting address of the object in the heap memory. </li>
<li>mem: indicates the returned address by <code>malloc</code>. </li>
</ul>
<p>The memory in between is reserved for the metadata mentioned above: <code>prev_size</code> and <code>size</code>. On a 64-bit system, they’re (type of <code>INTERNAL_SIZE_T</code>) 8 bytes in length. </p>
<p>For the <code>size</code> field, it is worth noting: </p>
<ul>
<li>It includes both the size of metadata and the size of the actual user data.</li>
<li>It is usually aligned to a multiple of 16 bytes. You can investigate the <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/381244/purpose-of-memory-alignment">purpose of memory alignment</a> by yourself.</li>
<li>It contains three special flags(<code>A|M|P</code>) at the three least significant bits. We can ignore the other two bits for now, but the last bit indicates whether the previous chunk is in use(set to 1) or not(set to 0). </li>
</ul>
<p>According to this, let’s review the content of this chunk again:</p>
<img src="/images/heap-demo-display-mark.png" title="pwndbg 3" width="600px" height="400px">

<p>I add marks on the image to help you understand. Let’s do some simple calculations. <code>100 + 8 = 108</code>, 100 is the size of memory we requested, 8 is the size of metadata(for <code>size</code> field). Then <code>108</code> is aligned to <code>112</code> as a multiple of 16 bytes. Finally, since the special flag P is set to 1, then we get <code>112 + 1 = 113(0x71)</code>(that’s the reason why the size is <code>0x71</code> instead of <code>0x70</code>).  </p>
<p>In this section, we break into the heap segment and see how an allocated chunk works. Next, we’ll check how to free a chunk. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/09/08/userland-memory-allocation-two/" data-id="cl95b06vq002sbomm4ooxcvmq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-userland-memory-allocation-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/05/userland-memory-allocation-one/" class="article-date">
  <time datetime="2022-08-05T12:31:11.000Z" itemprop="datePublished">2022-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/05/userland-memory-allocation-one/">Understand userland heap memory allocation: part one - overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In my eyes, compared with developing applications with high-level programming languages, one of the biggest differences for system programming with low-level languages like C and C++, is you have to manage the memory by yourself. So you call APIs like <code>malloc</code>, and <code>free</code> to allocate the memory based on your need and release the memory when the resource is no longer needed. It is not only one of the most frequent causes of <a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2021/11/01/debug-memory-errors-valgrind-and-gdb">bugs</a> in system programming; but also can lead to many <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_safety">security issues</a>. </p>
<p>It’s not difficult to understand the correct usage of APIs like <code>malloc</code>, and <code>free</code>. But have you ever wondered how they work, for example: </p>
<ul>
<li>When you call <code>malloc</code>, does it trigger system calls and delegate the task to the kernel or there are some other mechanisms? </li>
<li>When you call <code>malloc(10)</code> and try to allocate 10 bytes of heap memory, how many bytes of memory do you get? 10 bytes or more?</li>
<li>When the memory is allocated, where exactly the heap objects are located?</li>
<li>When you call <code>free</code>, is the memory directly returned to the kernel? </li>
</ul>
<p>This article will try to answer these questions. </p>
<p>Note that memory is a super complex topic, so I can’t cover everything about it in one article (In fact, what is covered in this article is very limited). This article will focus on <code>userland memory(heap) allocation</code>. </p>
<h3 id="Process-memory-management-overview"><a href="#Process-memory-management-overview" class="headerlink" title="Process memory management overview"></a>Process memory management overview</h3><h4 id="Process-virtual-memory"><a href="#Process-virtual-memory" class="headerlink" title="Process virtual memory"></a>Process virtual memory</h4><p>Every time we start a program, a memory area for that program is reserved, and that’s <code>process virtual memory</code> as shown in the following image: </p>
<img src="/images/process-memory-address.png" title="process virtual memory" width="400px" height="300px">

<p>You can note that each process has one <strong>invisible</strong> memory segment containing kernel codes and data structures. This invisible memory segment is important; since it’s directly related to <code>virtual memory</code>, which is employed by the kernel for memory management. Before we dive into the other different segments, let’s understand virtual memory first. </p>
<h4 id="Virtual-memory-technique"><a href="#Virtual-memory-technique" class="headerlink" title="Virtual memory technique"></a>Virtual memory technique</h4><img src="/images/virtual-memory-technique.png" title="virtual memory technique" width="600px" height="400px">

<p>Why do we need virtual memory? Virtual memory is a service provided by the kernel in the form of abstraction. Without virtual memory, applications would need to manage their physical memory space, coordinating with every other process running on the computer. Virtual memory leaves that management to the kernel by creating the maps that allow translation between virtual and physical memory.  The kernel creates an illusion that each process occupies the entire physical memory space. We can also realize <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_isolation">process isolation</a> based on virtual memory to enhance security. </p>
<p>Virtual memory is out of this article’s scope, if you’re interested, please take a look at the core techniques: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_paging">paging</a> and <a target="_blank" rel="noopener" href="https://linuxhint.com/linux-memory-management-swap-space/">swapping</a>. </p>
<h4 id="Static-vs-Dynamic-memory-allocation"><a href="#Static-vs-Dynamic-memory-allocation" class="headerlink" title="Static vs Dynamic memory allocation"></a>Static vs Dynamic memory allocation</h4><p>Next, let’s take a close look at the process memory layout above and understand where they are from. Generally speaking, there are two ways via which memories can be allocated for storing data: <code>static</code> and <code>dynamic</code>. Static memory allocation happens at <code>compile time</code>, while dynamic memory allocation occurs at <code>runtime</code>. </p>
<p>When a program started, the executable file(on the Linux system, it’s called an <code>ELF</code> file) will be loaded into the memory as a <code>Process Image</code>. This <code>ELF</code> file contains the following segments:</p>
<ul>
<li>.TEXT: contains the executable part of the program with all the machine codes.</li>
<li>.DATA: contains <code>initialized</code> static and global variables. </li>
<li>.BSS: is short for <code>block started by symbol</code> contains <code>uninitialized</code> static and global variables. </li>
</ul>
<p>The <code>ELF</code> file will be loaded by the kernel and create a process image. And these static data will be mapped into the corresponding segments of the virtual memory. The <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/article/1060">ELF loader</a> is also an interesting topic, I will write another article about it in the future. Please keep watching my blog!</p>
<p>The <code>memory-mapped region</code> segment is used for storing the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2019/08/25/how-to-write-linux-c-program-with-external-library/">shared libraries</a>. </p>
<p>Finally, <code>stack</code> and <code>heap</code> segments are produced at runtime dynamically, which are used to store and operate on temporary variables that are used during the execution of the program. Previously, I once wrote an article about the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2020/08/19/stack-frame/">stack</a>, please refer to it if you want to know the details.</p>
<p>The only remaining segment we didn’t mention yet is the <code>heap</code>, which is this article’s focus! </p>
<p>You can check the memory layout of one process by examining this file <code>/proc/&#123;pid&#125;/maps</code> as below: </p>
<img src="/images/maps-capture.png" title="proc/pid/maps" width="800px" height="600px">

<p>Note that the above investigation doesn’t consider multiple threads. The memory layout of the process with multi-threads will be more complex, please refer to other online <a target="_blank" rel="noopener" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">documents</a>.</p>
<p>In this section, we had a rough overview of memory management from top to bottom. Hope you can see the big picture and know where we are. Next, let’s dig into the <code>heap</code> segment and see how it works. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/08/05/userland-memory-allocation-one/" data-id="cl95b06vn002ibommhvdv09ax" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CPacketSniffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/22/CPacketSniffer/" class="article-date">
  <time datetime="2022-07-22T02:19:48.000Z" itemprop="datePublished">2022-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/22/CPacketSniffer/">cPacketSniffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this post, I want to introduce my new project: <a target="_blank" rel="noopener" href="https://github.com/baoqger/cPacketSniffer"><code>cPacketSniffer</code></a>. I worked on it for the past two months. Finally, I worked it out and feel very proud of putting it here!</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Simply speaking, I want to sharpen my techniques in <code>network programming</code> and <code>Linux system programming</code>. Both of these two topics can lead you to the bottom of computers or software. Feynman said <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/There%27s_Plenty_of_Room_at_the_Bottom">“There is plenty of room at the bottom”</a>, I think this physics law can apply to software as well. </p>
<h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><p>It’s very lucky for me to come across this site <a target="_blank" rel="noopener" href="http://tcpip.marcolavoie.ca/index.html">“Network programming in Linux”</a>, which developed a network packet capturing tool with <code>C++</code>. After confirming that the documents and source code on this site is completed and clear, I decided to refactor it with C language. That’s the starting point for my project <code>cPacketSniffer</code>.      </p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>As a network packets sniffer, <code>cPacketSniffer</code> provides the following features: </p>
<img src="/images/cPacketSniffer.png" title="cPacketSniffer modules" width="600px" height="400px">

<ul>
<li>Integrate with <code>libpcap</code> to support: filtering captured packets, capturing packets offline, capturing packets on specific devices and capturing packets in promiscuous mode.</li>
<li>Analyze network packets at low layers of TCP/IP stack, including <code>Ethernet</code>, <code>ARP</code>, <code>ICMP</code>, <code>IP(IPv4)</code>, <code>TCP</code>, <code>UDP</code>, etc. Also one protocol in the application layer: <code>TFTP</code>. </li>
<li>Detect network security attacks:<ul>
<li>ARP spoofing detection.</li>
<li>Ping flood detection.</li>
</ul>
</li>
<li>Analyze and track network traffics:<ul>
<li>TCP session tracking and traffic analysis.</li>
<li>TFTP session tracking and traffic analysis.</li>
</ul>
</li>
</ul>
<p>The following images demonstrate some typical usages of <code>cPacketSniffer</code>:  </p>
<p><strong>Packet Analysis</strong>:</p>
<img src="/images/packet-analysis.png" title="packet analysis" width="600px" height="400px">

<p><strong>ARP Spoofing Detection</strong>:</p>
<img src="/images/arpspoof.png" title="arp spoofing detection" width="600px" height="400px">

<p><strong>PING Flood Detection</strong>:</p>
<img src="/images/pingflooddetection.png" title="ping flood detection" width="600px" height="400px">

<p><strong>TCP Session Tracking</strong>:</p>
<img src="/images/tcpsessiontrack.png" title="tcp session track" width="600px" height="400px">

<p>Besides the above network programming-related functionalities, it also covers the following points: </p>
<ul>
<li>Develop a generic data structure in C.</li>
<li>Error handling in C. </li>
<li>Data encapsulation (object-oriented style programming) in C.</li>
<li>Manual memory management in C.</li>
<li>etc.</li>
</ul>
<p>This article will not cover these points in detail, I will write articles on these topics separately in the future. Please keep watching my blog!</p>
<h3 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h3><p>Now <code>cPacketSniffer</code> can work as a network packet sniffer based on the design. Moreover, it can also serve as a testbed to try experimental features. Next step I plan to try the following ideas:</p>
<ul>
<li>Implement the network intrusion detection function. </li>
<li>Improve the performance with advanced data structures, like binary search trees. </li>
<li>Memory and cache performance tuning. </li>
<li>Automatic memory management by Garbage Collection.</li>
<li>Integrate <code>ncurses</code> for Text-based user interface.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/07/22/CPacketSniffer/" data-id="cl95b06us0003bomm8fwz05d1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/" class="article-date">
  <time datetime="2022-06-08T06:59:19.000Z" itemprop="datePublished">2022-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/">Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/">article</a>, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a <code>Netfilter</code> module as our mini-firewall.  </p>
<h3 id="Netfilter-architecture"><a href="#Netfilter-architecture" class="headerlink" title="Netfilter architecture."></a>Netfilter architecture.</h3><h5 id="Basics-of-Netfilter-hooks"><a href="#Basics-of-Netfilter-hooks" class="headerlink" title="Basics of Netfilter hooks"></a>Basics of Netfilter hooks</h5><p><strong>The <code>Netfilter</code> framework provides a bunch of <code>hooks</code> in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well</strong>. And Netfilter allows you to write modules and register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? </p>
<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

<p>Currently, Netfilter provides the following 5 hooks for <code>IPv4</code>:</p>
<ul>
<li><em>NF_INET_PRE_ROUTING</em>: is triggered right after the packet has been received on a network card. This hook is triggered before the <code>routing decision</code> was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. </li>
<li><em>NF_INET_LOCAL_IN</em>: is triggered for network packets that are destined for the current host. </li>
<li><em>NF_INET_FORWARD</em>: is triggered for network packets that should be forwarded. </li>
<li><em>NF_INET_POST_ROUTING</em>: is triggered for network packets that have been routed and before being sent out to the network card. </li>
<li><em>NF_INET_LOCAL_OUT</em>: is triggered for network packets generated by the processes on the current host.</li>
</ul>
<p>The hook function you defined in the module can mangle or filter the packets, but it eventually must return a status code to Netfilter. There are several possible values for the code, but for now, you only need to understand two of them: </p>
<ul>
<li><em>NF_ACCEPT</em>: this means the hook function accepts the packet and it can go on the network stack trip. </li>
<li><em>NF_DROP</em>: this means the packet is dropped and no further parts of the network stack will be traversed.</li>
</ul>
<p>Netfilter allows you to register multiple callback functions to the same hook with different priorities. If the first hook function accepts the packet, then the packet will be passed to the next functions with low priority. If the packet is dropped by one callback function, then the next functions(if existing) will not be traversed. </p>
<p>As you see, <code>Netfilter</code> has a big scope and I can’t cover every detail in the articles. So the mini-firewall developed here will work on the hook <code>NF_INET_PRE_ROUTING</code>, which means it works by controlling the inbound network traffic. But the way of registering the hook and handling the packet can be applied to all other hooks. </p>
<p><em>Note</em>: there is another remarkable question: what’s the difference between <code>Netfilter</code> and <code>eBPF</code>? If you don’t know eBPF, please refer to my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">article</a>. Both of them are important network features in the Linux kernel. The important thing is <code>Netfilter</code> and <code>eBPF</code> hooks are located in different layers of the Kernel. As I drew in the above diagram, <code>eBPF</code> is located in a lower layer. </p>
<h5 id="Kernel-code-of-Netfilter-hooks"><a href="#Kernel-code-of-Netfilter-hooks" class="headerlink" title="Kernel code of Netfilter hooks"></a>Kernel code of Netfilter hooks</h5><p>To have a clear understanding of how the <code>Netfilter</code> framework is implemented inside the protocol stack, let’s dig a little bit deeper and take a look at the kernel source code (Don’t worry, only shows several simple functions). Let’s use the hook <code>NF_INET_PRE_ROUTING</code> as an example; since the mini-firewall will be written based on it. </p>
<p>When an IPv4 packet is received, its handler function <code>ip_rcv</code> will be called as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/net/ipv4/ip_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">        skb = ip_rcv_core(skb, net);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">        <span class="comment">// run Netfilter NF_INET_PRE_ROUTING hook&#x27;s callback function</span></span><br><span class="line">        <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, </span><br><span class="line">                       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">                       ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this handler function, you can see the hook is passed to the function <code>NF_HOOK</code>. Based on the name <code>NF_HOOK</code>, you can guess that it is for triggering the Netfilter hooks. Right? Let’s continue to examine how <code>NF_HOOK</code> is implemented as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">                ret = okfn(net, sk, skb); <span class="comment">// in our case: okfn is ip_rcv_finish</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      nf_hook - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *      okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *      value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code omit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>NF_HOOK</code> contains two steps:</p>
<ul>
<li>First, runs the hook’s callback functions by calling the underlying function <code>nf_hook</code>. </li>
<li>Second, invokes the function <code>okfn</code> (passed to <em>NF_HOOK</em> as the argument), if the packet passes through the hook functions and doesn’t drop.</li>
</ul>
<p>For the hook <em>NF_INET_LOCAL_IN</em>, the function <code>ip_rcv_finish</code> will be invoked after the hook functions pass. Its job is to pass the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey! </p>
<p>The other 4 hooks all use the same function <code>NF_HOOK</code> to trigger the callback functions. The following table shows where the hooks are embedded in the kernel, I leave them to the readers. </p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>File</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>NF_INET_PRE_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_rcv()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_IN</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_local_deliver()</td>
</tr>
<tr>
<td>NF_INET_FORWARD</td>
<td>/kernel-src/net/ipv4/ip_forward.c</td>
<td>ip_forward()</td>
</tr>
<tr>
<td>NF_INET_POST_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_build_and_send_pkt()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_OUT</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_output()</td>
</tr>
</tbody></table>
<p>Next, Let’s review the Netfilter’s APIs to create and register the hook function. </p>
<h3 id="Netfilter-API"><a href="#Netfilter-API" class="headerlink" title="Netfilter API"></a>Netfilter API</h3><p>It’s straightforward to create a Netfilter module, which involves three steps: </p>
<ul>
<li>Define the hook function.</li>
<li>Register the hook function in the kernel module initialization process.</li>
<li>Unregister the hook function in the kernel module clean-up process. </li>
</ul>
<p>Let’s go through them quickly one by one. </p>
<h5 id="Define-a-hook-function"><a href="#Define-a-hook-function" class="headerlink" title="Define a hook function"></a>Define a hook function</h5><p>The hook function name can be whatever you want, but it must follow the signature below: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br></pre></td></tr></table></figure>

<p>The hook function can mangle or filter the packet whose data is stored in the <code>sk_buff</code> structure (we can ignore the other two parameters; since we don’t use them in our mini-firewall). As we mentioned above, the callback function must return a Netfilter status code which is an integer. For instance, the <code>accepted</code> and <code>dropped</code> status is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Responses from hook functions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_ACCEPT 1</span></span><br></pre></td></tr></table></figure>
<h5 id="Register-and-unregister-a-hook-function"><a href="#Register-and-unregister-a-hook-function" class="headerlink" title="Register and unregister a hook function"></a>Register and unregister a hook function</h5><p>To register a hook function, we should wrap the defined hook function with related information, such as which hook you want to bind to, the protocol family and the priority of the hook function,  into a structure <code>struct nf_hook_ops</code> and pass it to the function <code>nf_register_net_hook</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn               *hook;    <span class="comment">// callback function</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">dev</span>;</span>     <span class="comment">// network device interface</span></span><br><span class="line">        <span class="type">void</span>                    *priv; </span><br><span class="line">        <span class="type">u_int8_t</span>                pf;       <span class="comment">// protocol</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            hooknum;  <span class="comment">// Netfilter hook enum</span></span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="type">int</span>                     priority; <span class="comment">// priority of callback function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Most of the fields are very straightforward to understand. The one need to emphasize is the field <code>hooknum</code>, which is just the Netfilter hooks discussed above. They are defined as enumerators as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">	NF_INET_PRE_ROUTING,</span><br><span class="line">	NF_INET_LOCAL_IN,</span><br><span class="line">	NF_INET_FORWARD,</span><br><span class="line">	NF_INET_LOCAL_OUT,</span><br><span class="line">	NF_INET_POST_ROUTING,</span><br><span class="line">	NF_INET_NUMHOOKS,</span><br><span class="line">	NF_INET_INGRESS = NF_INET_NUMHOOKS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Next, let’s take a look at the functions to register and unregister hook functions goes as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Function to register/unregister hook points. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter <code>struct net</code> is related to the network namespace, we can ignore it for now and use a default value. </p>
<p>Next, let’s implement our mini-firewall based on these APIs. All right? </p>
<h3 id="Implement-mini-firewall"><a href="#Implement-mini-firewall" class="headerlink" title="Implement mini-firewall"></a>Implement mini-firewall</h3><p>First, we need to clarify the requirements for our mini-firewall. We’ll implement two network traffic control rules in the mini-firewall as follows:</p>
<ul>
<li><em>Network protocol rule</em>: drops the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a> protocol packets.</li>
<li><em>IP address rule</em>: drops the packets from one specific IP address.</li>
</ul>
<p>The completed code implementation is in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">repo</a>.</p>
<h5 id="Drop-ICMP-protocol-packets"><a href="#Drop-ICMP-protocol-packets" class="headerlink" title="Drop ICMP protocol packets"></a>Drop ICMP protocol packets</h5><p><code>ICMP</code> is a network protocol widely used in the real world. The popular diagnostic tools like <code>ping</code> and <code>traceroute</code> run the ICMP protocol. We can filter out the ICMP packets based on the protocol type in the IP headers with the following hook function: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockicmppkt_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span>   <span class="comment">// IP header</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span> <span class="comment">// UDP header</span></span><br><span class="line">	<span class="keyword">if</span>(!skb)</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	iph = ip_hdr(skb); <span class="comment">// retrieve the IP headers from the packet</span></span><br><span class="line">	<span class="keyword">if</span>(iph-&gt;protocol == IPPROTO_UDP) &#123; </span><br><span class="line">		udph = udp_hdr(skb);</span><br><span class="line">		<span class="keyword">if</span>(ntohs(udph-&gt;dest) == <span class="number">53</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept UDP packet</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;Drop ICMP packet \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> NF_DROP;   <span class="comment">// drop TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic in the above hook function is easy to understand. First, we retrieve the IP headers from the network packet. And then according to the <code>protocol</code> type field in the headers, we decided to accept TCP and UDP packets but drop the ICMP packets. The only technique we need to pay attention to is the function <code>ip_hdr</code>, which is the kernel function defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/ip.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">ip_hdr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In source code file /kernel-src/include/linux/skbuff.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>ip_hdr</code> delegates the task to the function <code>skb_network_header</code>. It gets IP headers based on the following two data: </p>
<ul>
<li>head: is the pointer to the packet;</li>
<li>network_header: is the offset between the pointer to the packet and the pointer to the network layer protocol header. In detail, you can refer to this <a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html">document</a>.</li>
</ul>
<p>Next, we can register the above hook function as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">nf_blockicmppkt_ops</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	nf_blockicmppkt_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hook = (nf_hookfn*)nf_blockicmppkt_handler;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;priority = NF_IP_PRI_FIRST; <span class="comment">// set the priority</span></span><br><span class="line">		</span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">nf_minifirewall_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_unregister_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">		kfree(nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(nf_minifirewall_init);</span><br><span class="line">module_exit(nf_minifirewall_exit);</span><br></pre></td></tr></table></figure>

<p>The above logic is self-explaining. I will not spend too much time here. </p>
<p>Next, it’s time to demo how our mini-firewall works. </p>
<h5 id="Demo-time"><a href="#Demo-time" class="headerlink" title="Demo time"></a>Demo time</h5><p>Before we load the mini-firewall module, the <code>ping</code> command can work as expected: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">3</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">4</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time 3005ms</span><br><span class="line">rtt <span class="built_in">min</span>/avg/<span class="built_in">max</span>/mdev = <span class="number">71.857</span>/<span class="number">71.902</span>/<span class="number">71.961</span>/<span class="number">0.193</span> ms</span><br></pre></td></tr></table></figure>

<p>In contrast, after the mini-firewall module is built and loaded (based on the commands we discussed previously): </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">mini_firewall          <span class="number">16384</span>  <span class="number">0</span></span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.105</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">6</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 5097ms</span><br></pre></td></tr></table></figure>

<p>You can see all the packets are lost; because it is dropped by our mini-firewall. We can verify this by running the command <code>dmesg</code>: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">1260.184712</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1261.208637</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1262.232669</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1263.256757</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1264.280733</span>] Drop ICMP packet</span><br></pre></td></tr></table></figure>

<p>But other protocol packets can still run through the firewall. For instance, the command <code>wget 142.250.4.103</code> can return normally as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">302</span> Moved Temporarily</span><br><span class="line">Location: http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f [following]</span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">3248</span> (<span class="number">3.2</span>K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                                           <span class="number">100</span>%[===================================================================================================================&gt;]   <span class="number">3.17</span>K  --.-KB/s    <span class="keyword">in</span> 0s</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span> (<span class="number">332</span> MB/s) - ‘index.html’ saved [<span class="number">3248</span>/<span class="number">3248</span>]</span><br></pre></td></tr></table></figure>

<p>Next, let’s try to ban the traffic from this IP address. </p>
<h5 id="Drop-packets-source-from-one-specific-IP-address"><a href="#Drop-packets-source-from-one-specific-IP-address" class="headerlink" title="Drop packets source from one specific IP address"></a>Drop packets source from one specific IP address</h5><p>As we mentioned above, multiple callback functions are allowed to be registered on the same Netfilter hook. So we will define the second hook function with a different priority. The logic of this hook function goes like this: we can get the source IP address from the IP headers and make the drop or accept decision according to it. The code goes as follows</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS(addr) \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[3], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[2], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[1], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[0]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ip_addr_rule = <span class="string">&quot;142.250.4.103&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockipaddr_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">char</span> *str = (<span class="type">char</span> *)kmalloc(<span class="number">16</span>, GFP_KERNEL);</span><br><span class="line">		u32 sip;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">sb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">		sb = skb;</span><br><span class="line">		iph = ip_hdr(sb);</span><br><span class="line">		sip = ntohl(iph-&gt;saddr); <span class="comment">// get source ip address; </span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sprintf</span>(str, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, IPADDRESS(sip)); <span class="comment">// convert to standard IP address format</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str, ip_addr_rule)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This hook function uses two interesting techniques:</p>
<ul>
<li><p><code>ntohl</code>: is a kernel function, which is used to convert the value from <code>network byte order</code> to <code>host byte order</code>. <code>Byte order</code> is related to the computer science concept of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness"><code>Endianness</code></a>. Endianness defines the order or sequence of bytes of a word of digital data in computer memory. A <code>big-endian</code> system stores the most significant byte of a word at the smallest memory address.  A <code>little-endian</code> system, in contrast, stores the least-significant byte at the smallest address. Network protocol uses the <code>big-endian</code> system. But different OS and platforms run various Endianness system. So it may need such conversion based on the host machine.</p>
</li>
<li><p><code>IPADDRESS</code>: is a macro, which generates the standard IP address format(four 8-bit fields separated by periods) from a 32-bit integer. It uses the technique of <a target="_blank" rel="noopener" href="https://www.eskimo.com/~scs/cclass/notes/sx10e.html"><code>the equivalence of arrays and pointers in C</code></a>. I will write another article to examine what it is and how it works. Please keep watching my updates!</p>
</li>
</ul>
<p>Next, we can register this hook function in the same way discussed above. The only remarkable point is this callback function should have a different priority as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">	nf_blockipaddr_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockipaddr_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hook = (nf_hookfn*)nf_blockipaddr_handler;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hooknum = NF_INET_PRE_ROUTING;  <span class="comment">// register to the same hook</span></span><br><span class="line">		nf_blockipaddr_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockipaddr_ops-&gt;priority = NF_IP_PRI_FIRST + <span class="number">1</span>; <span class="comment">// set a higher priority</span></span><br><span class="line"></span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockipaddr_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s see how it works with a demo. </p>
<h5 id="Demo-time-1"><a href="#Demo-time-1" class="headerlink" title="Demo time"></a>Demo time</h5><p>After re-build and re-load the module, we can get: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">20</span>:07--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. failed: Connection timed out.</span><br><span class="line">Retrying.</span><br></pre></td></tr></table></figure>

<p>The <code>wget 142.250.4.103</code> can’t return response. Because it is dropped by our mini-firewall. Great!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">3162.064284</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.089466</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.288603</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.345463</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.480123</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br></pre></td></tr></table></figure>

<h3 id="More-space-to-expand"><a href="#More-space-to-expand" class="headerlink" title="More space to expand"></a>More space to expand</h3><p>You can find the full code implementation <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">here</a>. But I have to say, our mini-firewall only touches the surface of what Netfilter can provide. You can keep expanding the functionalities. For example, currently, the rules are hardcoded, why not make it possible to config the rules dynamically. There are many cool ideas worth trying. I leave it for the readers.  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we implement the mini-firewall step by step and examined many detailed techniques. Not only code; but we also verify the behavior of the mini-firewall by running real demos.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/06/08/how-to-write-a-netfilter-firewall-part3/" data-id="cl95b06vw003bbommgbe992dj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/" class="article-date">
  <time datetime="2022-05-05T10:06:50.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two - hello world module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/04/how-to-write-a-netfilter-firewall-part1/">article</a>, we examined the basics of <code>Netfilter</code> and <code>Linux kernel modules</code> in theory. Starting from this article, we will make our hands dirty and start implementing our mini-firewall. We will walk through the whole process step by step. In this article, let’s write our first Linux kernel module using a simple <code>hello world</code> demo. Then let’s learn how to build the module(which is very different from compiling an application in the user space) and how to load it in the kernel. After understanding how to write a module, in the next article, let’s write the initial version of our mini-firewall module using <a target="_blank" rel="noopener" href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter’s hook architecture</a>. All right. Let’s start the journey. </p>
<h3 id="Make-the-first-Kernel-module"><a href="#Make-the-first-Kernel-module" class="headerlink" title="Make the first Kernel module"></a>Make the first Kernel module</h3><p>First, I have to admit that Linux Kernel module development is a kind of large and complex technology topic. And there are many great <a target="_blank" rel="noopener" href="https://sysprog21.github.io/lkmpg/">online resources</a> about it. This series of articles is focusing on developing the mini-firewall based on Netfilter, so we can’t cover all the aspects of the Kernel module itself. In future articles, I’ll examine more in-depth knowledge of kernel modules. </p>
<h4 id="Write-the-module"><a href="#Write-the-module" class="headerlink" title="Write the module"></a>Write the module</h4><p>You can write the <code>hello world</code> Kernel module with a single <code>C</code> source code file <code>hello.c</code> as follows:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>We can write a Kernel module in such an easy and simple way because the Linux Kernel does the magic for you. Remember the design philosophy of Linux(Unix): <strong><em>Design for simplicity; add complexity only where you must</em></strong>. </p>
<p>Let’s examine several technical points worth to remark as follows: </p>
<p>First, Kernel modules must have at least two functions: a “start” function which is called when the module is loaded into the kernel, and an “end” function which is called just before it is removed from the kernel. Before kernel 2.3.13, the names of these two functions are hardcoded as <code>init_module()</code> and <code>cleanup_module()</code>. But in the new versions, you can use whatever name you like for the start and end functions of a module by using the <code>module_init</code> and <code>module_exit</code> macros. The macros are defined in <code>include/linux/module.h</code> and <code>include/linux/init.h</code>. You can refer there for detailed information. </p>
<p>Typically, <code>module_init</code> either registers a handler for something with the kernel (for example, the mini-firewall developed in this article), or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <code>module_exit</code> function is supposed to undo whatever <code>module_init</code> did, so the module can be unloaded safely.</p>
<p>Second, <code>printk</code> function provides similar behaviors to <code>printf</code>, which accepts the <code>format string</code> as the first argument. The <code>printk</code> function prototype goes as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>printk</code> function allows a caller to specify <code>log level</code> to indicate the type and importance of the message being sent to the kernel message log. For example, in the above code, the log level <code>KERN_INFO</code> is specified by prepending to the format string. In C programming, this syntax is called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/String_literal#String_literal_concatenation"><code>string literal concatenation</code></a>. (In other high-level programming languages, string concatenation is generally done with <code>+</code> operator). For the function <code>printk</code> and <code>log level</code>, you can find more information in <code>include/linux/kern_levels.h</code> and <code>include/linux/printk.h</code>.   </p>
<p>Note: The path to header files for Linux kernel module development is different from the one you often used for the application development. Don’t try to find the header file inside <em>/usr/include/linux</em>, instead please use the following path <em>/lib/modules/`uname -r`/build/include/linux</em> (<code>uname -r</code> command returns your kernel version).</p>
<p>Next, let’s build this hello-world kernel module.</p>
<h4 id="Build-the-module"><a href="#Build-the-module" class="headerlink" title="Build the module"></a>Build the module</h4><p>The way to build a kernel module is a little different from how to build a user-space application. The efficient solution to build kernel image and its modules is <code>Kernel Build System(Kbuild)</code>. </p>
<p><code>Kbuild</code> is a complex topic and I won’t explain it in too much detail here. Simply speaking, <code>Kbuild</code> allows you to create highly customized kernel binary images and modules. Technically, each subdirectory contains a <code>Makefile</code> compiling only the source code files in its directory. And a top-level Makefile recursively executes each subdirectory’s Makefile to generate the binary objects. And you can control which subdirectories are included by defining <code>config files</code>. In detail, you can refer to other <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system">documents</a>. </p>
<p>The following is the Makefile for the <code>hello world</code> module: </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>The <code>make -C dir</code> command changes to directory dir before reading the makefiles or doing anything else. The top-level Makefile in <em>/lib/modules/$(shell uname -r)/build</em> will be used. You can find that command <code>make M=dir modules</code> is used to make all modules in specified dir.</p>
<p>And in the module-level Makefile, the <code>obj-m</code> syntax tells <code>kbuild</code> system to build <code>module_name.o</code> from <code>module_name.c</code>, and after linking, will result in the kernel module <code>module_name.ko</code>. In our case, the module name is <code>hello</code>.</p>
<p>The build process goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ sudo make</span><br><span class="line">make -C /lib/modules/4.15.0-176-generic/build M=/home/DIR/jbao6/develop/kernel/hello-1  modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br><span class="line">  CC [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/DIR/jbao6/develop/kernel/hello-1/hello.mod.o</span><br><span class="line">  LD [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br></pre></td></tr></table></figure>
<p>After the build, you can get several new files in the same directory: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ <span class="built_in">ls</span></span><br><span class="line">hello.c  hello.ko  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span><br></pre></td></tr></table></figure>
<p>The file ends with <code>.ko</code> is the kernel module. You can ignore other files now, I will write another article later to have a deep discussion about the kernel module system. </p>
<h4 id="Load-the-module"><a href="#Load-the-module" class="headerlink" title="Load the module"></a>Load the module</h4><p>With the <code>file</code> command, you can note that the kernel module is an <code>ELF(Executable and Linkable Format)</code> format file. ELF files are typically the output of a compiler or linker and are a binary format. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisba:~/develop/kernel/hello-1$ file hello.ko</span><br><span class="line">hello.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=f0da99c757751e7e9f9c4e55f527fb034a0a4253, not stripped</span><br></pre></td></tr></table></figure>

<p>Next step, let’s try to install and remove the module dynamically. You need to know the following three commands: </p>
<ul>
<li><em>lsmod</em>: shows the list of kernel modules currently loaded.</li>
<li><em>insmod</em>: inserts a module into the Linux Kernel by running <code>sudo insmod module_name.ko</code></li>
<li><em>rmmod</em>: removes a module from the Linux Kernel by running <code>sudo rmmod module_name</code></li>
</ul>
<p>Since the <code>hello world</code> module is quite simple, you can easily install and remove the module as you wish. I will not show the detailed commands here and leave it to the readers. </p>
<p><strong>Note</strong>: It doesn’t mean that you can easily install and remove any kernel module without any issues. If the module you are loading has bugs, the entire system can crash. </p>
<h4 id="Debug-the-module"><a href="#Debug-the-module" class="headerlink" title="Debug the module"></a>Debug the module</h4><p>Next step, let’s prove that the <code>hello world</code> module is installed and removed as expected. We will use <code>dmesg</code> command. <code>dmesg</code> (diagnostic messages) can print the messages in the <code>kernel ring buffer</code>. </p>
<p>First, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circular_buffer"><code>ring buffer</code></a> is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. The <code>kernel ring buffer</code> is a ring buffer that records messages related to the operation of the kernel. As we mentioned above, the kernel logs printed by the <code>printk</code> function will be sent to the kernel ring buffer. </p>
<p>We can find the messages produced by our module with command <code>dmesg | grep world</code> as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~$ dmesg | grep world</span><br><span class="line"></span><br><span class="line">[2147137.177254] Hello, world</span><br><span class="line">[3281962.445169] Goodbye, world</span><br><span class="line">[3282008.037591] Hello, world</span><br><span class="line">[3282054.921824] Goodbye, world</span><br></pre></td></tr></table></figure>

<p>Now you can see that the <code>hello world</code> is loaded into the kernel correctly. And it can be removed dynamically as well. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to write a kernel module, how to build it and how to install it into the kernel dynamically. Next article we can work on the mini-firewall as a <code>Netfilter</code> module. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/05/how-to-write-a-netfilter-firewall-part2/" data-id="cl95b06v9001abommb1nq6lmj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/" class="article-date">
  <time datetime="2022-05-04T10:06:50.000Z" itemprop="datePublished">2022-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><code>Firewalls</code> are an important tool that can be configured to protect your servers and infrastructure. Firewalls’ main functionalities are filtering data, redirecting traffic, and protecting against network attacks. There are both hardware-based firewalls and software-based firewalls. I will not discuss too much about the background here, since you can find many online documents about <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Firewall_(computing)">it</a>.</p>
<p>Have you ever thought of implementing a simple firewall from scratch? Sounds crazy? But with the power of Linux, you can do that. After you read this series of articles, you will find that actually, it is quite simple. </p>
<p>You may once use various firewalls on Linux such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iptables">iptables</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nftables">nftables</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall">UFW</a>, etc. All of these firewall tools are user-space utility programs, and they are all relying on <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netfilter"><code>Netfilter</code></a>. <code>Netfilter</code> is the Linux kernel subsystem that allows various networking-related operations to be implemented. <code>Netfilter</code> allows you to develop your firewall using the <code>Linux Kernel Module</code>.  If you don’t know the techniques such as the Linux Kernel module and Netfilter, don’t worry. In this article, let’s write a Linux firewall from scratch based on Netfilter. You can learn the following interesting points:</p>
<ul>
<li>Linux kernel module development.</li>
<li>Linux kernel network programming. </li>
<li>Netfilter module development.</li>
</ul>
<h3 id="Netfilter-and-Kernel-modules"><a href="#Netfilter-and-Kernel-modules" class="headerlink" title="Netfilter and Kernel modules"></a>Netfilter and Kernel modules</h3><h4 id="Basics-of-Netfilter"><a href="#Basics-of-Netfilter" class="headerlink" title="Basics of Netfilter"></a>Basics of Netfilter</h4><p><code>Netfilter</code> can be considered to be the third generation of <code>firewall</code> on Linux. Before <code>Netfilter</code>was introduced in Linux Kernel 2.4, there are two older generations of firewalls on Linux as follows: </p>
<ul>
<li>The first generation was a port of an early version of BSD UNIX’s <code>ipfw</code> to Linux 1.1. </li>
<li>The second generation was <code>ipchains</code> developed in the 2.2 series of Linux Kernel. </li>
</ul>
<p>As we mentioned above, <code>Netfilter</code> was designed to provide the infrastructure inside the Linux kernel for various networking operations. So <code>firewall</code> is just one of the multiple functionalities provided by <code>Netfilter</code> as follows:</p>
<img src="/images/netfilter-arch.png" title="Netfilter architecture" width="600px" height="400px">

<ul>
<li><strong>Packet filtering</strong>: is in charge of filtering the packets based on the rules. It is also the topic of this article. </li>
<li><strong>NAT (Network address translation)</strong>: is in charge of translating the IP address of network packets. <code>NAT</code> is an important protocol, which has become a popular and essential tool in <code>conserving global address space in the face of IPv4 address exhaustion</code>. If you don’t know <code>NAT</code> protocol, you can refer to other <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_address_translation">documents</a>. I will examine it in other future articles. </li>
<li><strong>Packet mangling</strong>: is in charge of modifying the packet content(In fact, <code>NAT</code> is one kind of packet mangling, which modifies the source or destination IP address). For example, <code>MSS (Maximum Segment Size)</code> value of TCP SYN packets can be altered to allow large-size packets transported over the network. </li>
</ul>
<p>Note: this article will focus on building a simple firewall to filter packets based on Netfilter. So the <code>NAT</code> and <code>Packet Mangling</code> parts are not in the scope of this article. </p>
<p>Packet filtering can only be done inside the Linux kernel (Netfilter’s code is in the kernel as well), if we want to write a mini firewall, it has to run in the kernel space. Right? Does it mean we need to add our code into the kernel and recompile the kernel? Imagine you have to recompile the kernel each time you want to add a new packet filtering rule. That’s a bad idea. The good news is that <code>Netfilter</code> allows you to add extensions using the <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Kernel_module"><code>Linux kernel modules</code></a>. </p>
<h4 id="Basics-of-Linux-Kernel-modules"><a href="#Basics-of-Linux-Kernel-modules" class="headerlink" title="Basics of Linux Kernel modules"></a>Basics of Linux Kernel modules</h4><p>Although Linux is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monolithic_kernel"><code>monolithic kernel</code></a>, it can be extended using kernel modules. Modules can be inserted into the kernel and removed on demand. Linux isolates the kernel but allows you to add specific functionality on the fly through modules. In this way, Linux keeps a balance between stability and usability. </p>
<p>I want to examine one confusing point about the kernel module here: what is the difference between <code>driver</code> and <code>module</code>:</p>
<ul>
<li>A driver is a bit of code that runs in the kernel to talk to some hardware device. It drives the hardware. Standard practice is to build drivers as kernel modules where possible, rather than link them statically to the kernel since that gives more flexibility. </li>
<li>A kernel module may not be a device driver at all.    </li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In the first post of this series, we examine the basics of Netfilter and Linux kernel modules. In the next post, let’s start implementing the mini firewall. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/04/how-to-write-a-netfilter-firewall-part1/" data-id="cl95b06va001cbomm8y4102nl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" class="article-date">
  <time datetime="2022-03-28T06:15:15.000Z" itemprop="datePublished">2022-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">previous article</a>, we examined how to develop a network sniffer with <code>PF_SOCKET</code> socket in Linux platform. The sniffer developed in the last article captures all the network packets. But a powerful network sniffer like <code>tcpdump</code> should provide the packet filtering functionality. For instance, the sniffer can only capture the <code>TCP</code> segment(and skip the UPD), or it can only capture the packets from a specific source IP address. In this article, let’s continue to explore how to do that. </p>
<h3 id="Background-of-BPF"><a href="#Background-of-BPF" class="headerlink" title="Background of BPF"></a>Background of BPF</h3><p><code>Berkeley Packet Filter(BPF)</code> is the essential underlying technology for packet capture in Unix-like operating systems.<br>Search BPF as the keyword online, and the result is very confusing. It turns out that <code>BPF</code> keeps evolving, and there are several associated concepts such as <code>BPF</code> <code>cBPF</code> <code>eBPF</code> and <code>LSF</code>. So let us examine those concepts along the timeline:</p>
<ul>
<li><p>In <strong>1992</strong>, <code>BPF</code> was first introduced to the BSD Unix system for filtering unwanted network packets. The proposal of BPF was from researchers in Lawrence Berkeley Laboratory, who also developed the <code>libpcap</code> and <code>tcpdump</code>. </p>
</li>
<li><p>In <strong>1997</strong>, Linux Socket Filter(LSF) was developed based on BPF and introduced in Linux kernel version 2.1.75. Note that <code>LSF</code> and <code>BPF</code> have some distinct differences, but in the Linux context, when we speak of BPF or LSF, we mean the same packet filtering mechanism in the Linux kernel. We’ll examine the detailed theory and design of BPF in the following sections. </p>
</li>
<li><p>Originally, BPF was designed as a network packet filter. But in <strong>2013</strong>, BPF was widely extended, and it can be used for non-networking purposes such as performance analysis and troubleshooting. Nowadays, the extended BPF is called <code>eBPF</code>, and the original and obsolete version is renamed to classic BPF (<code>cBPF</code>). <strong>Note that what we examine in this article is cBPF, and eBPF is not inside the scope of this article</strong>. <code>eBPF</code> is the hottest technology in today’s software world, and I’ll talk about it in the future. </p>
</li>
</ul>
<h3 id="Where-to-place-BPF"><a href="#Where-to-place-BPF" class="headerlink" title="Where to place BPF"></a>Where to place BPF</h3><p>The first question to answer is where should we place the filter. The last article examines the path of a received packet  as follows: </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>The best solution to this question is to put the filter as early as possible in the path. Since copying a large amount of data from kernel space to the user space produces a huge overhead, which can influence the system performance a lot. So BPF is a kernel feature. The filter should be triggered immediately when a packet is received at the network interface.As the original BPF <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> said <strong>To minimize memory traffic, the major bottleneck in most modern system, the packet should be filtered ‘in place’ (e.g., where the network interface DMA engine put it) rather than copied to some other kernel buffer before filtering.</strong><br>Let’s verify this behavior by examining the kernel source code as follows (<strong>Note</strong> the kernel code shown in this article is based on version 2.6, which contains the <code>cBPF</code> implementation.): </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source code file of net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* packet_create: create socket */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">	po = pkt_sk(sk);</span><br><span class="line">	sk-&gt;sk_family = PF_PACKET;</span><br><span class="line">	po-&gt;num = proto;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;po-&gt;bind_lock);</span><br><span class="line">	po-&gt;prot_hook.func = packet_rcv; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">		po-&gt;prot_hook.func = packet_rcv_spkt; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proto) &#123;</span><br><span class="line">		po-&gt;prot_hook.type = proto;</span><br><span class="line">		dev_add_pack(&amp;po-&gt;prot_hook);</span><br><span class="line">		sock_hold(sk);</span><br><span class="line">		po-&gt;running = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_create</code> function handles the socket creation when the application calls the <code>socket</code> system call. In lines 11 and 14, it attaches the hook function to the socket. The hook function executes when the packet is received.</p>
<p>The following code block shows the hook function <code>packet_rcv</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hook function packet_rcv is triggered, when the packet is received */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    sk = pt-&gt;af_packet_priv;</span><br><span class="line">    snaplen = skb-&gt;len;</span><br><span class="line">    res = run_filter(skb, sk, snaplen); <span class="comment">// filter logic</span></span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">	    <span class="keyword">goto</span> drop_n_restore; <span class="comment">// drop the packet</span></span><br><span class="line"></span><br><span class="line">    __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb); <span class="comment">// put the packet into the queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_rcv</code> function calls <code>run_filter</code>, which is just the BPF logic part(Currently, you can regard it as a black box. In the next section, we’ll examine the details). Based on the return value of <code>run_filter</code> the packet can be filtered out or put into the queue. </p>
<p>So far, you can understand BPF(or the packet filtering) is working inside kernel space. But the packet sniffer is a user-space application. The next question is how to link the filtering rules in user space to the filtering handler in kernel space. </p>
<p>To answer this question, we have to understand BPF itself. It’s right time to understand this great piece of work. </p>
<h3 id="BPF-machine"><a href="#BPF-machine" class="headerlink" title="BPF machine"></a>BPF machine</h3><p>As I mentioned above, <code>BPF</code> was introduced in this original <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> written by researchers from Berkeley. I strongly recommend you read this great paper based on my own experience. In the beginning, I felt crazy to read it, so I read other related documents and tried to understand BPF. But most documents only cover one portion of the entire system, so it is difficult to piece all the information together. Finally, I read the original paper and connected all parts together. <strong>As the saying goes, sometimes taking time is actually a shortcut.</strong></p>
<h5 id="Virtual-CPU"><a href="#Virtual-CPU" class="headerlink" title="Virtual CPU"></a>Virtual CPU</h5><p>A packet filter is simply a boolean-valued function on a packet. If the value of the function is true the kernel copies the packet for the application; if it is false the packet is ignored. </p>
<p>In order to be as flexible as possible and not to limit the application to a set of predefined conditions, the <code>BPF</code> is actually implemented as a <code>register-based virtual machine</code> (for the difference between stack-based and register-based virtual machine, you can refer to <a target="_blank" rel="noopener" href="http://troubles.md/wasm-is-not-a-stack-machine/">this article</a>) running a user-defined program.  </p>
<p>You can regard the <code>BPF</code> as a <code>virtual CPU</code>. And it consists of an <code>accumulator</code>, an <code>index register(x)</code>, a scratch memory store, and an implicit <code>program counter</code>. If you’re not familiar with these concepts, I add some simple illustrations as follows:</p>
<ul>
<li>An <code>accumulator</code> is a type of register included in a CPU. It acts as a temporary storage location holding an intermediate value in mathematical and logical calculations. For example, in the operation of “1+2+3”, the accumulator would hold the value 1, then the value 3, then the value 6. The benefit of an accumulator is that it does not need to be explicitly referenced.</li>
<li>An <code>index register</code> in a computer’s CPU is a processor register or assigned memory location used for modifying operand addresses during the run of a program. </li>
<li>A <code>program counter</code> is a CPU register in the computer processor which has the address of the next instruction to be executed from memory. </li>
</ul>
<p>In the BPF machine, the accumulator is used for arithmetic operations, while the index register provides offsets into the packet or the scratch memory areas.  </p>
<h5 id="Instructions-set-and-addressing-mode"><a href="#Instructions-set-and-addressing-mode" class="headerlink" title="Instructions set and addressing mode"></a>Instructions set and addressing mode</h5><p>Same as the physical CPU, the <code>BPF</code> provides a small set of arithmetic, logical and jump instructions as follows, these instructions run on the BPF virtual machine(or CPU): </p>
<img src="/images/bpf-instructions.png" title="BPF instructions" width="400px" height="300px">

<p>The first column <em>opcodes</em> lists the BPF instructions written in an assembly language style. For example, <strong>ld</strong>, <strong>ldh</strong> and <strong>ldb</strong> means to copy the indicated value into the <code>accumulator</code>. <strong>ldx</strong> means to copy the indicated value into the <code>index register</code>. <strong>jeq</strong> means jump to the target instruction if the <code>accumulator</code> equals the indicated value. <strong>ret</strong> means return the indicated value. You can check the functionality of the instructions set in detail in the paper. </p>
<p>This kind of assembly-like style is more readable to humans. But when we develop an application (like the sniffer written in this article), we use binary code directly as the BPF instruction. This kind of binary format is called <code>BPF Bytecode</code>. I’ll examine the way to convert this assembly language to bytecode later. </p>
<p>The second column <em>addr modes</em> lists the addressing modes allowed for each instruction. The semantics of the addressing modes are listed in the following table: </p>
<img src="/images/address-mode.png" title="BPF instructions address mode" width="400px" height="300px">

<p>For instance, <strong>[k]</strong> means the data at byte offset k in the packet. <strong>#k</strong> means the literal value stored in k. You can read the paper in detail to check the meaning of other address modes.  </p>
<h5 id="Example-BPF-program"><a href="#Example-BPF-program" class="headerlink" title="Example BPF program"></a>Example BPF program</h5><p>Now let’s try to understand the following small BPF program based on the knowledge above: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2    jf 3</span><br><span class="line">(002) ret      #262144</span><br><span class="line">(003) ret      #0</span><br></pre></td></tr></table></figure>
<p>The BPF program consists of an array of BPF instructions. For example, the above BPF program contains four instructions. </p>
<p>The first instruction <strong>ldh</strong> loads a half-word(16-bit) value into the accumulator from offset 12 in the Ethernet packet. According to the Ethernet frame format shown below, the value is just the <code>Ethernet type</code> field. The Ethernet type is used to indicate which protocol is encapsulated in the frame’s payload (for example,  0x0806 for ARP, <strong>0x0800</strong> for IPv4, and 0x86DD for IPv6).</p>
<img src="/images/ethernet-frame-format.png" title="Ethernet frame fromat" width="600px" height="400px">

<p>The second instruction <strong>jeq</strong> compares the accumulator (currently stores <code>Ethernet type</code> field) to <code>0x800</code>(stands for IPv4). If the comparison fails, zero is returned, and the packet is rejected. If it is successful, a non-zero value is returned, and the packet is accepted. <strong>So the small BPF program filters and accepts all IP packets</strong>. You can find other BPF programs in the original paper. Go to read it, and you can feel the flexibility of BPF as well as the beauty of the design. </p>
<h5 id="Kernel-implementation-of-BPF"><a href="#Kernel-implementation-of-BPF" class="headerlink" title="Kernel implementation of BPF"></a>Kernel implementation of BPF</h5><p>Next, let’s examine how kernel implements BPF. As mentioned above, the hook function <code>packet_rcv</code> calls <code>run_filter</code> to handle the filtering logic. <code>run_filter</code> is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copied from net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* function run_filter is called in packet_rcv*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">int</span> res)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	filter = rcu_dereference(sk-&gt;sk_filter); <span class="comment">// get the filter bound to the socket</span></span><br><span class="line">	<span class="keyword">if</span> (filter != <span class="literal">NULL</span>)</span><br><span class="line">		res = sk_run_filter(skb, filter-&gt;insns, filter-&gt;len); <span class="comment">// the filtering is inside sk_run_filter function</span></span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find that the real filtering logic is inside <code>sk_run_filter</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sk_run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock_filter *filter, <span class="type">int</span> flen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">fentry</span>;</span>	<span class="comment">/* We walk down these */</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	u32 A = <span class="number">0</span>;			<span class="comment">/* Accumulator */</span></span><br><span class="line">	u32 X = <span class="number">0</span>;			<span class="comment">/* Index Register */</span></span><br><span class="line">	u32 mem[BPF_MEMWORDS];		<span class="comment">/* Scratch Memory Store */</span></span><br><span class="line">	u32 tmp;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">int</span> pc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Process array of filter instructions.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (pc = <span class="number">0</span>; pc &lt; flen; pc++) &#123;</span><br><span class="line">		fentry = &amp;filter[pc];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (fentry-&gt;code) &#123;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_X:</span><br><span class="line">			A += X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_K:</span><br><span class="line">			A += fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_X:</span><br><span class="line">			A -= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_K:</span><br><span class="line">			A -= fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_MUL|BPF_X:</span><br><span class="line">			A *= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* some code omitted ... */</span></span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_K:</span><br><span class="line">			<span class="keyword">return</span> fentry-&gt;k;</span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_A:</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		<span class="keyword">case</span> BPF_ST:</span><br><span class="line">			mem[fentry-&gt;k] = A;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_STX:</span><br><span class="line">			mem[fentry-&gt;k] = X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Same as we mentioned, <code>sk_run_filter</code> is simply a boolean-valued function on a packet. It maintains the accumulator, the index register, etc. as local variables. And process the array of BPF filter instructions in a <code>for</code> loop. Each instruction will update the value of local variables. In this way, it simulates a virtual CPU. Interesting, right? </p>
<h5 id="BPF-JIT"><a href="#BPF-JIT" class="headerlink" title="BPF JIT"></a>BPF JIT</h5><p>Since each network packet must go through the filtering function, it becomes the performance bottleneck of the entire system. </p>
<p>A <code>just-in-time (JIT)</code> compiler was introduced into the kernel in <strong>2011</strong> to speed up BPF bytecode execution. </p>
<ul>
<li>What is a <code>JIT</code> compiler? A <code>JIT</code> compiler runs <strong>after</strong> the program has started and compiles the code(usually bytecode or some type of VM instructions) on the fly(or just in time) into a form that’s usually faster, typically the host CPU’s native instruction set. This is in contrast to a <code>traditional compiler</code> that compiles all the code to machine language <strong>before</strong> the program is first run. </li>
</ul>
<p>In the <code>BPF</code> case, the <code>JIT</code> compiler translates BPF bytecode into a host system’s assembly code directly, which can optimize the performance a lot. I’ll not show details about JIT in this article. You can refer to the <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.19.8/source/arch/arm/net/bpf_jit_32.c#L868">kernel code</a>.  </p>
<h3 id="Set-BPF-in-sniffer"><a href="#Set-BPF-in-sniffer" class="headerlink" title="Set BPF in sniffer"></a>Set BPF in sniffer</h3><p>Next, let’s add BPF into our packet sniffer. As we mentioned above in the application level, the BPF instructions should use bytecode format with the following data structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>    <span class="comment">/* Filter block */</span></span><br><span class="line">        __u16   code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">        __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">        __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">        __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How can we convert the BPF assembly language into bytecode? There are two solutions. First, there is a small helper tool called <code>bpf_asm</code>(which is provided along with the Linux kernel), and you can regard it as the BPF assembly language interpreter. But it is not recommended to application developers. </p>
<p>Second, we can use <code>tcpdump</code>, which provides the converting functionality. You can find the following information from the tcpdump man page: </p>
<ul>
<li><p>-d:   Dump the compiled packet-matching code in a human-readable form to standard output and stop.</p>
</li>
<li><p>-dd:  Dump packet-matching code as a C program fragment.</p>
</li>
<li><p>-ddd: Dump packet-matching code as decimal numbers (preceded with a count).</p>
</li>
</ul>
<p><code>tcpdump ip</code> means we want to capture all the IP packets. With options <strong>-d</strong>, <strong>-dd</strong> and <strong>-ddd</strong>, the output goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">baoqger@ubuntu:~$ sudo tcpdump -d ip</span><br><span class="line">[sudo] password <span class="keyword">for</span> baoqger:</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      <span class="comment">#0x800           jt 2    jf 3</span></span><br><span class="line">(002) ret      <span class="comment">#262144</span></span><br><span class="line">(003) ret      <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -<span class="built_in">dd</span> ip</span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -ddd ip</span><br><span class="line">4</span><br><span class="line">40 0 0 12</span><br><span class="line">21 0 1 2048</span><br><span class="line">6 0 0 262144</span><br><span class="line">6 0 0 0</span><br></pre></td></tr></table></figure>
<p>Option <strong>-d</strong> prints the BPF instructions in assembly language (same as the example BPF program shown above). Options <strong>-dd</strong> prints the bytecode as a C program fragment. <strong>So tcpdump is the most convenient tool when you want to get the BPF bytecode</strong>.</p>
<p>The BPF filter bytecode (wrapped in the structure <code>sock_fprog</code>) can be passed to the kernel through <code>setsockopt</code> system call as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attach the filter to the socket</span></span><br><span class="line"><span class="comment">// the filter code is generated by running: tcpdump tcp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">BPF_code</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">Filter</span>;</span></span><br><span class="line"><span class="comment">// error prone code, .len field should be consistent with the real length of the filter code array</span></span><br><span class="line">Filter.len = <span class="keyword">sizeof</span>(BPF_code)/<span class="keyword">sizeof</span>(BPF_code[<span class="number">0</span>]); </span><br><span class="line">Filter.filter = BPF_code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;setsockopt attach filter&quot;</span>);</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>setsockopt</code> system call triggers two kernel functions: <code>sock_setsockopt</code> and <code>sk_attach_filter</code> (I’ll not show the details for these two functions), which <strong>binds the filters to the socket</strong>. And in <code>run_filter</code> kernel function (mentioned above), it can <strong>get the filters from the socket</strong> and <strong>execute the filters on the packet</strong>. </p>
<p>So far, every piece is connected. The puzzle of BPF is solved. The <code>BPF</code> machine allows the user-space applications to inject customized BPF programs straight into a kernel. Once loaded and verified, BPF programs execute in kernel context. These BPF programs operate inside kernel memory space with access to all the internal kernel states available to it. For example, the <code>cBPF</code> machine which uses the network packet data. But this power can be extended as <code>eBPF</code>, which can be used in many other varied applications. As someone <a target="_blank" rel="noopener" href="https://www.brendangregg.com/bpf-performance-tools-book.html">said</a> <strong>In some way, eBPF does to the kernel what Javascript does to the websites: it allows all sorts of new application to be created.</strong>  In the future, I plan to examine eBPF in depth. </p>
<img src="/images/bpf-run-instructions.png" title="BPF Run Instructions" width="600px" height="400px">

<h3 id="Process-the-packet"><a href="#Process-the-packet" class="headerlink" title="Process the packet"></a>Process the packet</h3><p>We examined the <code>BPF</code> filtering theory on the kernel level a lot in the above section. But for our tiny sniffer, the last step we need to do is process the network packet. </p>
<ul>
<li><p>First, the <code>recvfrom</code> system call reads the packet from the socket. And we put the system call in a <code>while</code> loop to keep reading the incoming packets. </p>
</li>
<li><p>Then, we print the source and destination <code>MAC</code> address in the packet(the packet we got is a raw Ethernet frame in Layer 2, right?). And if what this Ethernet frame contains is an <code>IP4</code> packet, then we print out the source and destination <code>IP</code> address. To understand more about it, you can study the header format of various network protocols. I will not cover in details here.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------\n&quot;</span>);</span><br><span class="line">	n = recvfrom(sock, buffer, <span class="number">2048</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d bytes read\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check to see if the packet contains at least</span></span><br><span class="line"><span class="comment">	* complete Ethernet (14), IP (20) and TCP/UDP</span></span><br><span class="line"><span class="comment">	* (8) headers.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">42</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;recvfrom():&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Incomplete packet (errno is %d)\n&quot;</span>, errno);</span><br><span class="line">		close(sock);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ethhead = buffer;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Source MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">0</span>], ethhead[<span class="number">1</span>], ethhead[<span class="number">2</span>], ethhead[<span class="number">3</span>], ethhead[<span class="number">4</span>], ethhead[<span class="number">5</span>]</span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Destination MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">6</span>], ethhead[<span class="number">7</span>], ethhead[<span class="number">8</span>], ethhead[<span class="number">9</span>], ethhead[<span class="number">10</span>], ethhead[<span class="number">11</span>]</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	iphead = buffer + <span class="number">14</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*iphead==<span class="number">0x45</span>) &#123; <span class="comment">/* Double check for IPv4</span></span><br><span class="line"><span class="comment">						* and no options present */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">12</span>],iphead[<span class="number">13</span>],</span><br><span class="line">				iphead[<span class="number">14</span>],iphead[<span class="number">15</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dest host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">16</span>],iphead[<span class="number">17</span>],</span><br><span class="line">				iphead[<span class="number">18</span>],iphead[<span class="number">19</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source,Dest ports %d,%d\n&quot;</span>,</span><br><span class="line">				(iphead[<span class="number">20</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">21</span>],</span><br><span class="line">				(iphead[<span class="number">22</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">23</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Layer-4 protocol %s\n&quot;</span>, transport_protocol(iphead[<span class="number">9</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find the complete source code of the sniffer in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c">repo</a>.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to add filters to our sniffer. First, we analyze why the filter should be running inside kernel space instead of the application space. Then, this article examines the <code>BPF</code> machine design and implementation in detail based on the paper. We reviewed the kernel source code to understand how to implement the <code>BPF</code> virtual machine. As I mentioned above, the original <code>BPF</code>(<code>cBPF</code>) was extended to <code>eBPF</code> now. But the understanding of the BPF virtual machine is very helpful to <code>eBPF</code> as well.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" data-id="cl95b06vw003abomm641w3xu6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" class="article-date">
  <time datetime="2022-02-22T02:21:14.000Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>When we refer to network packet sniffer, some famous and popular tools come to your mind, like <code>tcpdump</code>. I have shown you how to capture network packets with such tools in my previous articles. But have you ever thought about writing a packet sniffer from scratch without dependencies on any third-party libraries? We need to dig deep into the operating system and find the weapons needed to build this tool. Sounds complex, right? In this article, let us do it. After reading this article, you can find that it is not as difficult as you think. </p>
<p>Note that different operating system kernels have different internal network implementations. This article will focus on the <code>Linux</code> platform. </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Firstly, we need to review how <code>tcpdump</code> is implemented. According to the official <a target="_blank" rel="noopener" href="https://www.tcpdump.org/">document</a>, <code>tcpdump</code> is built on the library <code>libpcap</code>, which is developed based on the remarkable research result from Berkeley, in details you can refer to <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">this paper</a>.</p>
<p>As you know, different operating systems have different internal implementations of network stacks. <code>libpcap</code> covers all of these differences and provides the system-independent interface for user-level packet capture. I want to focus on the Linux platform, so how does <code>libpcap</code> work on the Linux system? According to some <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21200009/capturing-performance-with-pcap-vs-raw-socket">documents</a>, it turns out that libpcap uses the <code>PF_PACKET</code> socket to capture packets on a network interface.</p>
<p>So the next question is: what the <code>PF_PACKET</code> socket is? </p>
<h3 id="PF-PACKET-socket"><a href="#PF-PACKET-socket" class="headerlink" title="PF_PACKET socket"></a>PF_PACKET socket</h3><p>In my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2021/07/31/how-to-implement-simple-http-server-golang/">article</a>, we mentioned that the socket interface is TCP/IP’s window on the world. In most modern systems incorporating TCP/IP, the socket interface is the only way applications can use the TCP/IP suite of protocols. </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>It is correct. This time, let’s dig deeper about <code>socket</code> by examining the system call executed when we create a new socket: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>When you want to create a socket with the above system call, you have to specify which domain (or protocol family) you want to use with that socket as the first argument. The most commonly used family is <code>PF_INET</code>, which is for communications based on IPv4 protocols (when you create a TCP server, you use this family). Moreover, you have to specify a type for your socket as the second argument. And the possible values depend on the family you specified. For example, when dealing with the <code>PF_INET</code> family, the values for type include <code>SOCK_STREAM</code>(for TCP) and <code>SOCK_DGRAM</code>(for UDP). For other detailed information about the socket system call, you can refer to the socket(3) man page. </p>
<p>You can find one potential value for the <code>domain</code> argument as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AF_PACKET    Low-level packet interface</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: <code>AF_PACKET</code> and <code>PF_PACKET</code> are same. It is called <code>PF_PACKET</code> in history and then renamed  <code>AF_PACKET</code> later. <code>PF</code> means protocol families, and <code>AF</code> means address families. In this article, I use <code>PF_PACKET</code>. </p>
<p>Different from <code>PF_INET</code> socket, which can give you TCP segment. By <code>PF_PACKET</code> socket, you can get the raw <code>Ethernet</code> frame which bypasses the usual upper layer handling of TCP/IP stack. It might sound a little bit crazy. But, that is, any packet received will be directly passed to the application. </p>
<p>For a better understanding of <code>PF_PACKET</code> socket, let us go deeper and roughly examine the path of a received packet from the network interface to the application level. </p>
<p>(As shown in the image above) When the network interface card(NIC) receives a packet, it is handled by the driver. The driver maintains a structure called <code>ring buffer</code> internally. And write the packet to kernel memory (the memory is pre-allocated with ring buffer)  with direct memory access(DMA). The packet is placed inside a structure called <strong><code>sk_buff</code></strong>(one of the most important structures related to kernel network subsystem).   </p>
<p>After entering the kernel space, the packet goes through protocol stack handling layer by layer, such as <code>IP processing</code> and <code>TCP/UDP processing</code>. And the packet goes into applications via the socket interface. You already understand this familiar path very well.</p>
<p>But for the <code>PF_PACKET</code> socket, the packet in <code>sk_buff</code> is cloned, then it skips the protocol stacks and directly goes to the application. The kernel needs the clone operation, because one copy is consumed by the <code>PF_PACKET</code> socket, and the other one goes through the usual protocol stacks.</p>
<p>In future articles, I’ll demonstrate more about Linux kernel network internals.</p>
<p>Next step, let us see how to create a <code>PF_PACKET</code> socket at the code level. For brevity, I omit some code and only show the essential part. You can refer to this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c">repo</a> in detail.  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sock = <span class="built_in">socket</span>(PF_PACKET, SOCK_RAW, <span class="built_in">htons</span>(ETH_P_IP))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please ensure to include the system header files: <code>&lt;sys/socket.h&gt; &lt;sys/types.h&gt;</code>. </p>
<h3 id="Bind-to-one-network-interface"><a href="#Bind-to-one-network-interface" class="headerlink" title="Bind to one network interface"></a>Bind to one network interface</h3><p>Without the additional settings, the sniffer captures all the packets received on all the network devices. Next step, let us try to bind the sniffer to a specific network device. </p>
<p>Firstly, you can use <code>ifconfig</code> command to list all the available <code>network interfaces</code> on your machines. The network interface is a software interface to the networking hardware. </p>
<p>For example, the following image shows information of network interface <code>eth0</code>: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.230.49  netmask 255.255.240.0  broadcast 192.168.239.255</span><br><span class="line">        inet6 fe80::215:5dff:fefb:e31f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:fb:e3:1f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 260  bytes 87732 (87.7 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 178  bytes 29393 (29.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>Let’s bind the sniffer to <code>eth0</code> as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind to eth0 interface only</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *opt;</span><br><span class="line">opt = <span class="string">&quot;eth0&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, opt, <span class="built_in">strlen</span>(opt) + <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt bind device&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We do it by calling the <code>setsockopt</code> system call. I leave the detailed usage of it to you. </p>
<p>Now the sniffer only captures network packets received on the specified network card. </p>
<h3 id="Non-promiscuous-and-promiscuous-mode"><a href="#Non-promiscuous-and-promiscuous-mode" class="headerlink" title="Non-promiscuous and promiscuous mode"></a>Non-promiscuous and promiscuous mode</h3><p>By default, each network card minds its own business and reads only the frames directed to it. It means that the network card discards all the packets that do not contain its own MAC address, which is called <code>non-promiscuous</code> mode. </p>
<p>Next, let us make the sniffer can work in <code>promiscuous</code> mode. In this way, it retrieves all the data packets. Even the ones that are not addressed to its host. </p>
<p>To set a network interface to promiscuous mode, all we have to do is issue the <code>ioctl()</code> system call to an open socket on that interface.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the network card in promiscuos mode*/</span></span><br><span class="line"><span class="comment">// An ioctl() request has encoded in it whether the argument is an in parameter or out parameter</span></span><br><span class="line"><span class="comment">// SIOCGIFFLAGS	0x8913		/* get flags			*/</span></span><br><span class="line"><span class="comment">// SIOCSIFFLAGS	0x8914		/* set flags			*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ethreq</span>;</span></span><br><span class="line"><span class="built_in">strncpy</span>(ethreq.ifr_name, <span class="string">&quot;eth0&quot;</span>, IF_NAMESIZE);</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCGIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ethreq.ifr_flags |= IFF_PROMISC;</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCSIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ioctl</code> stands for <strong>I/O control</strong>, which manipulates the underlying device parameters of specific files. <code>ioctl</code> takes three arguments: </p>
<ul>
<li>The first argument must be an open file descriptor. We use the socket file descriptor bound to the network interface in our case.</li>
<li>The second argument is a device-dependent request code. You can see we called <code>ioctl</code> twice. The first call uses request code <em>SIOC<strong>G</strong>IFFLAGS</em> to get flags, and the second call uses request code <em>SIOC<strong>S</strong>IFFLAGS</em> to set flags. Do not be fooled by these two constant values, which are spelled alike.</li>
<li>The third argument is for returning information to the requesting process.  </li>
</ul>
<p>Now the sniffer can retrieve all the data packets received on the network card, no matter to which host the packets are addressed.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>This article examined what <code>PF_PACKET</code> socket is, how it works and why the application can get raw Ethernet packets. Furthermore, we discussed how to bind the sniffer to one specific network interface and how can make the sniffer work in the promiscuous mode. The next article will examine how to implement the packet filter functionality, which is very useful to a network sniffer. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" data-id="cl95b06v80016bommehtd2333" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-stack-smashing-detect-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/07/stack-smashing-detect-in-c/" class="article-date">
  <time datetime="2022-02-07T05:12:08.000Z" itemprop="datePublished">2022-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/07/stack-smashing-detect-in-c/">stack-smashing-detect-in-c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/07/stack-smashing-detect-in-c/" data-id="cl95b06vm002bbommepsbegih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
          </li>
        
          <li>
            <a href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
          </li>
        
          <li>
            <a href="/2022/08/05/userland-memory-allocation-one/">Understand userland heap memory allocation: part one - overview</a>
          </li>
        
          <li>
            <a href="/2022/07/22/CPacketSniffer/">cPacketSniffer</a>
          </li>
        
          <li>
            <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/">Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>