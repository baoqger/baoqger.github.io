<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-note-on-red-black-tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/13/note-on-red-black-tree/" class="article-date">
  <time datetime="2023-01-12T23:51:56.000Z" itemprop="datePublished">2023-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/13/note-on-red-black-tree/">Understand Red Black Tree: part one - background</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In this series of articles, I want to examine an important data structure: the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a>. The <code>red-black tree</code> is an advanced data structure that is difficult to fully understand. Maybe you have some wonders and confusion about it as follows:</p>
<ul>
<li>What is the meaning of <code>red</code> and <code>black</code> here?</li>
<li>The <code>red-black tree</code> is known as a self-balancing binary search tree. But what’s the difference between it and others? </li>
<li>Where is it used or applied?  </li>
</ul>
<p>If you want to know the answer to the above questions, then this article is just for you. I will cover the following topics:</p>
<ul>
<li>Why do we need the red-black tree and what is its advantage? </li>
<li>How does a red-black tree work?</li>
<li>How to write a red-black tree from scratch? </li>
</ul>
<h3 id="Background-of-Red-Black-Tree"><a href="#Background-of-Red-Black-Tree" class="headerlink" title="Background of Red-Black Tree"></a>Background of Red-Black Tree</h3><p>In this section, let’s review the history of the red-black tree. During this process, I will show you why it was invented and what kind of advantages it can provide compared with other tree data structures. </p>
<p>First thing first, let’s define the red-black tree as follows: </p>
<ul>
<li>Red-Black Tree is a <code>self-balancing</code> <code>binary</code> <code>search</code> <code>tree</code>. </li>
</ul>
<p>Let’s analyze this definition step by step: </p>
<ul>
<li><p>Tree: A tree is a <code>nonlinear</code> data structure, compared to <code>arrays</code>, <code>linked lists</code>, <code>stacks</code> and <code>queues</code> which are <code>linear</code> data structures. A tree is a data structure consisting of one node called the <code>root</code> and zero or one or more <code>subtrees</code>. One disadvantage of <code>linear</code> data structures is the time required to search a <code>linear</code> list is proportional to the size of the data set, which means that the time complexity is <code>O(n)</code>. That’s why more efficient data structures like trees are invented to <code>store</code> and <code>search</code> data. </p>
</li>
<li><p>General Tree: A general tree is a tree where each node may have zero or more children. </p>
</li>
<li><p>Binary Tree: A binary tree is a specialized case of a general tree, where each node can have no more than <code>two</code> children. </p>
</li>
<li><p>Binary Search Tree: A binary tree satisfying the <code>binary search</code> property is called a <code>binary search tree(BST)</code>. To build a BST, the node with a key greater than any particular node is stored on the <code>right</code> sub-trees and the one equal to or less than is stored on the <code>left</code> sub-tree. </p>
</li>
</ul>
<p>The <code>average</code> search time complexity of BST is <code>O(logN)</code>, but in the <code>worst case</code>, it will be degraded to <code>O(N)</code>. It happens when we insert the nodes one by one in order. For example, if we insert the elements in array <code>[1, 2, 3, 4, 5, 6]</code> into RST in order, what we get is as follows: </p>
<img src="/images/bst-degraded.png" title="arp spoofing detection" width="200px" height="200px">

<p>This kind of <code>unbalanced BST</code> is degraded to a single linked list. So the BST needs to keep balanced during the insert and delete of the node.  That’s where the <code>self-balancing</code> binary search tree comes from. </p>
<ul>
<li>Self-Balancing Binary Search Tree: it’s a binary search tree that automatically keeps its height small in the face of arbitrary item insertions and deletions. And the red-black tree is just one type of it. </li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>As the first post of this series, I examined the background of the red-black tree bit by bit. I hope you can understand what’s self-balancing binary search tree and why we need it. In the next post, I will start to examine the behavior and property of the red-black tree. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2023/01/13/note-on-red-black-tree/" data-id="clgorr6xv002c0gmmc0zv0n7m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bst-deletion-issue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/01/bst-deletion-issue/" class="article-date">
  <time datetime="2023-01-01T04:10:04.000Z" itemprop="datePublished">2023-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/01/bst-deletion-issue/">Deletion operation in Binary Search Tree: successor or predecessor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Today, in this article I want to examine one concrete topic: how to delete a node from a <code>binary search tree</code>. This question is important for understanding other tree data structures, like the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a>, and the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black tree</a>. </p>
<p>As is common with many data structures, <code>deletion</code> is always the hardest operation. For example, to delete a specific element from the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Array">array</a>, we need to shift all the elements after it by one index. And to delete one node from the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>, we need to reset the pointer of the previous node (if it’s a doubled linked list, we need to reset more points, which is a more complex case). This is the same for the binary search tree as well. Let’s see in the following section. </p>
<p>Note: the idea of this article is inspired by the book <strong><em>Data Structures and Algorithm Analysis in C</em></strong> written by <a target="_blank" rel="noopener" href="http://users.cs.fiu.edu/~weiss/">Mark Allen Weiss</a>. The demo code shown in the following section is from this book. And I made some changes based on it. I highly recommend this great book to readers.  </p>
<h3 id="Deletion-of-the-binary-search-tree"><a href="#Deletion-of-the-binary-search-tree" class="headerlink" title="Deletion of the binary search tree"></a>Deletion of the binary search tree</h3><p>Before we can examine the deletion operation in depth, let’s quickly review the concept of the binary search tree as follows:</p>
<ul>
<li>Binary search tree: is a binary tree holding the following property that for every node, X, in the tree, the values of all the keys in its left subtree are smaller than the key value in X, and the values of all the keys in its right subtree are larger than the key value in X. </li>
</ul>
<p>Simply speaking, the binary search tree is a binary tree satisfying the <code>binary search</code> property. So each node of a binary search tree can have two children subtrees at most. When we need to delete one node from the binary search tree, then it’s necessary to consider the following 3 cases. </p>
<p>If the node is a <code>leaf</code>, then it can be deleted immediately. For example, to delete node <code>1</code> from the following binary search tree: </p>
<img src="/images/left-node-deletion.png" title="Delete leaf node from binary search tree" width="400px" height="500px">

<p>I will show you how to implement it at the code level later, which summarizes all the cases. </p>
<p>If the node has only <code>one child subtree</code>, the node can be deleted after we reset its parent’s pointer to bypass the node and point to its child node. For example, to delete node <code>4</code> as follows: </p>
<img src="/images/onechild-node-deletion.png" title="Delete leaf node from binary search tree" width="400px" height="500px">

<p>In the above example, node <code>4</code> has only one left child node <code>3</code>. Let’s consider the symmetric scenario, imagine what will happen when it has only one right child node. The answer is it doesn’t influence how we handle the deleted node here and the result is the same. I will not draw the diagram here and leave it for you to explore. </p>
<p>The complicated case is how to deal with a node with <code>two children</code>. Before we introduce the solution, let’s clarify one concept about the binary search tree: <code>successor</code>: </p>
<ul>
<li>Successor: is the node with the <code>minimum</code> value in the <code>right</code> subtree of any node.</li>
</ul>
<img src="/images/twochildren-delete-origin.png" title="Delete leaf node from binary search tree" width="200px" height="300px">

<p>Let’s take node <code>16</code> in the above binary search tree as an example, the <code>successor</code> is node <code>17</code>. All right! Based on this concept, the solution to delete a node with two children is straightforward:</p>
<ul>
<li>Replace the data of the deleted node with the value of the <code>successor</code> and recursively delete the <code>successor</code> from the <code>right</code> subtree. </li>
</ul>
<p>Let’s try to analyze this solution. Firstly, replacing the data of the node with the value of the <code>successor</code> can keep the <code>binary search</code> property after the deletion operation. Secondly, since the <code>successor</code> has the minimum value of the subtree, which means it cannot have a left child. So the <code>successor</code> is either a leaf node without any child node or a node with only one right child node. So recursively deleting the <code>successor</code> can be resolved by the two simple cases we discussed above, it’s perfect, right?  For instance, the deletion of node <code>16</code> goes as follows: </p>
<img src="/images/twochildren-delete-after.png" title="Delete leaf node from binary search tree" width="500px" height="600px">

<p>As we mentioned above, node <code>16</code>‘s <code>successor</code> is node <code>17</code>. So replace the value with 17 and delete node <code>17</code> from the right subtree, where node <code>17</code> is just a leaf node. Next, let’s implement the node deletion operation. </p>
<h3 id="Code-implementation"><a href="#Code-implementation" class="headerlink" title="Code implementation"></a>Code implementation</h3><p>In this article, I will only show the codes related to the deletion operation rather than the complete implementation of a binary search tree. If you want to know how to write a BST from scratch, please refer to this GitHub <a target="_blank" rel="noopener" href="https://github.com/baoqger/data-structures-and-algorithm-analysis-in-c-practice/tree/main/trees/BinarySearchTree">repo</a>.</p>
<p>Firstly, let’s examine the header file, which contains the data type definitions and function declarations. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utility.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ET;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BST;</span><br><span class="line"></span><br><span class="line">BST <span class="title function_">delete</span><span class="params">(ET, BST)</span>;</span><br><span class="line">Position <span class="title function_">findMinBST</span><span class="params">(BST)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// code omitted here</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>You can notice that besides the <code>delete</code> function, we also define a helper function <code>findMinBST</code> which is used to find the <code>successor</code> node. </p>
<p>Next, let’s examine the function definitions as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BST</span><br><span class="line"><span class="title function_">delete</span><span class="params">(ET elem, BST T)</span></span><br><span class="line">&#123;</span><br><span class="line">    Position tmpCell;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        fatal(<span class="string">&quot;Element not found&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (elem &lt; T-&gt;Element)</span><br><span class="line">        T-&gt;Left = delete(elem, T-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (elem &gt; T-&gt;Element)</span><br><span class="line">        T-&gt;Right = delete(elem, T-&gt;Right);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// we found the element to be deleted</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left != <span class="literal">NULL</span> &amp;&amp; T-&gt;Right != <span class="literal">NULL</span>) <span class="comment">// two children</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpCell = findMinBST(T-&gt;Right);</span><br><span class="line">        T-&gt;Element = tmpCell-&gt;Element;</span><br><span class="line">        T-&gt;Right = delete(T-&gt;Element, T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// one or zero children, change the pointer T pointing to new address(NULl or the child node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpCell = T;</span><br><span class="line">        <span class="comment">// for leaf node, T will be reset to null</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Right == <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        <span class="built_in">free</span>(tmpCell);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Position</span><br><span class="line"><span class="title function_">findMinBST</span><span class="params">(BST T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;Left == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> findMinBST(T-&gt;Left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I add some comments in the above code block which can help your understanding of this recursive algorithm. Please go ahead and think hard about it. </p>
<p>In the next section, we’ll have some open discussions about this solution. Let’s see whether there is any other solution. And what’re the potential issues of the current solution? </p>
<h3 id="Open-discussion"><a href="#Open-discussion" class="headerlink" title="Open discussion"></a>Open discussion</h3><h4 id="successor-vs-predecessor"><a href="#successor-vs-predecessor" class="headerlink" title="successor vs predecessor"></a>successor vs predecessor</h4><p>Firstly, in the above solution, we delete the node with two children based on the <code>successor</code>. And there is the other concept called <code>predecessor</code>: </p>
<ul>
<li>Predecessor: is the node with the <code>maximum</code> value in the left subtree of any node.</li>
</ul>
<p>So similarly, the alternative solution to delete the node with two children is: </p>
<ul>
<li>Replace the data of the deleted node with the value of the <code>predecessor</code> and recursively delete the <code>predecessor</code> from the <code>left</code> subtree.</li>
</ul>
<p>We can do this by writing another helper function <code>findMaxBST</code> as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Position</span><br><span class="line"><span class="title function_">findMaxBST</span><span class="params">(BST T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;Right != <span class="literal">NULL</span>)</span><br><span class="line">      T = T-&gt;Right;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Does it work? The answer is yes. But the performance of the solution based on the <code>predecessor</code> is worse than the one based on the <code>successor</code>. Because the <code>predecessor</code> has the maximum value of the left subtree, it means that the <code>predecessor</code> can have two children. Then when we delete the <code>predecessor</code> recursively, the worst-case time complexity can reach <code>O(logN)</code> while the solution based on the <code>successor</code> only requires constant(<code>O(1)</code>) time. That’s the difference. </p>
<h4 id="balanced-vs-unbalanced"><a href="#balanced-vs-unbalanced" class="headerlink" title="balanced vs unbalanced"></a>balanced vs unbalanced</h4><p>Although the above solution can work, it exposes a serious performance issue. The reason why people invent binary search tree data structures is that we can get <code>O(logN)</code> level performance for searching operations. But imagine what will happen if we keep inserting and deleting nodes in the binary search tree in the way we mentioned here. The depth of the tree will become <code>unbalanced</code>. The left subtree grows deeper than the right subtree because we are always replacing a deleted node with the <code>successor</code>(which is from the right subtree, right?) </p>
<p>The following image is borrowed from Mark’s great book I mentioned above, which clearly shows that the tree becomes <code>unbalanced</code> after many rounds of insertion and deletion. If you want to know about it in theory, please refer to the book.  </p>
<img src="/images/bst-unbalanced.png" title="Unbalanced binary search tree" width="800px" height="1000px">

<p>For an unbalanced BST, the worst-case time complexity can be degraded to <code>O(n)</code>. To keep the desired performance, people invent a more advanced data structure <code>self-balancing binary search tree</code>, like the <code>AVL tree</code> and <code>Red-black tree</code>. I will share about them in the coming articles, please keep watching my blog. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examined various solutions to delete a node from the binary search tree and evaluated their performance. We also discussed some open questions about BST, which prove why we need more advanced data structures like the red-black tree. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2023/01/01/bst-deletion-issue/" data-id="clgorr6x900070gmmeatlg6rr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Search-Tree-delete-balanced-performance/" rel="tag">Binary Search Tree, delete, balanced, performance</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-external-sorting-two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/06/external-sorting-two/" class="article-date">
  <time datetime="2022-12-06T03:11:06.000Z" itemprop="datePublished">2022-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/06/external-sorting-two/">External Mergesort: part two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In this last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/11/02/external-sorting-one/">article</a>, we examined how <code>external mergesort</code> works in theory, let’s implement it now. </p>
<p>First, you can find all the source codes of this implementation in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/external-merge-sort">repo</a>. In this repo, I implemented both <code>two-way</code> and <code>multi-way</code> solutions, which are tracked in different branches, please be aware of this. But for the sake of simplicity, I will focus on the generalized <code>multi-way</code> mergesort solution in this article. </p>
<h3 id="Data-Preparation"><a href="#Data-Preparation" class="headerlink" title="Data Preparation"></a>Data Preparation</h3><p>Before diving into the code, let’s define the problem we need to solve here. I will generate an input file containing several millions of seven digits random numbers, from 1,000,000 to 9,999,999. The random numbers can be duplicated, and each number is stored in one new line of the input file. The input file can be prepared with the following Bash script which calls GNU <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shuf">shuf</a> : </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Chris Bao</span></span><br><span class="line"><span class="comment"># Generate millions of seven digits random integers</span></span><br><span class="line"><span class="comment"># based on shuf utility</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shuf</span> -i 1000000-9999999 -n 7777777 &gt; ./input.txt</span><br></pre></td></tr></table></figure>

<p>The generated input file is roughly <code>60 MB</code> in size. For modern computers, it can be loaded to memory easily. But since we are working external memory algorithm, so let’s assume we are running the algorithm on an old computer, which has only <code>100000 Byte</code> memory. Based on this assumed restriction, we need to sort the numbers in the input file and save the result in a new file. </p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Let’s define some global constants in this algorithm:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONSTANT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTANT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMORY_LIMIT 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECORD_SIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MULTI_WAY_NUMBER 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>

<p><code>MEMORY_LIMIT</code> denotes the <code>100000 bytes</code> memory limit; In C, we can use the type <code>unsigned int</code> to store an integer in the range from 1,000,000 to 9,999,999. So <code>RECORD_SIZE</code> means each record(or integer) will take up 4 bytes of memory.</p>
<p>And by default, the algorithm will use the <code>two-way</code> merge, but the user can pass an argument to run a <code>multi-way</code> merge too. </p>
<h5 id="Sort-phase"><a href="#Sort-phase" class="headerlink" title="Sort phase"></a>Sort phase</h5><p>The sort phase is implemented inside the <code>separationSort</code> function as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Goes through a given file and separates that file into sorted 1MB files using (internal) mergeSort algorithm</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">separationSort</span><span class="params">(FILE *input)</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)*(MEMORY_LIMIT/RECORD_SIZE));</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sort phase start.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((nread = getline(&amp;line, &amp;len, input)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; MEMORY_LIMIT/RECORD_SIZE) &#123;</span><br><span class="line">            buffer[count++] = (<span class="type">unsigned</span> <span class="type">int</span>)strtoul(line, <span class="literal">NULL</span>, <span class="number">10</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeSort(buffer, count); <span class="comment">// sort records</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// output sorted to file</span></span><br><span class="line">            <span class="keyword">if</span> (fileNum == <span class="number">1</span>) &#123; <span class="comment">// create the dir</span></span><br><span class="line">                <span class="type">int</span> status;</span><br><span class="line">                <span class="comment">// create tmp directory</span></span><br><span class="line">                <span class="keyword">if</span> ((status = mkdir(<span class="string">&quot;./tmp&quot;</span>, S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create tmp directory.\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// create pass0 directory for sort phase</span></span><br><span class="line">                <span class="keyword">if</span> ((status = mkdir(<span class="string">&quot;./tmp/pass0&quot;</span>, S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create pass0 directory.\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> fileName[<span class="number">20</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(fileName, <span class="string">&quot;./tmp/pass0/%d.txt&quot;</span>, fileNum);</span><br><span class="line">            <span class="keyword">if</span> ((fp = fopen(fileName, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create file: %s.\n&quot;</span>, fileName);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            outputToFile(buffer, count, fp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset memory buffer(zero-out the entire array)</span></span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)*(MEMORY_LIMIT/RECORD_SIZE));</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            fileNum++;</span><br><span class="line">            buffer[count++] = (<span class="type">unsigned</span> <span class="type">int</span>)strtoul(line, <span class="literal">NULL</span>, <span class="number">10</span>); <span class="comment">// add the current record into new buffer&#x27;s as first element</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the last and final file</span></span><br><span class="line">    mergeSort(buffer, count);</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(fileName, <span class="string">&quot;./tmp/pass0/%d.txt&quot;</span>, fileNum);</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(fileName, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create file: %s.\n&quot;</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    outputToFile(buffer, count, fp);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sort phase done. %d tmp sorted files are produced.\n&quot;</span>, fileNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic is not difficult. The function takes the input file descriptor as a parameter and reads each line(via the <code>getline</code> method) in a loop until reaches the end of the file. The numbers will be read into the memory buffer before hitting the memory limit. When the memory buffer is full(100000 bytes), the numbers are sorted with the function <code>mergeSort</code>. </p>
<p>The function <code>mergeSort</code> is defined inside the file <a target="_blank" rel="noopener" href="https://github.com/baoqger/external-merge-sort/blob/multi-way-with-pass/internal_sort.c"><code>internal_sort.c</code></a>, which implements the classic internal <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Merge_sort"><code>merge sorting</code></a> algorithm. I will not cover it in this article, since you can find many documents about it online. If you don’t know about it, please spend some time learning about it. Of course, you can replace it with other sorting algorithms like <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quicksort"><code>quick sort</code></a> too. I leave this for the readers. </p>
<p>After sorting, the numbers are saved in the temporary files in the directory of <code>./tmp/pass0</code>. The filename is just the run number. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Output sorted record to given file(of)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputToFile</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *buffer, <span class="type">int</span> size, FILE *of)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(of, <span class="string">&quot;%u\n&quot;</span>, buffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(of);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can verify the result of the sort phase as follows: </p>
<img src="/images/pass0.png" title="Random access machine model" width="600px" height="400px">

<p>You can see each file contains up to <code>25000</code> (equal to <code>MEMORY_LIMIT/RECORD_SIZE</code>) numbers and 312 files are created in pass0. </p>
<p>Note that I will not examine the details about how to make a new directory and how to open a new file to read or write. You can learn such Linux file I/O concepts by yourself. </p>
<h5 id="Merge-phase"><a href="#Merge-phase" class="headerlink" title="Merge phase"></a>Merge phase</h5><p>The <code>exMerge</code> function controls the passes in the merge phase starting from <code>pass1</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exMerge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    <span class="type">int</span> pass = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fileNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        exMergeSort(pass, fileNum);</span><br><span class="line">        <span class="type">int</span> remainer = fileNum % ways;</span><br><span class="line">        fileNum = fileNum / ways;</span><br><span class="line">        <span class="keyword">if</span> (remainer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fileNum++;</span><br><span class="line">        &#125; </span><br><span class="line">        pass++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The variable <code>fileNum</code> stores the <code>run</code> number in each pass. And the variable <code>ways</code> denotes the number of multi-way. Thus, the <code>run</code> number of the next pass should be calculated as <code>fileNum / ways</code>.</p>
<p>The detailed merging logic is inside the function <code>exMergeSort</code>, which takes two parameters. <code>pass</code> means the current pass number(starting from 1), while <code>nums</code> means how many runs(or sub-files) in the last pass need to be merged. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exMergeSort</span><span class="params">(<span class="type">int</span> pass, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    <span class="type">int</span> inputFileNum = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; inputFileNum &lt; nums;) &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create the dir for current pass</span></span><br><span class="line">        <span class="keyword">if</span> (inputFileNum == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="type">char</span> dirName[<span class="number">20</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(dirName, <span class="string">&quot;./tmp/pass%d&quot;</span>, pass);</span><br><span class="line">            <span class="keyword">if</span> ((status = mkdir(dirName, S_IRWXU | S_IRWXU | S_IROTH | S_IXOTH)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create tmp directory %s.\n&quot;</span>, dirName);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open new file to merge in each run</span></span><br><span class="line">        FILE *fm; </span><br><span class="line">        <span class="type">char</span> mergedFileName[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(mergedFileName, <span class="string">&quot;./tmp/pass%d/%d.txt&quot;</span>, pass, run);</span><br><span class="line">        <span class="keyword">if</span> ((fm = fopen(mergedFileName, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;merged file %s: can&#x27;t create or open.\n&quot;</span>, mergedFileName);</span><br><span class="line">        &#125;</span><br><span class="line">        run++;</span><br><span class="line">        <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above code creates a temp directory for each pass and a temp file for each run. </p>
<p>Next, we create an array of the input files for each run. And the input file is inside the temp directory of the last pass. Each run merges multiple files in the <code>for</code> loop. The only trick logic here is that the remaining files in the last run may be less than the number of ways declared, we need to handle that properly (line 5 of the below code block).  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rewind the sorted files in previous pass, each run merge way_numbers numbers of files</span></span><br><span class="line"><span class="comment">// Merge the sorted files with multi ways in N runs. </span></span><br><span class="line"><span class="comment">// In the first N - 1 runs, each run merge ways numbers of files</span></span><br><span class="line"><span class="comment">// In the last run, merge the remaining files. </span></span><br><span class="line"><span class="type">int</span> way_numbers = run * ways &lt;= nums ? ways : nums - inputFileNum;</span><br><span class="line">FILE *fiarr[way_numbers];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; way_numbers; i++) &#123;</span><br><span class="line">   <span class="type">char</span> inputFileName[<span class="number">20</span>];</span><br><span class="line">   inputFileNum++; <span class="comment">// start from 0 to nums</span></span><br><span class="line">   <span class="built_in">sprintf</span>(inputFileName, <span class="string">&quot;./tmp/pass%d/%d.txt&quot;</span>, pass - <span class="number">1</span>, inputFileNum);</span><br><span class="line">   <span class="keyword">if</span> ((fiarr[i] = fopen(inputFileName, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input file %s: can&#x27;t create or open.\n&quot;</span>, inputFileName);</span><br><span class="line">   &#125;</span><br><span class="line">   rewind(fiarr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we need to read one number from every input file until only one file is not run out. Find the smallest one and save it in the temp output run file. And for the last remaining file, remember to put the rest numbers into the output file too.  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get and compare records until files runs out of records</span></span><br><span class="line"><span class="type">char</span> *records[way_numbers]; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; way_numbers; i++) &#123;</span><br><span class="line">    records[i] = getRecord(fiarr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loop until only one file is not run-out</span></span><br><span class="line"><span class="keyword">while</span>(validateRecords(records, way_numbers )) &#123;</span><br><span class="line">    <span class="type">int</span> index = getMinRecordIndex(records, way_numbers);</span><br><span class="line">    <span class="built_in">fprintf</span>(fm, <span class="string">&quot;%s&quot;</span>, records[index]); <span class="comment">// print record to new merged file</span></span><br><span class="line">    <span class="built_in">free</span>(records[index]); <span class="comment">// free the memory allocated by getline in getRecord function</span></span><br><span class="line">    records[index] = getRecord(fiarr[index]); <span class="comment">// Get new record from the file</span></span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// put the rest record in the last remaining file into new file </span></span><br><span class="line"><span class="type">int</span> lastIndex = getLastRemainRecordIndex(records, way_numbers);</span><br><span class="line"><span class="keyword">while</span>(records[lastIndex]) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(fm, <span class="string">&quot;%s&quot;</span>, records[lastIndex]);</span><br><span class="line">    <span class="built_in">free</span>(records[lastIndex]);</span><br><span class="line">    records[lastIndex] = getRecord(fiarr[lastIndex]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code bock utilizes several methods like <code>getRecord</code>, <code>validateRecords</code>, <code>getMinRecordIndex</code> and <code>getLastRemainRecordIndex</code> as follows, and these functions are easy to understand. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Returns a copy of the record</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getRecord</span><span class="params">(FILE *ifp)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">while</span> ((nread = getline(&amp;line, &amp;len, ifp)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> line;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validate whether at least two records are non-zero</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">validateRecords</span><span class="params">(<span class="type">char</span> **records, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (records[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the min valid record&#x27;s index</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMinRecordIndex</span><span class="params">(<span class="type">char</span> **records, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> min = (<span class="type">int</span>)INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (records[i] == <span class="literal">NULL</span>) &#123; <span class="comment">// pass invalid run-out record files</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (strtoul(records[i], <span class="literal">NULL</span>, <span class="number">10</span>) &lt; min) &#123;</span><br><span class="line">            min = strtoul(records[i], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the last remainer of the records</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLastRemainRecordIndex</span><span class="params">(<span class="type">char</span> **records, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (records[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In detail, you can refer to the source code of this <a target="_blank" rel="noopener" href="https://github.com/baoqger/external-merge-sort/blob/multi-way-with-pass/main.c">github repo</a>. Next, let’s evaluate the performance of this algorithm by tuning the number of ways for merging. </p>
<h3 id="Performance-Evaluation"><a href="#Performance-Evaluation" class="headerlink" title="Performance Evaluation"></a>Performance Evaluation</h3><p>We’ll use the Linux <code>time</code> utility to measure the running time of this algorithm. </p>
<p>The result of two-way mergesort is: </p>
<img src="/images/two-way-merge.png" title="two way merge sort" width="600px" height="400px">

<p>while six-way mergesort can complete with a shorter runtime. </p>
<img src="/images/multi-way-merge.png" title="two way merge sort" width="600px" height="400px">
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/12/06/external-sorting-two/" data-id="clgorr6xa000d0gmm2lnj3dsz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-external-sorting-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/02/external-sorting-one/" class="article-date">
  <time datetime="2022-11-02T08:44:29.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/02/external-sorting-one/">External Mergesort: part one</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This article will examine one interesting question which I came across when reading the book <strong><em>Programming Pearls</em></strong>. This question simply goes like this: <code>How to sort a large disk file? The disk file has so much data that it cannot all fit into the main memory.</code> I considered this <code>algorithm</code> question for a while; but noticed that all the classic sorting algorithms, like <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quicksort"><code>Quick sort</code></a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Merge_sort"><code>merge sort</code></a>, can’t solve it easily. Then I did some research about it, and I will share what I learned in this article. I believe you can solve this problem as well, after reading this article.</p>
<h3 id="Background-of-External-Algorithm"><a href="#Background-of-External-Algorithm" class="headerlink" title="Background of External Algorithm"></a>Background of External Algorithm</h3><p>Traditionally, computer scientists analyze the running time of an algorithm by counting the number of executed instructions, which is usually expressed as a function of the input size n, like the well-known <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Big_O_notation"><code>Big O notation</code></a>. This kind of algorithm complexity analysis is based on the <code>Random access machine(RAM)</code> model, which defines the following assumptions:</p>
<ul>
<li>A machine with an unbounded amount of available memory;</li>
<li>Any desired memory location can be accessed in unit time;</li>
<li>Every instruction takes the same amount of time. </li>
</ul>
<img src="/images/RAM-Model.png" title="Random access machine model" width="300px" height="200px">

<p>This model works well when the amount of memory that the algorithm needs to use is smaller than the amount of memory in the computer running the code. </p>
<p>But in the real world, some applications need to process data that are too large to fit into a computer’s main memory at once. And the algorithms used to solve such problems are called <code>external memory algorithms</code> or <code>disk-based algorithms</code>; since the input data are stored on an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/External_storage"><code>external memory</code> storage device</a>.</p>
<p>Instead of the <code>RAM</code> model, the <code>external memory algorithm</code> is analyzed based on the <code>external memory model</code>. The model consists of a CPU processor with an internal memory of bounded size, connected to an unbounded external memory. One I/O operation consists of moving a block of contiguous elements from external to internal memory(this is called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_cache"><code>page cache</code></a> and is managed by the kernel.). </p>
<img src="/images/external-model.png" title="external memory model" width="400px" height="300px">

<p>Compared with the main memory, the access speed of external memory is slower by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_hierarchy">several orders of magnitude</a>, even though modern storage techniques such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Solid-state_drive"><code>SSD</code></a> are already adopted. Thus, for external algorithms, the bottleneck of the performance is <code>disk IO</code> speed instead of the CPU cycles. </p>
<p>In this section, we examined the computational model of the external memory algorithms. Next, let’s review one typical type of external memory algorithm: external sorting. </p>
<h3 id="External-Mergesort"><a href="#External-Mergesort" class="headerlink" title="External Mergesort"></a>External Mergesort</h3><p>Similar to the traditional internal sorting algorithms, several different solutions are available for external sorting. In this article, I will focus on <code>external mergesort</code>.</p>
<p>External mergesort is a straightforward generalization of internal mergesort. The algorithm starts by repeatedly loading M input items into the memory(since the memory buffer size is limited, can only store M input items at once), sorting them, and writing them back out to disk. This step divides the input file into some(or many, if the input file is very large) sorted runs, each with M items sorted. Then the algorithm repeatedly merges multiple sorted runs, until only a single sorted run containing all the input data remains. </p>
<p>Let’s use the following example model to analyze this algorithm. First of all, assume the memory buffer is limited, and the size is one <code>page</code>. And the input file size is 8 <code>pages</code>. External mergesort can be divided into two phases: <code>sort phase</code> and <code>merge phase</code>.  </p>
<img src="/images/external-mergesort.png" title="external mergesort" width="800px" height="600px">

<p><strong><em>Sort phase</em></strong>:</p>
<ul>
<li>Divide the entire input file into 8 groups, each group size is one page(memory buffer capacity).</li>
<li>Load each page into the memory, sort the items in the memory buffer(with an internal sorting algorithm), and save the sorted items in a temporary sub-file. Each sub-file is called a <code>run</code>.</li>
</ul>
<p>At the end of the sort phase, 8 temporary sorted 1-page runs will be created. This step can be marked as <strong><em>pass 0</em></strong>.</p>
<p><strong><em>Merge phase</em></strong>: </p>
<p>The 8 sorted runs in pass 0 will be merged into a single sorted file with 3 more passes.</p>
<ul>
<li>pass 1: Perform 4 runs for the merge. <ul>
<li>Run 1: Merge the first two small 1-page runs into a big 2-page run. This merging step goes as follows: <ul>
<li>Read the first two sorted sub-files (one item from each file).</li>
<li>Find the smaller item, output it in the new sub-file, and the appropriate input sub-file is advanced. Repeat this cycle until the input sub-file is completed. <strong>This routine’s logic is the same as the internal mergesort algorithm.</strong></li>
</ul>
</li>
<li>Run 2: Merge the next two 1-page runs into a 2-page run. </li>
<li>Run 3 and 4: follow the same process.   </li>
<li>At the end of <strong><em>pass 1</em></strong>, 4 temporary sorted 2-page runs will be created. </li>
</ul>
</li>
<li>pass 2: Perform 2 runs for the merge. <ul>
<li>At the end of <strong><em>pass 2</em></strong>, 2 temporary sorted 4-page runs will be created. </li>
</ul>
</li>
<li>pass 3: Perform 1 run for the merge. <ul>
<li>At the end of <strong><em>pass 3</em></strong>, the final 8-page run containing all the sorted items will be created.</li>
</ul>
</li>
</ul>
<p>Note: the above process may seem complicated at the first sight, but the logic is nearly the same as the internal merge sort. The only difference is internal merging is based on memory buffers, while external merging is based on disk files, and needs reading the item from disk to memory.</p>
<p>Since we keep merging two small sub-files into a big one with doubled size, the above algorithm can be called <code>two-way</code> external merge sorting. We can generalize the idea to <code>multi-way</code> external merge sorting, which merges M runs into one.  </p>
<p>Next, let’s analyze its complexity. Suppose the input file has <code>N</code> items and each page consists of <code>B</code> items. And <code>M</code> denotes the number of ways used in the merge phase, thus the number of passes should be: <b>log<sub>M</sub>(N/B) + 1</b>, where plus one means the first pass in the sort phase. And each pass, each item is read and written once from and to the disk file. So the total number of disk I/O is: <b>2N*(log<sub>M</sub>(N/B) + 1)</b></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examined the abstract computational model of the external memory algorithm and analyzed the details of the external mergesort algorithm. Next article, let’s implement the code and evaluate the performance. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/11/02/external-sorting-one/" data-id="clgorr6xa000b0gmmhpjl1ckc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-userland-memory-allocation-three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/10/userland-memory-allocation-three/" class="article-date">
  <time datetime="2022-10-10T08:27:46.000Z" itemprop="datePublished">2022-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/09/08/userland-memory-allocation-two/">article</a>,  we investigated how the allocated chunks are aligned and stored in the heap. This article continues to examine how to free a chunk of memory and how the freed chunks are stored in the heap. </p>
<h3 id="Hands-on-demo"><a href="#Hands-on-demo" class="headerlink" title="Hands-on demo"></a>Hands-on demo</h3><p>Let’s continue debugging the demo code shown in the last article: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">&quot;AAAABBBBCCCCDDDD&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Previously, we allocated a chunk of memory and put data in it. The next line will free this chunk. Before we run the instruction and show the demo result, let’s discuss the theory first. </p>
<p>The freed chunk will not be returned to the kernel immediately after the <code>free</code> is called. Instead, the heap <code>allocator</code> keeps track of the freed chunks in a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linked_list"><code>linked list</code></a> data structure. So the freed chunks in the linked list can be reused when the application requests new allocations again. This can decrease the performance overhead by avoiding too many system calls. </p>
<p>The <code>allocator</code> could store all the freed chunks together in a long linked list, this would work but the performance would be slow. Instead, the <code>glibc</code> maintains a series of freed linked lists called <code>bins</code>, which can speed up the allocations and frees. We will examine how <code>bins</code> work later.  </p>
<p>It is worth noting that each free chunk needs to store <code>pointers</code> to other chunks to form the linked list. That’s what we discussed in the last section, there’re two points in the <code>malloc_chunk</code> structure: <code>fd</code> and <code>bk</code>, right? Since the <code>user data</code> region of the freed chunk is free for use by the <code>allocator</code>, so it repurposes the <code>user data</code> region as the place to store the pointer. </p>
<p>Based on the above description, the following picture illustrates the exact structure of a freed chunk:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if freed                  | </span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             pointer to the next freed chunk                   |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             pointer to the previous freed chunk               |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                           ......                              .</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Now step over one line in <code>gdb</code> and check chunks in the heap as follows: </p>
<img src="/images/heap-demo-heap-free.png" title="pwndbg 1" width="300px" height="200px">

<p>You can see the changes: the allocated chunk is marked as a <code>Free chunk (tcache)</code> and pointer <code>fd</code> is set(which indicates this freed chunk is inserted into a linked list). </p>
<p>The <code>tcache</code> is one kind of <code>bins</code> provided by <code>glibc</code>. The gdb <code>pwndbg</code> plugin allows you to check the content of <code>bins</code> by running command <code>bins</code> as follows:</p>
<img src="/images/heap-demo-bins.png" title="pwndbg 2" width="300px" height="200px">

<p>Note that the freed chunk(at 0x5555555592a0) is inserted into <code>tcache bins</code> as the liked list header.  </p>
<p>Note that there 5 types of bins: <code>small bins</code>, <code>large bins</code>, <code>unsorted bins</code>, <code>fast bins</code> and <code>tcache bins</code>. If you don’t know, don’t worry I will examine them in the following section. </p>
<p>According to the definition, after the second <code>malloc(100)</code> is called, the <code>allocator</code> should reuse the freed chunk in the <code>bins</code>. The following image can prove this:  </p>
<img src="/images/heap-demo-reuse-100.png" title="pwndbg 3" width="300px" height="200px">

<p>The freed chunk at 0x555555559290 is in use again and all <code>bins</code> are empty after the chunk is removed from the linked list. All right! </p>
<h3 id="Recycling-memory-with-bins"><a href="#Recycling-memory-with-bins" class="headerlink" title="Recycling memory with bins"></a>Recycling memory with bins</h3><p>Next, I want to spend a little bit of time examining why we need <code>bins</code> and how <code>bins</code> optimize chunk allocation and free. </p>
<p>If the <code>allocator</code> keeps track of all the freed chunks in a long linked list. The time complexity is <code>O(N)</code> for the allocator to find a freed chunk with fit size by traversing from the head to the tail. If the <code>allocator</code> wants to keep the chunks in order, then at least  <code>O(NlogN)</code> time is needed to sort the list by size. This slow process would have a bad impact on the overall performance of programs. That’s the reason why we need bins to optimize this process. In summary, the optimization is done on the following two aspects:</p>
<ul>
<li>High-performance data structure</li>
<li>Per-thread cache without lock contention</li>
</ul>
<h4 id="High-performance-data-structure"><a href="#High-performance-data-structure" class="headerlink" title="High-performance data structure"></a>High-performance data structure</h4><p>Take the <code>small bins</code> and <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686"><code>large bins</code></a> as a reference, they are defined as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>They are defined together in an array of linked lists and each linked list(or bin) stores chunks that are all <code>the same fixed size</code>. From <code>bins[2] to bins[63]</code> are the <code>small bins</code>, which track freed chunks less than 1024 bytes while the <code>large bins</code> are for bigger chunks.  <code>small bins</code> and <code>large bins</code> can be represented as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Doubly_linked_list"><code>double-linked list</code></a> shown below: </p>
<img src="/images/small-bins-index.png" title="pwndbg 4" width="600px" height="400px">

<p>The <code>glibc</code> provides a <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1686">function</a> to calculate the <code>index</code> of the corresponding small(or large) bin in the array based on the requested <code>size</code>. Since the <code>index</code> operation of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Array_(data_structure)">array</a> is in <code>O(1)</code> time. Moreover, each bin contains chunks of the same size, so it can also take <code>O(1)</code> time to insert or remove one chunk into or from the list. As a result, the entire allocation time is optimized to  <code>O(1)</code>. </p>
<p><code>bins</code> are <code>LIFO(Last In First Out)</code> data structure. The insert and remove operations can be illustrated as follows: </p>
<img src="/images/LIFO-linked-list.png" title="pwndbg 4" width="600px" height="400px">

<p>Moreover, for <code>small bins</code> and <code>large bins</code>, if the neighbors of the current chunk are free, they are <code>merged</code> into a larger one. That’s the reason we need a <code>double-linked list</code> to allow running fast traverse both forward and backward. </p>
<p>Unlike <code>small bins</code> and <code>large bins</code>, <code>fast bins</code> and <code>tcache bins</code> chunks are <code>never merged</code> with their neighbors. In practice, the glibc <code>allocator</code> doesn’t set the <code>P</code> special flag at the start of the next chunk. This can avoid the overhead of merging chunks so that the freed chunk can be immediately reused if the same size chunk is requested. Moreover, since <code>fast bins</code> and <code>tcache bins</code> are never merged, they are implemented as a <a target="_blank" rel="noopener" href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1678"><code>single-linked list</code></a>.</p>
<p>This can be proved by running the second <code>free</code> method in the demo code and checking the chunks in the heap as follows: </p>
<img src="/images/heap-demo-heap-free.png" title="pwndbg 1" width="300px" height="200px">

<p>First, the <code>top</code> chunk’s size is still <code>0x20d01</code> rather than <code>0x20d00</code>, which indicates the <code>P</code> bit is equal to 1. Second, the <code>Free chunk</code> only has one pointer: <code>fd</code>. If it’s in a double-linked list, both <code>fd</code> and <code>bk</code> should point to a valid address. </p>
<h4 id="Per-thread-cache-without-lock-contention"><a href="#Per-thread-cache-without-lock-contention" class="headerlink" title="Per-thread cache without lock contention"></a>Per-thread cache without lock contention</h4><p>The letter <code>t</code> in <code>tcache bins</code> represents the <code>thread</code>, which is used to optimize the performance of multi-thread programs. In multi-thread programming, the most common way solution to prevent the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition"><code>race condition</code></a> issue is using the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lock_(computer_science)"><code>lock or mutex</code></a>. Similarly, The <code>glibc</code> maintains a <code>lock</code> in the data structure for each heap. But this design comes with a performance cost: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lock_(computer_science)#:~:text=lock%20contention%3A%20this%20occurs%20whenever,lock%20held%20by%20the%20other."><code>lock contention</code></a>, which happens when one thread attempts to acquire a lock held by another thread. This means the thread can’t do any tasks. </p>
<p><code>tcache bins</code> are per-thread bins. This means if the thread has a chunk on its <code>tcache bins</code>, it can serve the allocation without waiting for the heap lock!  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examined how the userland heap allocaor works by debugging into the heap memory with gdb. The discussion is fully based on the <code>glibc</code> implementation. The design and behavior of the <code>glibc</code> heap allocator are complex but interesting, what we covered here just touches the tip of the iceberg. You can explore more by yourself. </p>
<p>Moreover, I plan to write a simple version of a heap allocator for learning and teaching purpose. Please keep watching my blog!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/10/10/userland-memory-allocation-three/" data-id="clgorr6y0002v0gmm9enoex75" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-userland-memory-allocation-two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/08/userland-memory-allocation-two/" class="article-date">
  <time datetime="2022-09-08T07:43:57.000Z" itemprop="datePublished">2022-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/08/05/userland-memory-allocation-one/">article</a> gave a general overview of memory management. The story goes on. In this section, let’s break into the heap memory to see how it works basically. </p>
<h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><p>We need to first understand some terminology in the memory management field: </p>
<ul>
<li><strong>mutator</strong>: the program that modifies the objects in the heap, which is simply the user application. But I will use the term <code>mutator</code> in this article. </li>
<li><strong>allocator</strong>: the <code>mutator</code> doesn’t allocate memory by itself, it delegates this generic job to the <code>allocator</code>. At the code level, the <code>allocator</code> is generally implemented as a library. The detailed allocation behavior is fully determined by the implementations, in this article I will focus on the memory allocator in the library of <code>glibc</code>.  </li>
</ul>
<p>The relationship between the <code>mutator</code> and <code>allocator</code> is shown in the following diagram: </p>
<img src="/images/memo-allocator.png" title="memory allocator" width="400px" height="300px">

<p>There is a third component in the memory management field: the <code>garbage collector(GC)</code>. <code>GC</code> reclaims memories automatically. Since this article is talking about manual heap memory allocation in system programming, we will ignore <code>GC</code> for now. <code>GC</code> is a very interesting technical challenge, I will examine it in the future. Please keep watching my blog!</p>
<h3 id="Hands-on-demo"><a href="#Hands-on-demo" class="headerlink" title="Hands-on demo"></a>Hands-on demo</h3><p>We will use <code>gdb</code> and <code>pwndbg</code>(which is a gdb <a target="_blank" rel="noopener" href="https://github.com/pwndbg/pwndbg">plugin</a>) and break into the heap memory to see how it works. The <code>gdb</code> provides the functionality to extend it via <code>Python</code> plugins. <code>pwndbg</code> is the most widely used. </p>
<p>The demo code is as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">&quot;AAAABBBBCCCCDDDD&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="type">char</span> *b = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The demo code above just allocates some memory, set the content of the memory and releases it later. And then allocate other chunks of memory again. Very simple, all right? </p>
<p>First, set a <code>breakpoint</code> at line 7(the first <code>malloc</code> call) and run the program in <code>gdb</code>. Then run <code>vmmap</code> command from <code>pwndbg</code>, which can get the process memory layout as follows: </p>
<img src="/images/heap-demo-vmmap-no-heap.png" title="pwndbg 1" width="800px" height="600px">

<p>Note that there is no <code>heap</code> segment yet before the first <code>malloc</code> call is made. After step over one line in <code>gdb</code>, check the layout again: </p>
<img src="/images/heap-demo-vmmap-has-heap.png" title="pwndbg 2" width="800px" height="600px">

<p>Now the <code>heap</code> segment is created with the size of <code>132KB</code>(21000 in hexadecimal). As described above, the kernel maps 132KB of physical memory to this process’s virtual memory and marks this 132KB block of physical memory as used to isolate other processes. This mapping routine is done via system calls like <code>brk</code>, <code>sbrk</code> and <code>mmap</code>. Please investigate these system calls yourself.</p>
<p>132KB is much bigger than the 100B(the size passed to <code>malloc</code>). This behavior can answer one question at the beginning of this article. The system calls aren’t necessary to be triggered each time when <code>malloc</code> is called. This design is aimed to decrease performance overhead. Now the 132KB heap memory is maintained by the <code>allocator</code>. Next time the application calls <code>malloc</code> again, the <code>allocator</code> will allocate memory for it. </p>
<p>Next, step one more line in <code>gdb</code> to assign value(“AAAABBBBCCCCDDDD”) to the allocated block. Let’s check the content of this 132KB heap segment with <code>heap</code> command as follows:</p>
<img src="/images/heap-demo-heap.png" title="pwndbg 3" width="300px" height="200px">

<p>There are 3 chunks. Let’s examine these chunks one by one. </p>
<p>The <code>top</code> chunk contains all the remaining memories which have not been allocated yet. In our case, the kernel maps 132KB of physical memory to this process. And 100B memory is allocated by calling <code>malloc(100)</code>, so the remaining memories are in the <code>top</code> chunk. The <code>top</code> chunk stays on the border of the heap segment, and it can grow and shrink as the process allocates more memory or release unused memory. </p>
<p>Then let’s look at the chunk with the size of 0x291. The <code>allocator</code> uses this chunk to store heap management structures. It is not important for our analysis, just skip it. </p>
<p>What we care about is the chunk in the middle with a size of <code>0x71</code>. It should be the block we requested and contains the string “AAAABBBBCCCCDDDD”. We can verify this point by checking its content:</p>
<img src="/images/heap-demo-display.png" title="pwndbg 3" width="600px" height="400px">

<p>gdb’s <a target="_blank" rel="noopener" href="https://visualgdb.com/gdbreference/commands/x"><code>x</code></a> command can display the memory contents at a given address using the specified format. <code>x/40wx 0x555555559290</code> prints 40 words(each word is 32 bits) of memories starting from 0x555555559290 in the hexadecimal format.</p>
<p>We can see that the string “AAAABBBBCCCCDDDD” is there. So our guess is correct. But the question is why the size of this chunk is <code>0x71</code>. To understand this, we need to first analyze how the <code>allocator</code> stores <code>chunk</code>. A chunk of memory is represented by the following structure: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (only if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>prev_size</code>: the size of the previous chunk only when the previous chunk is free, otherwise when the previous chunk is in use it stores the user data of the previous chunk. </li>
<li><code>size</code>: the size of the current chunk.</li>
<li><code>fd</code>: pointer to the next free chunk only when the current chunk is free, otherwise when the current chunk is in use it stores the user data.</li>
<li><code>bk</code>: pointer to the previous free chunk. Behaves in the same way as pointer <code>fd</code>.  </li>
</ul>
<p>Based on the above description, the following picture illustrates the exact structure of an allocated <code>chunk</code>: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if freed                  | </span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk: indicates the real starting address of the object in the heap memory. </li>
<li>mem: indicates the returned address by <code>malloc</code>. </li>
</ul>
<p>The memory in between is reserved for the metadata mentioned above: <code>prev_size</code> and <code>size</code>. On a 64-bit system, they’re (type of <code>INTERNAL_SIZE_T</code>) 8 bytes in length. </p>
<p>For the <code>size</code> field, it is worth noting: </p>
<ul>
<li>It includes both the size of metadata and the size of the actual user data.</li>
<li>It is usually aligned to a multiple of 16 bytes. You can investigate the <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/381244/purpose-of-memory-alignment">purpose of memory alignment</a> by yourself.</li>
<li>It contains three special flags(<code>A|M|P</code>) at the three least significant bits. We can ignore the other two bits for now, but the last bit indicates whether the previous chunk is in use(set to 1) or not(set to 0). </li>
</ul>
<p>According to this, let’s review the content of this chunk again:</p>
<img src="/images/heap-demo-display-mark.png" title="pwndbg 3" width="600px" height="400px">

<p>I add marks on the image to help you understand. Let’s do some simple calculations. <code>100 + 8 = 108</code>, 100 is the size of memory we requested, 8 is the size of metadata(for <code>size</code> field). Then <code>108</code> is aligned to <code>112</code> as a multiple of 16 bytes. Finally, since the special flag P is set to 1, then we get <code>112 + 1 = 113(0x71)</code>(that’s the reason why the size is <code>0x71</code> instead of <code>0x70</code>).  </p>
<p>In this section, we break into the heap segment and see how an allocated chunk works. Next, we’ll check how to free a chunk. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/09/08/userland-memory-allocation-two/" data-id="clgorr6y0002w0gmme3w9gcjx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-userland-memory-allocation-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/05/userland-memory-allocation-one/" class="article-date">
  <time datetime="2022-08-05T12:31:11.000Z" itemprop="datePublished">2022-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/05/userland-memory-allocation-one/">Understand userland heap memory allocation: part one - overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In my eyes, compared with developing applications with high-level programming languages, one of the biggest differences for system programming with low-level languages like C and C++, is you have to manage the memory by yourself. So you call APIs like <code>malloc</code>, and <code>free</code> to allocate the memory based on your need and release the memory when the resource is no longer needed. It is not only one of the most frequent causes of <a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2021/11/01/debug-memory-errors-valgrind-and-gdb">bugs</a> in system programming; but also can lead to many <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_safety">security issues</a>. </p>
<p>It’s not difficult to understand the correct usage of APIs like <code>malloc</code>, and <code>free</code>. But have you ever wondered how they work, for example: </p>
<ul>
<li>When you call <code>malloc</code>, does it trigger system calls and delegate the task to the kernel or there are some other mechanisms? </li>
<li>When you call <code>malloc(10)</code> and try to allocate 10 bytes of heap memory, how many bytes of memory do you get? 10 bytes or more?</li>
<li>When the memory is allocated, where exactly the heap objects are located?</li>
<li>When you call <code>free</code>, is the memory directly returned to the kernel? </li>
</ul>
<p>This article will try to answer these questions. </p>
<p>Note that memory is a super complex topic, so I can’t cover everything about it in one article (In fact, what is covered in this article is very limited). This article will focus on <code>userland memory(heap) allocation</code>. </p>
<h3 id="Process-memory-management-overview"><a href="#Process-memory-management-overview" class="headerlink" title="Process memory management overview"></a>Process memory management overview</h3><h4 id="Process-virtual-memory"><a href="#Process-virtual-memory" class="headerlink" title="Process virtual memory"></a>Process virtual memory</h4><p>Every time we start a program, a memory area for that program is reserved, and that’s <code>process virtual memory</code> as shown in the following image: </p>
<img src="/images/process-memory-address.png" title="process virtual memory" width="400px" height="300px">

<p>You can note that each process has one <strong>invisible</strong> memory segment containing kernel codes and data structures. This invisible memory segment is important; since it’s directly related to <code>virtual memory</code>, which is employed by the kernel for memory management. Before we dive into the other different segments, let’s understand virtual memory first. </p>
<h4 id="Virtual-memory-technique"><a href="#Virtual-memory-technique" class="headerlink" title="Virtual memory technique"></a>Virtual memory technique</h4><img src="/images/virtual-memory-technique.png" title="virtual memory technique" width="600px" height="400px">

<p>Why do we need virtual memory? Virtual memory is a service provided by the kernel in the form of abstraction. Without virtual memory, applications would need to manage their physical memory space, coordinating with every other process running on the computer. Virtual memory leaves that management to the kernel by creating the maps that allow translation between virtual and physical memory.  The kernel creates an illusion that each process occupies the entire physical memory space. We can also realize <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_isolation">process isolation</a> based on virtual memory to enhance security. </p>
<p>Virtual memory is out of this article’s scope, if you’re interested, please take a look at the core techniques: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_paging">paging</a> and <a target="_blank" rel="noopener" href="https://linuxhint.com/linux-memory-management-swap-space/">swapping</a>. </p>
<h4 id="Static-vs-Dynamic-memory-allocation"><a href="#Static-vs-Dynamic-memory-allocation" class="headerlink" title="Static vs Dynamic memory allocation"></a>Static vs Dynamic memory allocation</h4><p>Next, let’s take a close look at the process memory layout above and understand where they are from. Generally speaking, there are two ways via which memories can be allocated for storing data: <code>static</code> and <code>dynamic</code>. Static memory allocation happens at <code>compile time</code>, while dynamic memory allocation occurs at <code>runtime</code>. </p>
<p>When a program started, the executable file(on the Linux system, it’s called an <code>ELF</code> file) will be loaded into the memory as a <code>Process Image</code>. This <code>ELF</code> file contains the following segments:</p>
<ul>
<li>.TEXT: contains the executable part of the program with all the machine codes.</li>
<li>.DATA: contains <code>initialized</code> static and global variables. </li>
<li>.BSS: is short for <code>block started by symbol</code> contains <code>uninitialized</code> static and global variables. </li>
</ul>
<p>The <code>ELF</code> file will be loaded by the kernel and create a process image. And these static data will be mapped into the corresponding segments of the virtual memory. The <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/article/1060">ELF loader</a> is also an interesting topic, I will write another article about it in the future. Please keep watching my blog!</p>
<p>The <code>memory-mapped region</code> segment is used for storing the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2019/08/25/how-to-write-linux-c-program-with-external-library/">shared libraries</a>. </p>
<p>Finally, <code>stack</code> and <code>heap</code> segments are produced at runtime dynamically, which are used to store and operate on temporary variables that are used during the execution of the program. Previously, I once wrote an article about the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2020/08/19/stack-frame/">stack</a>, please refer to it if you want to know the details.</p>
<p>The only remaining segment we didn’t mention yet is the <code>heap</code>, which is this article’s focus! </p>
<p>You can check the memory layout of one process by examining this file <code>/proc/&#123;pid&#125;/maps</code> as below: </p>
<img src="/images/maps-capture.png" title="proc/pid/maps" width="800px" height="600px">

<p>Note that the above investigation doesn’t consider multiple threads. The memory layout of the process with multi-threads will be more complex, please refer to other online <a target="_blank" rel="noopener" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">documents</a>.</p>
<p>In this section, we had a rough overview of memory management from top to bottom. Hope you can see the big picture and know where we are. Next, let’s dig into the <code>heap</code> segment and see how it works. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/08/05/userland-memory-allocation-one/" data-id="clgorr6y0002t0gmm1ibcc3om" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CPacketSniffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/22/CPacketSniffer/" class="article-date">
  <time datetime="2022-07-22T02:19:48.000Z" itemprop="datePublished">2022-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/22/CPacketSniffer/">cPacketSniffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this post, I want to introduce my new project: <a target="_blank" rel="noopener" href="https://github.com/baoqger/cPacketSniffer"><code>cPacketSniffer</code></a>. I worked on it for the past two months. Finally, I worked it out and feel very proud of putting it here!</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Simply speaking, I want to sharpen my techniques in <code>network programming</code> and <code>Linux system programming</code>. Both of these two topics can lead you to the bottom of computers or software. Feynman said <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/There%27s_Plenty_of_Room_at_the_Bottom">“There is plenty of room at the bottom”</a>, I think this physics law can apply to software as well. </p>
<h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><p>It’s very lucky for me to come across this site <a target="_blank" rel="noopener" href="http://tcpip.marcolavoie.ca/index.html">“Network programming in Linux”</a>, which developed a network packet capturing tool with <code>C++</code>. After confirming that the documents and source code on this site is completed and clear, I decided to refactor it with C language. That’s the starting point for my project <code>cPacketSniffer</code>.      </p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>As a network packets sniffer, <code>cPacketSniffer</code> provides the following features: </p>
<img src="/images/cPacketSniffer.png" title="cPacketSniffer modules" width="600px" height="400px">

<ul>
<li>Integrate with <code>libpcap</code> to support: filtering captured packets, capturing packets offline, capturing packets on specific devices and capturing packets in promiscuous mode.</li>
<li>Analyze network packets at low layers of TCP/IP stack, including <code>Ethernet</code>, <code>ARP</code>, <code>ICMP</code>, <code>IP(IPv4)</code>, <code>TCP</code>, <code>UDP</code>, etc. Also one protocol in the application layer: <code>TFTP</code>. </li>
<li>Detect network security attacks:<ul>
<li>ARP spoofing detection.</li>
<li>Ping flood detection.</li>
</ul>
</li>
<li>Analyze and track network traffics:<ul>
<li>TCP session tracking and traffic analysis.</li>
<li>TFTP session tracking and traffic analysis.</li>
</ul>
</li>
</ul>
<p>The following images demonstrate some typical usages of <code>cPacketSniffer</code>:  </p>
<p><strong>Packet Analysis</strong>:</p>
<img src="/images/packet-analysis.png" title="packet analysis" width="600px" height="400px">

<p><strong>ARP Spoofing Detection</strong>:</p>
<img src="/images/arpspoof.png" title="arp spoofing detection" width="600px" height="400px">

<p><strong>PING Flood Detection</strong>:</p>
<img src="/images/pingflooddetection.png" title="ping flood detection" width="600px" height="400px">

<p><strong>TCP Session Tracking</strong>:</p>
<img src="/images/tcpsessiontrack.png" title="tcp session track" width="600px" height="400px">

<p>Besides the above network programming-related functionalities, it also covers the following points: </p>
<ul>
<li>Develop a generic data structure in C.</li>
<li>Error handling in C. </li>
<li>Data encapsulation (object-oriented style programming) in C.</li>
<li>Manual memory management in C.</li>
<li>etc.</li>
</ul>
<p>This article will not cover these points in detail, I will write articles on these topics separately in the future. Please keep watching my blog!</p>
<h3 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h3><p>Now <code>cPacketSniffer</code> can work as a network packet sniffer based on the design. Moreover, it can also serve as a testbed to try experimental features. Next step I plan to try the following ideas:</p>
<ul>
<li>Implement the network intrusion detection function. </li>
<li>Improve the performance with advanced data structures, like binary search trees. </li>
<li>Memory and cache performance tuning. </li>
<li>Automatic memory management by Garbage Collection.</li>
<li>Integrate <code>ncurses</code> for Text-based user interface.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/07/22/CPacketSniffer/" data-id="clgorr6x300010gmm871y8os2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/" class="article-date">
  <time datetime="2022-06-08T06:59:19.000Z" itemprop="datePublished">2022-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/">Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/">article</a>, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a <code>Netfilter</code> module as our mini-firewall.  </p>
<h3 id="Netfilter-architecture"><a href="#Netfilter-architecture" class="headerlink" title="Netfilter architecture."></a>Netfilter architecture.</h3><h5 id="Basics-of-Netfilter-hooks"><a href="#Basics-of-Netfilter-hooks" class="headerlink" title="Basics of Netfilter hooks"></a>Basics of Netfilter hooks</h5><p><strong>The <code>Netfilter</code> framework provides a bunch of <code>hooks</code> in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well</strong>. And Netfilter allows you to write modules and register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? </p>
<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

<p>Currently, Netfilter provides the following 5 hooks for <code>IPv4</code>:</p>
<ul>
<li><em>NF_INET_PRE_ROUTING</em>: is triggered right after the packet has been received on a network card. This hook is triggered before the <code>routing decision</code> was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. </li>
<li><em>NF_INET_LOCAL_IN</em>: is triggered for network packets that are destined for the current host. </li>
<li><em>NF_INET_FORWARD</em>: is triggered for network packets that should be forwarded. </li>
<li><em>NF_INET_POST_ROUTING</em>: is triggered for network packets that have been routed and before being sent out to the network card. </li>
<li><em>NF_INET_LOCAL_OUT</em>: is triggered for network packets generated by the processes on the current host.</li>
</ul>
<p>The hook function you defined in the module can mangle or filter the packets, but it eventually must return a status code to Netfilter. There are several possible values for the code, but for now, you only need to understand two of them: </p>
<ul>
<li><em>NF_ACCEPT</em>: this means the hook function accepts the packet and it can go on the network stack trip. </li>
<li><em>NF_DROP</em>: this means the packet is dropped and no further parts of the network stack will be traversed.</li>
</ul>
<p>Netfilter allows you to register multiple callback functions to the same hook with different priorities. If the first hook function accepts the packet, then the packet will be passed to the next functions with low priority. If the packet is dropped by one callback function, then the next functions(if existing) will not be traversed. </p>
<p>As you see, <code>Netfilter</code> has a big scope and I can’t cover every detail in the articles. So the mini-firewall developed here will work on the hook <code>NF_INET_PRE_ROUTING</code>, which means it works by controlling the inbound network traffic. But the way of registering the hook and handling the packet can be applied to all other hooks. </p>
<p><em>Note</em>: there is another remarkable question: what’s the difference between <code>Netfilter</code> and <code>eBPF</code>? If you don’t know eBPF, please refer to my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">article</a>. Both of them are important network features in the Linux kernel. The important thing is <code>Netfilter</code> and <code>eBPF</code> hooks are located in different layers of the Kernel. As I drew in the above diagram, <code>eBPF</code> is located in a lower layer. </p>
<h5 id="Kernel-code-of-Netfilter-hooks"><a href="#Kernel-code-of-Netfilter-hooks" class="headerlink" title="Kernel code of Netfilter hooks"></a>Kernel code of Netfilter hooks</h5><p>To have a clear understanding of how the <code>Netfilter</code> framework is implemented inside the protocol stack, let’s dig a little bit deeper and take a look at the kernel source code (Don’t worry, only shows several simple functions). Let’s use the hook <code>NF_INET_PRE_ROUTING</code> as an example; since the mini-firewall will be written based on it. </p>
<p>When an IPv4 packet is received, its handler function <code>ip_rcv</code> will be called as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/net/ipv4/ip_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">        skb = ip_rcv_core(skb, net);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">        <span class="comment">// run Netfilter NF_INET_PRE_ROUTING hook&#x27;s callback function</span></span><br><span class="line">        <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, </span><br><span class="line">                       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">                       ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this handler function, you can see the hook is passed to the function <code>NF_HOOK</code>. Based on the name <code>NF_HOOK</code>, you can guess that it is for triggering the Netfilter hooks. Right? Let’s continue to examine how <code>NF_HOOK</code> is implemented as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">                ret = okfn(net, sk, skb); <span class="comment">// in our case: okfn is ip_rcv_finish</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      nf_hook - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *      okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *      value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code omit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>NF_HOOK</code> contains two steps:</p>
<ul>
<li>First, runs the hook’s callback functions by calling the underlying function <code>nf_hook</code>. </li>
<li>Second, invokes the function <code>okfn</code> (passed to <em>NF_HOOK</em> as the argument), if the packet passes through the hook functions and doesn’t drop.</li>
</ul>
<p>For the hook <em>NF_INET_LOCAL_IN</em>, the function <code>ip_rcv_finish</code> will be invoked after the hook functions pass. Its job is to pass the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey! </p>
<p>The other 4 hooks all use the same function <code>NF_HOOK</code> to trigger the callback functions. The following table shows where the hooks are embedded in the kernel, I leave them to the readers. </p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>File</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>NF_INET_PRE_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_rcv()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_IN</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_local_deliver()</td>
</tr>
<tr>
<td>NF_INET_FORWARD</td>
<td>/kernel-src/net/ipv4/ip_forward.c</td>
<td>ip_forward()</td>
</tr>
<tr>
<td>NF_INET_POST_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_build_and_send_pkt()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_OUT</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_output()</td>
</tr>
</tbody></table>
<p>Next, Let’s review the Netfilter’s APIs to create and register the hook function. </p>
<h3 id="Netfilter-API"><a href="#Netfilter-API" class="headerlink" title="Netfilter API"></a>Netfilter API</h3><p>It’s straightforward to create a Netfilter module, which involves three steps: </p>
<ul>
<li>Define the hook function.</li>
<li>Register the hook function in the kernel module initialization process.</li>
<li>Unregister the hook function in the kernel module clean-up process. </li>
</ul>
<p>Let’s go through them quickly one by one. </p>
<h5 id="Define-a-hook-function"><a href="#Define-a-hook-function" class="headerlink" title="Define a hook function"></a>Define a hook function</h5><p>The hook function name can be whatever you want, but it must follow the signature below: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br></pre></td></tr></table></figure>

<p>The hook function can mangle or filter the packet whose data is stored in the <code>sk_buff</code> structure (we can ignore the other two parameters; since we don’t use them in our mini-firewall). As we mentioned above, the callback function must return a Netfilter status code which is an integer. For instance, the <code>accepted</code> and <code>dropped</code> status is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Responses from hook functions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_ACCEPT 1</span></span><br></pre></td></tr></table></figure>
<h5 id="Register-and-unregister-a-hook-function"><a href="#Register-and-unregister-a-hook-function" class="headerlink" title="Register and unregister a hook function"></a>Register and unregister a hook function</h5><p>To register a hook function, we should wrap the defined hook function with related information, such as which hook you want to bind to, the protocol family and the priority of the hook function,  into a structure <code>struct nf_hook_ops</code> and pass it to the function <code>nf_register_net_hook</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn               *hook;    <span class="comment">// callback function</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">dev</span>;</span>     <span class="comment">// network device interface</span></span><br><span class="line">        <span class="type">void</span>                    *priv; </span><br><span class="line">        <span class="type">u_int8_t</span>                pf;       <span class="comment">// protocol</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            hooknum;  <span class="comment">// Netfilter hook enum</span></span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="type">int</span>                     priority; <span class="comment">// priority of callback function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Most of the fields are very straightforward to understand. The one need to emphasize is the field <code>hooknum</code>, which is just the Netfilter hooks discussed above. They are defined as enumerators as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">	NF_INET_PRE_ROUTING,</span><br><span class="line">	NF_INET_LOCAL_IN,</span><br><span class="line">	NF_INET_FORWARD,</span><br><span class="line">	NF_INET_LOCAL_OUT,</span><br><span class="line">	NF_INET_POST_ROUTING,</span><br><span class="line">	NF_INET_NUMHOOKS,</span><br><span class="line">	NF_INET_INGRESS = NF_INET_NUMHOOKS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Next, let’s take a look at the functions to register and unregister hook functions goes as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Function to register/unregister hook points. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter <code>struct net</code> is related to the network namespace, we can ignore it for now and use a default value. </p>
<p>Next, let’s implement our mini-firewall based on these APIs. All right? </p>
<h3 id="Implement-mini-firewall"><a href="#Implement-mini-firewall" class="headerlink" title="Implement mini-firewall"></a>Implement mini-firewall</h3><p>First, we need to clarify the requirements for our mini-firewall. We’ll implement two network traffic control rules in the mini-firewall as follows:</p>
<ul>
<li><em>Network protocol rule</em>: drops the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a> protocol packets.</li>
<li><em>IP address rule</em>: drops the packets from one specific IP address.</li>
</ul>
<p>The completed code implementation is in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">repo</a>.</p>
<h5 id="Drop-ICMP-protocol-packets"><a href="#Drop-ICMP-protocol-packets" class="headerlink" title="Drop ICMP protocol packets"></a>Drop ICMP protocol packets</h5><p><code>ICMP</code> is a network protocol widely used in the real world. The popular diagnostic tools like <code>ping</code> and <code>traceroute</code> run the ICMP protocol. We can filter out the ICMP packets based on the protocol type in the IP headers with the following hook function: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockicmppkt_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span>   <span class="comment">// IP header</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span> <span class="comment">// UDP header</span></span><br><span class="line">	<span class="keyword">if</span>(!skb)</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	iph = ip_hdr(skb); <span class="comment">// retrieve the IP headers from the packet</span></span><br><span class="line">	<span class="keyword">if</span>(iph-&gt;protocol == IPPROTO_UDP) &#123; </span><br><span class="line">		udph = udp_hdr(skb);</span><br><span class="line">		<span class="keyword">if</span>(ntohs(udph-&gt;dest) == <span class="number">53</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept UDP packet</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;Drop ICMP packet \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> NF_DROP;   <span class="comment">// drop TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic in the above hook function is easy to understand. First, we retrieve the IP headers from the network packet. And then according to the <code>protocol</code> type field in the headers, we decided to accept TCP and UDP packets but drop the ICMP packets. The only technique we need to pay attention to is the function <code>ip_hdr</code>, which is the kernel function defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/ip.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">ip_hdr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In source code file /kernel-src/include/linux/skbuff.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>ip_hdr</code> delegates the task to the function <code>skb_network_header</code>. It gets IP headers based on the following two data: </p>
<ul>
<li>head: is the pointer to the packet;</li>
<li>network_header: is the offset between the pointer to the packet and the pointer to the network layer protocol header. In detail, you can refer to this <a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html">document</a>.</li>
</ul>
<p>Next, we can register the above hook function as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">nf_blockicmppkt_ops</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	nf_blockicmppkt_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hook = (nf_hookfn*)nf_blockicmppkt_handler;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;priority = NF_IP_PRI_FIRST; <span class="comment">// set the priority</span></span><br><span class="line">		</span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">nf_minifirewall_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_unregister_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">		kfree(nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(nf_minifirewall_init);</span><br><span class="line">module_exit(nf_minifirewall_exit);</span><br></pre></td></tr></table></figure>

<p>The above logic is self-explaining. I will not spend too much time here. </p>
<p>Next, it’s time to demo how our mini-firewall works. </p>
<h5 id="Demo-time"><a href="#Demo-time" class="headerlink" title="Demo time"></a>Demo time</h5><p>Before we load the mini-firewall module, the <code>ping</code> command can work as expected: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">3</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">4</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time 3005ms</span><br><span class="line">rtt <span class="built_in">min</span>/avg/<span class="built_in">max</span>/mdev = <span class="number">71.857</span>/<span class="number">71.902</span>/<span class="number">71.961</span>/<span class="number">0.193</span> ms</span><br></pre></td></tr></table></figure>

<p>In contrast, after the mini-firewall module is built and loaded (based on the commands we discussed previously): </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">mini_firewall          <span class="number">16384</span>  <span class="number">0</span></span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.105</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">6</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 5097ms</span><br></pre></td></tr></table></figure>

<p>You can see all the packets are lost; because it is dropped by our mini-firewall. We can verify this by running the command <code>dmesg</code>: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">1260.184712</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1261.208637</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1262.232669</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1263.256757</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1264.280733</span>] Drop ICMP packet</span><br></pre></td></tr></table></figure>

<p>But other protocol packets can still run through the firewall. For instance, the command <code>wget 142.250.4.103</code> can return normally as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">302</span> Moved Temporarily</span><br><span class="line">Location: http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f [following]</span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">3248</span> (<span class="number">3.2</span>K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                                           <span class="number">100</span>%[===================================================================================================================&gt;]   <span class="number">3.17</span>K  --.-KB/s    <span class="keyword">in</span> 0s</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span> (<span class="number">332</span> MB/s) - ‘index.html’ saved [<span class="number">3248</span>/<span class="number">3248</span>]</span><br></pre></td></tr></table></figure>

<p>Next, let’s try to ban the traffic from this IP address. </p>
<h5 id="Drop-packets-source-from-one-specific-IP-address"><a href="#Drop-packets-source-from-one-specific-IP-address" class="headerlink" title="Drop packets source from one specific IP address"></a>Drop packets source from one specific IP address</h5><p>As we mentioned above, multiple callback functions are allowed to be registered on the same Netfilter hook. So we will define the second hook function with a different priority. The logic of this hook function goes like this: we can get the source IP address from the IP headers and make the drop or accept decision according to it. The code goes as follows</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS(addr) \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[3], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[2], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[1], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[0]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ip_addr_rule = <span class="string">&quot;142.250.4.103&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockipaddr_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">char</span> *str = (<span class="type">char</span> *)kmalloc(<span class="number">16</span>, GFP_KERNEL);</span><br><span class="line">		u32 sip;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">sb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">		sb = skb;</span><br><span class="line">		iph = ip_hdr(sb);</span><br><span class="line">		sip = ntohl(iph-&gt;saddr); <span class="comment">// get source ip address; </span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sprintf</span>(str, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, IPADDRESS(sip)); <span class="comment">// convert to standard IP address format</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str, ip_addr_rule)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This hook function uses two interesting techniques:</p>
<ul>
<li><p><code>ntohl</code>: is a kernel function, which is used to convert the value from <code>network byte order</code> to <code>host byte order</code>. <code>Byte order</code> is related to the computer science concept of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness"><code>Endianness</code></a>. Endianness defines the order or sequence of bytes of a word of digital data in computer memory. A <code>big-endian</code> system stores the most significant byte of a word at the smallest memory address.  A <code>little-endian</code> system, in contrast, stores the least-significant byte at the smallest address. Network protocol uses the <code>big-endian</code> system. But different OS and platforms run various Endianness system. So it may need such conversion based on the host machine.</p>
</li>
<li><p><code>IPADDRESS</code>: is a macro, which generates the standard IP address format(four 8-bit fields separated by periods) from a 32-bit integer. It uses the technique of <a target="_blank" rel="noopener" href="https://www.eskimo.com/~scs/cclass/notes/sx10e.html"><code>the equivalence of arrays and pointers in C</code></a>. I will write another article to examine what it is and how it works. Please keep watching my updates!</p>
</li>
</ul>
<p>Next, we can register this hook function in the same way discussed above. The only remarkable point is this callback function should have a different priority as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">	nf_blockipaddr_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockipaddr_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hook = (nf_hookfn*)nf_blockipaddr_handler;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hooknum = NF_INET_PRE_ROUTING;  <span class="comment">// register to the same hook</span></span><br><span class="line">		nf_blockipaddr_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockipaddr_ops-&gt;priority = NF_IP_PRI_FIRST + <span class="number">1</span>; <span class="comment">// set a higher priority</span></span><br><span class="line"></span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockipaddr_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s see how it works with a demo. </p>
<h5 id="Demo-time-1"><a href="#Demo-time-1" class="headerlink" title="Demo time"></a>Demo time</h5><p>After re-build and re-load the module, we can get: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">20</span>:07--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. failed: Connection timed out.</span><br><span class="line">Retrying.</span><br></pre></td></tr></table></figure>

<p>The <code>wget 142.250.4.103</code> can’t return response. Because it is dropped by our mini-firewall. Great!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">3162.064284</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.089466</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.288603</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.345463</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.480123</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br></pre></td></tr></table></figure>

<h3 id="More-space-to-expand"><a href="#More-space-to-expand" class="headerlink" title="More space to expand"></a>More space to expand</h3><p>You can find the full code implementation <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">here</a>. But I have to say, our mini-firewall only touches the surface of what Netfilter can provide. You can keep expanding the functionalities. For example, currently, the rules are hardcoded, why not make it possible to config the rules dynamically. There are many cool ideas worth trying. I leave it for the readers.  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we implement the mini-firewall step by step and examined many detailed techniques. Not only code; but we also verify the behavior of the mini-firewall by running real demos.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/06/08/how-to-write-a-netfilter-firewall-part3/" data-id="clgorr6yb003l0gmme75515fv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/" class="article-date">
  <time datetime="2022-05-05T10:06:50.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two - hello world module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/04/how-to-write-a-netfilter-firewall-part1/">article</a>, we examined the basics of <code>Netfilter</code> and <code>Linux kernel modules</code> in theory. Starting from this article, we will make our hands dirty and start implementing our mini-firewall. We will walk through the whole process step by step. In this article, let’s write our first Linux kernel module using a simple <code>hello world</code> demo. Then let’s learn how to build the module(which is very different from compiling an application in the user space) and how to load it in the kernel. After understanding how to write a module, in the next article, let’s write the initial version of our mini-firewall module using <a target="_blank" rel="noopener" href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter’s hook architecture</a>. All right. Let’s start the journey. </p>
<h3 id="Make-the-first-Kernel-module"><a href="#Make-the-first-Kernel-module" class="headerlink" title="Make the first Kernel module"></a>Make the first Kernel module</h3><p>First, I have to admit that Linux Kernel module development is a kind of large and complex technology topic. And there are many great <a target="_blank" rel="noopener" href="https://sysprog21.github.io/lkmpg/">online resources</a> about it. This series of articles is focusing on developing the mini-firewall based on Netfilter, so we can’t cover all the aspects of the Kernel module itself. In future articles, I’ll examine more in-depth knowledge of kernel modules. </p>
<h4 id="Write-the-module"><a href="#Write-the-module" class="headerlink" title="Write the module"></a>Write the module</h4><p>You can write the <code>hello world</code> Kernel module with a single <code>C</code> source code file <code>hello.c</code> as follows:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>We can write a Kernel module in such an easy and simple way because the Linux Kernel does the magic for you. Remember the design philosophy of Linux(Unix): <strong><em>Design for simplicity; add complexity only where you must</em></strong>. </p>
<p>Let’s examine several technical points worth to remark as follows: </p>
<p>First, Kernel modules must have at least two functions: a “start” function which is called when the module is loaded into the kernel, and an “end” function which is called just before it is removed from the kernel. Before kernel 2.3.13, the names of these two functions are hardcoded as <code>init_module()</code> and <code>cleanup_module()</code>. But in the new versions, you can use whatever name you like for the start and end functions of a module by using the <code>module_init</code> and <code>module_exit</code> macros. The macros are defined in <code>include/linux/module.h</code> and <code>include/linux/init.h</code>. You can refer there for detailed information. </p>
<p>Typically, <code>module_init</code> either registers a handler for something with the kernel (for example, the mini-firewall developed in this article), or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <code>module_exit</code> function is supposed to undo whatever <code>module_init</code> did, so the module can be unloaded safely.</p>
<p>Second, <code>printk</code> function provides similar behaviors to <code>printf</code>, which accepts the <code>format string</code> as the first argument. The <code>printk</code> function prototype goes as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>printk</code> function allows a caller to specify <code>log level</code> to indicate the type and importance of the message being sent to the kernel message log. For example, in the above code, the log level <code>KERN_INFO</code> is specified by prepending to the format string. In C programming, this syntax is called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/String_literal#String_literal_concatenation"><code>string literal concatenation</code></a>. (In other high-level programming languages, string concatenation is generally done with <code>+</code> operator). For the function <code>printk</code> and <code>log level</code>, you can find more information in <code>include/linux/kern_levels.h</code> and <code>include/linux/printk.h</code>.   </p>
<p>Note: The path to header files for Linux kernel module development is different from the one you often used for the application development. Don’t try to find the header file inside <em>/usr/include/linux</em>, instead please use the following path <em>/lib/modules/`uname -r`/build/include/linux</em> (<code>uname -r</code> command returns your kernel version).</p>
<p>Next, let’s build this hello-world kernel module.</p>
<h4 id="Build-the-module"><a href="#Build-the-module" class="headerlink" title="Build the module"></a>Build the module</h4><p>The way to build a kernel module is a little different from how to build a user-space application. The efficient solution to build kernel image and its modules is <code>Kernel Build System(Kbuild)</code>. </p>
<p><code>Kbuild</code> is a complex topic and I won’t explain it in too much detail here. Simply speaking, <code>Kbuild</code> allows you to create highly customized kernel binary images and modules. Technically, each subdirectory contains a <code>Makefile</code> compiling only the source code files in its directory. And a top-level Makefile recursively executes each subdirectory’s Makefile to generate the binary objects. And you can control which subdirectories are included by defining <code>config files</code>. In detail, you can refer to other <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system">documents</a>. </p>
<p>The following is the Makefile for the <code>hello world</code> module: </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>The <code>make -C dir</code> command changes to directory dir before reading the makefiles or doing anything else. The top-level Makefile in <em>/lib/modules/$(shell uname -r)/build</em> will be used. You can find that command <code>make M=dir modules</code> is used to make all modules in specified dir.</p>
<p>And in the module-level Makefile, the <code>obj-m</code> syntax tells <code>kbuild</code> system to build <code>module_name.o</code> from <code>module_name.c</code>, and after linking, will result in the kernel module <code>module_name.ko</code>. In our case, the module name is <code>hello</code>.</p>
<p>The build process goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ sudo make</span><br><span class="line">make -C /lib/modules/4.15.0-176-generic/build M=/home/DIR/jbao6/develop/kernel/hello-1  modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br><span class="line">  CC [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/DIR/jbao6/develop/kernel/hello-1/hello.mod.o</span><br><span class="line">  LD [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br></pre></td></tr></table></figure>
<p>After the build, you can get several new files in the same directory: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ <span class="built_in">ls</span></span><br><span class="line">hello.c  hello.ko  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span><br></pre></td></tr></table></figure>
<p>The file ends with <code>.ko</code> is the kernel module. You can ignore other files now, I will write another article later to have a deep discussion about the kernel module system. </p>
<h4 id="Load-the-module"><a href="#Load-the-module" class="headerlink" title="Load the module"></a>Load the module</h4><p>With the <code>file</code> command, you can note that the kernel module is an <code>ELF(Executable and Linkable Format)</code> format file. ELF files are typically the output of a compiler or linker and are a binary format. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisba:~/develop/kernel/hello-1$ file hello.ko</span><br><span class="line">hello.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=f0da99c757751e7e9f9c4e55f527fb034a0a4253, not stripped</span><br></pre></td></tr></table></figure>

<p>Next step, let’s try to install and remove the module dynamically. You need to know the following three commands: </p>
<ul>
<li><em>lsmod</em>: shows the list of kernel modules currently loaded.</li>
<li><em>insmod</em>: inserts a module into the Linux Kernel by running <code>sudo insmod module_name.ko</code></li>
<li><em>rmmod</em>: removes a module from the Linux Kernel by running <code>sudo rmmod module_name</code></li>
</ul>
<p>Since the <code>hello world</code> module is quite simple, you can easily install and remove the module as you wish. I will not show the detailed commands here and leave it to the readers. </p>
<p><strong>Note</strong>: It doesn’t mean that you can easily install and remove any kernel module without any issues. If the module you are loading has bugs, the entire system can crash. </p>
<h4 id="Debug-the-module"><a href="#Debug-the-module" class="headerlink" title="Debug the module"></a>Debug the module</h4><p>Next step, let’s prove that the <code>hello world</code> module is installed and removed as expected. We will use <code>dmesg</code> command. <code>dmesg</code> (diagnostic messages) can print the messages in the <code>kernel ring buffer</code>. </p>
<p>First, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circular_buffer"><code>ring buffer</code></a> is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. The <code>kernel ring buffer</code> is a ring buffer that records messages related to the operation of the kernel. As we mentioned above, the kernel logs printed by the <code>printk</code> function will be sent to the kernel ring buffer. </p>
<p>We can find the messages produced by our module with command <code>dmesg | grep world</code> as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~$ dmesg | grep world</span><br><span class="line"></span><br><span class="line">[2147137.177254] Hello, world</span><br><span class="line">[3281962.445169] Goodbye, world</span><br><span class="line">[3282008.037591] Hello, world</span><br><span class="line">[3282054.921824] Goodbye, world</span><br></pre></td></tr></table></figure>

<p>Now you can see that the <code>hello world</code> is loaded into the kernel correctly. And it can be removed dynamically as well. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to write a kernel module, how to build it and how to install it into the kernel dynamically. Next article we can work on the mini-firewall as a <code>Netfilter</code> module. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/05/how-to-write-a-netfilter-firewall-part2/" data-id="clgorr6xo001j0gmm1393foxq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binary-Search-Tree-delete-balanced-performance/" rel="tag">Binary Search Tree, delete, balanced, performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Binary-Search-Tree-delete-balanced-performance/" style="font-size: 10px;">Binary Search Tree, delete, balanced, performance</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/13/note-on-red-black-tree/">Understand Red Black Tree: part one - background</a>
          </li>
        
          <li>
            <a href="/2023/01/01/bst-deletion-issue/">Deletion operation in Binary Search Tree: successor or predecessor</a>
          </li>
        
          <li>
            <a href="/2022/12/06/external-sorting-two/">External Mergesort: part two</a>
          </li>
        
          <li>
            <a href="/2022/11/02/external-sorting-one/">External Mergesort: part one</a>
          </li>
        
          <li>
            <a href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>