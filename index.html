<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-how-to-write-a-netfilter-firewall-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/" class="article-date">
  <time datetime="2022-05-05T10:06:50.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two- hello world module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this last <a href="https://organicprogrammer.com/2022/05/04/how-to-write-a-netfilter-firewall/" target="_blank" rel="noopener">article</a>, we examined the basics of <code>Netfilter</code> and <code>Linux kernel modules</code> in theory. Starting from this article, we will make our hands dirty and start implementing our mini-firewall. We will walk through the whole process step by step. In this article, let’s write our first Linux kernel module using a simple <code>hello world</code> demo. Then let’s learn how to build the module(which is very different from compiling an application in the user space) and how to load it in the kernel. After understanding how to write a module, in the next article, let’s write the initial version of our mini-firewall module using <a href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks" target="_blank" rel="noopener">Netfilter’s hook architecture</a>. All right. Let’s start the journey. </p>
<h3 id="Make-the-first-Kernel-module"><a href="#Make-the-first-Kernel-module" class="headerlink" title="Make the first Kernel module"></a>Make the first Kernel module</h3><p>First, I have to admit that Linux Kernel module development is a kind of large and complex technology topic. And there are many great <a href="https://sysprog21.github.io/lkmpg/" target="_blank" rel="noopener">online resources</a> about it. This series of articles is focusing on developing the mini-firewall based on Netfilter, so we can’t cover all the aspects of the Kernel module itself. In future articles, I’ll examine more in-depth knowledge of kernel modules. </p>
<h4 id="Write-the-module"><a href="#Write-the-module" class="headerlink" title="Write the module"></a>Write the module</h4><p>You can write the <code>hello world</code> Kernel module with a single <code>C</code> source code file <code>hello.c</code> as follows:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt; /* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt; /* Needed by all modules */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"Goodbye, world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<p>We can write a Kernel module in such an easy and simple way because the Linux Kernel does the magic for you. Remember the design philosophy of Linux(Unix): <strong><em>Design for simplicity; add complexity only where you must</em></strong>. </p>
<p>Let’s examine several technical points worth to remark as follows: </p>
<p>First, Kernel modules must have at least two functions: a “start” function which is called when the module is loaded into the kernel, and an “end” function which is called just before it is removed from the kernel. Before kernel 2.3.13, the names of these two functions are hardcoded as <code>init_module()</code> and <code>cleanup_module()</code>. But in the new versions, you can use whatever name you like for the start and end functions of a module by using the <code>module_init</code> and <code>module_exit</code> macros. The macros are defined in <code>include/linux/module.h</code> and <code>include/linux/init.h</code>. You can refer there for detailed information. </p>
<p>Typically, <code>module_init</code> either registers a handler for something with the kernel (for example, the mini-firewall developed in this article), or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <code>module_exit</code> function is supposed to undo whatever <code>module_init</code> did, so the module can be unloaded safely.</p>
<p>Second, <code>printk</code> function provides similar behaviors to <code>printf</code>, which accepts the <code>format string</code> as the first argument. The <code>printk</code> function prototype goes as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>printk</code> function allows a caller to specify <code>log level</code> to indicate the type and importance of the message being sent to the kernel message log. For example, in the above code, the log level <code>KERN_INFO</code> is specified by prepending to the format string. In C programming, this syntax is called <a href="https://en.wikipedia.org/wiki/String_literal#String_literal_concatenation" target="_blank" rel="noopener"><code>string literal concatenation</code></a>. (In other high-level programming languages, string concatenation is generally done with <code>+</code> operator). For the function <code>printk</code> and <code>log level</code>, you can find more information in <code>include/linux/kern_levels.h</code> and <code>include/linux/printk.h</code>.   </p>
<p>Note: The path to header files for Linux kernel module development is different from the one you often used for the application development. Don’t try to find the header file inside <em>/usr/include/linux</em>, instead please use the following path <em>/lib/modules/`uname -r`/build/include/linux</em> (<code>uname -r</code> command returns your kernel version).</p>
<p>Next, let’s build this hello-world kernel module.</p>
<h4 id="Build-the-module"><a href="#Build-the-module" class="headerlink" title="Build the module"></a>Build the module</h4><p>The way to build a kernel module is a little different from how to build a user-space application. The efficient solution to build kernel image and its modules is <code>Kernel Build System(Kbuild)</code>. </p>
<p><code>Kbuild</code> is a complex topic and I won’t explain it in too much detail here. Simply speaking, <code>Kbuild</code> allows you to create highly customized kernel binary images and modules. Technically, each subdirectory contains a <code>Makefile</code> compiling only the source code files in its directory. And a top-level Makefile recursively executes each subdirectory’s Makefile to generate the binary objects. And you can control which subdirectories are included by defining <code>config files</code>. In detail, you can refer to other <a href="https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system" target="_blank" rel="noopener">documents</a>. </p>
<p>The following is the Makefile for the <code>hello world</code> module: </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>The <code>make -C dir</code> command changes to directory dir before reading the makefiles or doing anything else. The top-level Makefile in <em>/lib/modules/$(shell uname -r)/build</em> will be used. You can find that command <code>make M=dir modules</code> is used to make all modules in specified dir.</p>
<p>And in the module-level Makefile, the <code>obj-m</code> syntax tells <code>kbuild</code> system to build <code>module_name.o</code> from <code>module_name.c</code>, and after linking, will result in the kernel module <code>module_name.ko</code>. In our case, the module name is <code>hello</code>.</p>
<p>The build process goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ sudo make</span><br><span class="line">make -C /lib/modules/4.15.0-176-generic/build M=/home/DIR/jbao6/develop/kernel/hello-1  modules</span><br><span class="line">make[1]: Entering directory <span class="string">'/usr/src/linux-headers-4.15.0-176-generic'</span></span><br><span class="line">  CC [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/DIR/jbao6/develop/kernel/hello-1/hello.mod.o</span><br><span class="line">  LD [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">'/usr/src/linux-headers-4.15.0-176-generic'</span></span><br></pre></td></tr></table></figure>
<p>After the build, you can get several new files in the same directory: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ ls</span><br><span class="line">hello.c  hello.ko  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span><br></pre></td></tr></table></figure>
<p>The file ends with <code>.ko</code> is the kernel module. You can ignore other files now, I will write another article later to have a deep discussion about the kernel module system. </p>
<h4 id="Load-the-module"><a href="#Load-the-module" class="headerlink" title="Load the module"></a>Load the module</h4><p>With the <code>file</code> command, you can note that the kernel module is an <code>ELF(Executable and Linkable Format)</code> format file. ELF files are typically the output of a compiler or linker and are a binary format. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisba:~/develop/kernel/hello-1$ file hello.ko</span><br><span class="line">hello.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=f0da99c757751e7e9f9c4e55f527fb034a0a4253, not stripped</span><br></pre></td></tr></table></figure>

<p>Next step, let’s try to install and remove the module dynamically. You need to know the following three commands: </p>
<ul>
<li><em>lsmod</em>: shows the list of kernel modules currently loaded.</li>
<li><em>insmod</em>: inserts a module into the Linux Kernel by running <code>sudo insmod module_name.ko</code></li>
<li><em>rmmod</em>: removes a module from the Linux Kernel by running <code>sudo rmmod module_name</code></li>
</ul>
<p>Since the <code>hello world</code> module is quite simple, you can easily install and remove the module as you wish. I will not show the detailed commands here and leave it to the readers. </p>
<p><strong>Note</strong>: It doesn’t mean that you can easily install and remove any kernel module without any issues. If the module you are loading has bugs, the entire system can crash. </p>
<h4 id="Debug-the-module"><a href="#Debug-the-module" class="headerlink" title="Debug the module"></a>Debug the module</h4><p>Next step, let’s prove that the <code>hello world</code> module is installed and removed as expected. We will use <code>dmesg</code> command. <code>dmesg</code> (diagnostic messages) can print the messages in the <code>kernel ring buffer</code>. </p>
<p>First, a <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener"><code>ring buffer</code></a> is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. The <code>kernel ring buffer</code> is a ring buffer that records messages related to the operation of the kernel. As we mentioned above, the kernel logs printed by the <code>printk</code> function will be sent to the kernel ring buffer. </p>
<p>We can find the messages produced by our module with command <code>dmesg | grep world</code> as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~$ dmesg | grep world</span><br><span class="line"></span><br><span class="line">[2147137.177254] Hello, world</span><br><span class="line">[3281962.445169] Goodbye, world</span><br><span class="line">[3282008.037591] Hello, world</span><br><span class="line">[3282054.921824] Goodbye, world</span><br></pre></td></tr></table></figure>

<p>Now you can see that the <code>hello world</code> is loaded into the kernel correctly. And it can be removed dynamically as well. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to write a kernel module, how to build it and how to install it into the kernel dynamically. Next article we can work on the mini-firewall as a <code>Netfilter</code> module. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/05/how-to-write-a-netfilter-firewall-part2/" data-id="cl458i8by001894mmhdh38lei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/" class="article-date">
  <time datetime="2022-05-04T10:06:50.000Z" itemprop="datePublished">2022-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><code>Firewalls</code> are an important tool that can be configured to protect your servers and infrastructure. Firewalls’ main functionalities are filtering data, redirecting traffic, and protecting against network attacks. There are both hardware-based firewalls and software-based firewalls. I will not discuss too much about firewalls, since you can find many online documents about <a href="https://en.wikipedia.org/wiki/Firewall_(computing)" target="_blank" rel="noopener">it</a>. I </p>
<p>Have you ever thought of implementing a simple firewall from scratch? Sounds crazy? But with the power of Linux, you can do that. After you read this series of articles, you will find that actually, it is quite simple. </p>
<p>You may once use various firewalls on Linux such as <a href="https://en.wikipedia.org/wiki/Iptables" target="_blank" rel="noopener">iptables</a>, <a href="https://en.wikipedia.org/wiki/Nftables" target="_blank" rel="noopener">nftables</a>, <a href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall" target="_blank" rel="noopener">UFW</a>, etc. All of these firewall tools are user-space utility programs, and they are all relying on <a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener"><code>Netfilter</code></a>. <code>Netfilter</code> is the Linux kernel subsystem that allows various networking-related operations to be implemented. <code>Netfilter</code> allows you to develop your firewall using the <code>Linux Kernel Module</code>.  If you don’t know the techniques such as the Linux Kernel module and Netfilter, don’t worry. In this article, let’s write a Linux firewall from scratch based on Netfilter. You can learn the following interesting points:</p>
<ul>
<li>Linux kernel module development.</li>
<li>Linux kernel network programming. </li>
<li>Netfilter module development.</li>
</ul>
<h3 id="Netfilter-and-Kernel-modules"><a href="#Netfilter-and-Kernel-modules" class="headerlink" title="Netfilter and Kernel modules"></a>Netfilter and Kernel modules</h3><h4 id="Basics-of-Netfilter"><a href="#Basics-of-Netfilter" class="headerlink" title="Basics of Netfilter"></a>Basics of Netfilter</h4><p><code>Netfilter</code> can be considered to be the third generation of <code>firewall</code> on Linux. Before <code>Netfilter</code>was introduced in Linux Kernel 2.4, there are two older generations of firewalls on Linux as follows: </p>
<ul>
<li>The first generation was a port of an early version of BSD UNIX’s <code>ipfw</code> to Linux 1.1. </li>
<li>The second generation was <code>ipchains</code> developed in the 2.2 series of Linux Kernel. </li>
</ul>
<p>As we mentioned above, <code>Netfilter</code> was designed to provide the infrastructure inside the Linux kernel for various networking operations. So <code>firewall</code> is just one of the multiple functionalities provided by <code>Netfilter</code> as follows:</p>
<img src="/images/netfilter-arch.png" title="Netfilter architecture" width="600px" height="400px">

<ul>
<li><strong>Packet filtering</strong>: is in charge of filtering the packets based on the rules. It is also the topic of this article. </li>
<li><strong>NAT (Network address translation)</strong>: is in charge of translating the IP address of network packets. <code>NAT</code> is an important protocol, which has become a popular and essential tool in <code>conserving global address space in the face of IPv4 address exhaustion</code>. If you don’t know <code>NAT</code> protocol, you can refer to other <a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="noopener">documents</a>. I will examine it in other future articles. </li>
<li><strong>Packet mangling</strong>: is in charge of modifying the packet content(In fact, <code>NAT</code> is one kind of packet mangling, which modifies the source or destination IP address). For example, <code>MSS (Maximum Segment Size)</code> value of TCP SYN packets can be altered to allow large-size packets transported over the network. </li>
</ul>
<p>Note: this article will focus on building a simple firewall to filter packets based on Netfilter. So the <code>NAT</code> and <code>Packet Mangling</code> parts are not in the scope of this article. </p>
<p>Packet filtering can only be done inside the Linux kernel (Netfilter’s code is in the kernel as well), if we want to write a mini firewall, it has to run in the kernel space. Right? Does it mean we need to add our code into the kernel and recompile the kernel? Imagine you have to recompile the kernel each time you want to add a new packet filtering rule. That’s a bad idea. The good news is that <code>Netfilter</code> allows you to add extensions using the <a href="https://wiki.archlinux.org/title/Kernel_module" target="_blank" rel="noopener"><code>Linux kernel modules</code></a>. </p>
<h4 id="Basics-of-Linux-Kernel-modules"><a href="#Basics-of-Linux-Kernel-modules" class="headerlink" title="Basics of Linux Kernel modules"></a>Basics of Linux Kernel modules</h4><p>Although Linux is a <a href="https://en.wikipedia.org/wiki/Monolithic_kernel" target="_blank" rel="noopener"><code>monolithic kernel</code></a>, it can be extended using kernel modules. Modules can be inserted into the kernel and removed on demand. Linux isolates the kernel but allows you to add specific functionality on the fly through modules. In this way, Linux keeps a balance between stability and usability. </p>
<p>I want to examine one confusing point about the kernel module here: what is the difference between <code>driver</code> and <code>module</code>:</p>
<ul>
<li>A driver is a bit of code that runs in the kernel to talk to some hardware device. It drives the hardware. Standard practice is to build drivers as kernel modules where possible, rather than link them statically to the kernel since that gives more flexibility. </li>
<li>A kernel module may not be a device driver at all.    </li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In the first post of this series, we examine the basics of Netfilter and Linux kernel modules. In the next post, let’s start implementing the mini firewall. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/04/how-to-write-a-netfilter-firewall-part1/" data-id="cl458i8by001794mm25a0ayn7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" class="article-date">
  <time datetime="2022-03-28T06:15:15.000Z" itemprop="datePublished">2022-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the <a href="https://organicprogrammer.com/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" target="_blank" rel="noopener">previous article</a>, we examined how to develop a network sniffer with <code>PF_SOCKET</code> socket in Linux platform. The sniffer developed in the last article captures all the network packets. But a powerful network sniffer like <code>tcpdump</code> should provide the packet filtering functionality. For instance, the sniffer can only capture the <code>TCP</code> segment(and skip the UPD), or it can only capture the packets from a specific source IP address. In this article, let’s continue to explore how to do that. </p>
<h3 id="Background-of-BPF"><a href="#Background-of-BPF" class="headerlink" title="Background of BPF"></a>Background of BPF</h3><p><code>Berkeley Packet Filter(BPF)</code> is the essential underlying technology for packet capture in Unix-like operating systems.<br>Search BPF as the keyword online, and the result is very confusing. It turns out that <code>BPF</code> keeps evolving, and there are several associated concepts such as <code>BPF</code> <code>cBPF</code> <code>eBPF</code> and <code>LSF</code>. So let us examine those concepts along the timeline:</p>
<ul>
<li><p>In <strong>1992</strong>, <code>BPF</code> was first introduced to the BSD Unix system for filtering unwanted network packets. The proposal of BPF was from researchers in Lawrence Berkeley Laboratory, who also developed the <code>libpcap</code> and <code>tcpdump</code>. </p>
</li>
<li><p>In <strong>1997</strong>, Linux Socket Filter(LSF) was developed based on BPF and introduced in Linux kernel version 2.1.75. Note that <code>LSF</code> and <code>BPF</code> have some distinct differences, but in the Linux context, when we speak of BPF or LSF, we mean the same packet filtering mechanism in the Linux kernel. We’ll examine the detailed theory and design of BPF in the following sections. </p>
</li>
<li><p>Originally, BPF was designed as a network packet filter. But in <strong>2013</strong>, BPF was widely extended, and it can be used for non-networking purposes such as performance analysis and troubleshooting. Nowadays, the extended BPF is called <code>eBPF</code>, and the original and obsolete version is renamed to classic BPF (<code>cBPF</code>). <strong>Note that what we examine in this article is cBPF, and eBPF is not inside the scope of this article</strong>. <code>eBPF</code> is the hottest technology in today’s software world, and I’ll talk about it in the future. </p>
</li>
</ul>
<h3 id="Where-to-place-BPF"><a href="#Where-to-place-BPF" class="headerlink" title="Where to place BPF"></a>Where to place BPF</h3><p>The first question to answer is where should we place the filter. The last article examines the path of a received packet  as follows: </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>The best solution to this question is to put the filter as early as possible in the path. Since copying a large amount of data from kernel space to the user space produces a huge overhead, which can influence the system performance a lot. So BPF is a kernel feature. The filter should be triggered immediately when a packet is received at the network interface.As the original BPF <a href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">paper</a> said <strong>To minimize memory traffic, the major bottleneck in most modern system, the packet should be filtered ‘in place’ (e.g., where the network interface DMA engine put it) rather than copied to some other kernel buffer before filtering.</strong><br>Let’s verify this behavior by examining the kernel source code as follows (<strong>Note</strong> the kernel code shown in this article is based on version 2.6, which contains the <code>cBPF</code> implementation.): </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source code file of net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* packet_create: create socket */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">	po = pkt_sk(sk);</span><br><span class="line">	sk-&gt;sk_family = PF_PACKET;</span><br><span class="line">	po-&gt;num = proto;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;po-&gt;bind_lock);</span><br><span class="line">	po-&gt;prot_hook.func = packet_rcv; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">		po-&gt;prot_hook.func = packet_rcv_spkt; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proto) &#123;</span><br><span class="line">		po-&gt;prot_hook.type = proto;</span><br><span class="line">		dev_add_pack(&amp;po-&gt;prot_hook);</span><br><span class="line">		sock_hold(sk);</span><br><span class="line">		po-&gt;<span class="built_in">running</span> = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_create</code> function handles the socket creation when the application calls the <code>socket</code> system call. In lines 11 and 14, it attaches the hook function to the socket. The hook function executes when the packet is received.</p>
<p>The following code block shows the hook function <code>packet_rcv</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hook function packet_rcv is triggered, when the packet is received */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_rcv</span><span class="params">(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    sk = pt-&gt;af_packet_priv;</span><br><span class="line">    snaplen = skb-&gt;len;</span><br><span class="line">    res = run_filter(skb, sk, snaplen); <span class="comment">// filter logic</span></span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">	    <span class="keyword">goto</span> drop_n_restore; <span class="comment">// drop the packet</span></span><br><span class="line"></span><br><span class="line">    __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb); <span class="comment">// put the packet into the queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_rcv</code> function calls <code>run_filter</code>, which is just the BPF logic part(Currently, you can regard it as a black box. In the next section, we’ll examine the details). Based on the return value of <code>run_filter</code> the packet can be filtered out or put into the queue. </p>
<p>So far, you can understand BPF(or the packet filtering) is working inside kernel space. But the packet sniffer is a user-space application. The next question is how to link the filtering rules in user space to the filtering handler in kernel space. </p>
<p>To answer this question, we have to understand BPF itself. It’s right time to understand this great piece of work. </p>
<h3 id="BPF-machine"><a href="#BPF-machine" class="headerlink" title="BPF machine"></a>BPF machine</h3><p>As I mentioned above, <code>BPF</code> was introduced in this original <a href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">paper</a> written by researchers from Berkeley. I strongly recommend you read this great paper based on my own experience. In the beginning, I felt crazy to read it, so I read other related documents and tried to understand BPF. But most documents only cover one portion of the entire system, so it is difficult to piece all the information together. Finally, I read the original paper and connected all parts together. <strong>As the saying goes, sometimes taking time is actually a shortcut.</strong></p>
<h5 id="Virtual-CPU"><a href="#Virtual-CPU" class="headerlink" title="Virtual CPU"></a>Virtual CPU</h5><p>A packet filter is simply a boolean-valued function on a packet. If the value of the function is true the kernel copies the packet for the application; if it is false the packet is ignored. </p>
<p>In order to be as flexible as possible and not to limit the application to a set of predefined conditions, the <code>BPF</code> is actually implemented as a <code>register-based virtual machine</code> (for the difference between stack-based and register-based virtual machine, you can refer to <a href="http://troubles.md/wasm-is-not-a-stack-machine/" target="_blank" rel="noopener">this article</a>) running a user-defined program.  </p>
<p>You can regard the <code>BPF</code> as a <code>virtual CPU</code>. And it consists of an <code>accumulator</code>, an <code>index register(x)</code>, a scratch memory store, and an implicit <code>program counter</code>. If you’re not familiar with these concepts, I add some simple illustrations as follows:</p>
<ul>
<li>An <code>accumulator</code> is a type of register included in a CPU. It acts as a temporary storage location holding an intermediate value in mathematical and logical calculations. For example, in the operation of “1+2+3”, the accumulator would hold the value 1, then the value 3, then the value 6. The benefit of an accumulator is that it does not need to be explicitly referenced.</li>
<li>An <code>index register</code> in a computer’s CPU is a processor register or assigned memory location used for modifying operand addresses during the run of a program. </li>
<li>A <code>program counter</code> is a CPU register in the computer processor which has the address of the next instruction to be executed from memory. </li>
</ul>
<p>In the BPF machine, the accumulator is used for arithmetic operations, while the index register provides offsets into the packet or the scratch memory areas.  </p>
<h5 id="Instructions-set-and-addressing-mode"><a href="#Instructions-set-and-addressing-mode" class="headerlink" title="Instructions set and addressing mode"></a>Instructions set and addressing mode</h5><p>Same as the physical CPU, the <code>BPF</code> provides a small set of arithmetic, logical and jump instructions as follows, these instructions run on the BPF virtual machine(or CPU): </p>
<img src="/images/bpf-instructions.png" title="BPF instructions" width="400px" height="300px">

<p>The first column <em>opcodes</em> lists the BPF instructions written in an assembly language style. For example, <strong>ld</strong>, <strong>ldh</strong> and <strong>ldb</strong> means to copy the indicated value into the <code>accumulator</code>. <strong>ldx</strong> means to copy the indicated value into the <code>index register</code>. <strong>jeq</strong> means jump to the target instruction if the <code>accumulator</code> equals the indicated value. <strong>ret</strong> means return the indicated value. You can check the functionality of the instructions set in detail in the paper. </p>
<p>This kind of assembly-like style is more readable to humans. But when we develop an application (like the sniffer written in this article), we use binary code directly as the BPF instruction. This kind of binary format is called <code>BPF Bytecode</code>. I’ll examine the way to convert this assembly language to bytecode later. </p>
<p>The second column <em>addr modes</em> lists the addressing modes allowed for each instruction. The semantics of the addressing modes are listed in the following table: </p>
<img src="/images/address-mode.png" title="BPF instructions address mode" width="400px" height="300px">

<p>For instance, <strong>[k]</strong> means the data at byte offset k in the packet. <strong>#k</strong> means the literal value stored in k. You can read the paper in detail to check the meaning of other address modes.  </p>
<h5 id="Example-BPF-program"><a href="#Example-BPF-program" class="headerlink" title="Example BPF program"></a>Example BPF program</h5><p>Now let’s try to understand the following small BPF program based on the knowledge above: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2    jf 3</span><br><span class="line">(002) ret      #262144</span><br><span class="line">(003) ret      #0</span><br></pre></td></tr></table></figure>
<p>The BPF program consists of an array of BPF instructions. For example, the above BPF program contains four instructions. </p>
<p>The first instruction <strong>ldh</strong> loads a half-word(16-bit) value into the accumulator from offset 12 in the Ethernet packet. According to the Ethernet frame format shown below, the value is just the <code>Ethernet type</code> field. The Ethernet type is used to indicate which protocol is encapsulated in the frame’s payload (for example,  0x0806 for ARP, <strong>0x0800</strong> for IPv4, and 0x86DD for IPv6).</p>
<img src="/images/ethernet-frame-format.png" title="Ethernet frame fromat" width="600px" height="400px">

<p>The second instruction <strong>jeq</strong> compares the accumulator (currently stores <code>Ethernet type</code> field) to <code>0x800</code>(stands for IPv4). If the comparison fails, zero is returned, and the packet is rejected. If it is successful, a non-zero value is returned, and the packet is accepted. <strong>So the small BPF program filters and accepts all IP packets</strong>. You can find other BPF programs in the original paper. Go to read it, and you can feel the flexibility of BPF as well as the beauty of the design. </p>
<h5 id="Kernel-implementation-of-BPF"><a href="#Kernel-implementation-of-BPF" class="headerlink" title="Kernel implementation of BPF"></a>Kernel implementation of BPF</h5><p>Next, let’s examine how kernel implements BPF. As mentioned above, the hook function <code>packet_rcv</code> calls <code>run_filter</code> to handle the filtering logic. <code>run_filter</code> is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copied from net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* function run_filter is called in packet_rcv*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">run_filter</span><span class="params">(struct sk_buff *skb, struct sock *sk,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	filter = rcu_dereference(sk-&gt;sk_filter); <span class="comment">// get the filter bound to the socket</span></span><br><span class="line">	<span class="keyword">if</span> (filter != <span class="literal">NULL</span>)</span><br><span class="line">		res = sk_run_filter(skb, filter-&gt;insns, filter-&gt;len); <span class="comment">// the filtering is inside sk_run_filter function</span></span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find that the real filtering logic is inside <code>sk_run_filter</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sk_run_filter</span><span class="params">(struct sk_buff *skb, struct sock_filter *filter, <span class="keyword">int</span> flen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">fentry</span>;</span>	<span class="comment">/* We walk down these */</span></span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	u32 A = <span class="number">0</span>;			<span class="comment">/* Accumulator */</span></span><br><span class="line">	u32 X = <span class="number">0</span>;			<span class="comment">/* Index Register */</span></span><br><span class="line">	u32 mem[BPF_MEMWORDS];		<span class="comment">/* Scratch Memory Store */</span></span><br><span class="line">	u32 tmp;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> pc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Process array of filter instructions.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (pc = <span class="number">0</span>; pc &lt; flen; pc++) &#123;</span><br><span class="line">		fentry = &amp;filter[pc];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (fentry-&gt;code) &#123;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_X:</span><br><span class="line">			A += X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_K:</span><br><span class="line">			A += fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_X:</span><br><span class="line">			A -= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_K:</span><br><span class="line">			A -= fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_MUL|BPF_X:</span><br><span class="line">			A *= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* some code omitted ... */</span></span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_K:</span><br><span class="line">			<span class="keyword">return</span> fentry-&gt;k;</span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_A:</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		<span class="keyword">case</span> BPF_ST:</span><br><span class="line">			mem[fentry-&gt;k] = A;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_STX:</span><br><span class="line">			mem[fentry-&gt;k] = X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Same as we mentioned, <code>sk_run_filter</code> is simply a boolean-valued function on a packet. It maintains the accumulator, the index register, etc. as local variables. And process the array of BPF filter instructions in a <code>for</code> loop. Each instruction will update the value of local variables. In this way, it simulates a virtual CPU. Interesting, right? </p>
<h5 id="BPF-JIT"><a href="#BPF-JIT" class="headerlink" title="BPF JIT"></a>BPF JIT</h5><p>Since each network packet must go through the filtering function, it becomes the performance bottleneck of the entire system. </p>
<p>A <code>just-in-time (JIT)</code> compiler was introduced into the kernel in <strong>2011</strong> to speed up BPF bytecode execution. </p>
<ul>
<li>What is a <code>JIT</code> compiler? A <code>JIT</code> compiler runs <strong>after</strong> the program has started and compiles the code(usually bytecode or some type of VM instructions) on the fly(or just in time) into a form that’s usually faster, typically the host CPU’s native instruction set. This is in contrast to a <code>traditional compiler</code> that compiles all the code to machine language <strong>before</strong> the program is first run. </li>
</ul>
<p>In the <code>BPF</code> case, the <code>JIT</code> compiler translates BPF bytecode into a host system’s assembly code directly, which can optimize the performance a lot. I’ll not show details about JIT in this article. You can refer to the <a href="https://elixir.bootlin.com/linux/v3.19.8/source/arch/arm/net/bpf_jit_32.c#L868" target="_blank" rel="noopener">kernel code</a>.  </p>
<h3 id="Set-BPF-in-sniffer"><a href="#Set-BPF-in-sniffer" class="headerlink" title="Set BPF in sniffer"></a>Set BPF in sniffer</h3><p>Next, let’s add BPF into our packet sniffer. As we mentioned above in the application level, the BPF instructions should use bytecode format with the following data structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>    <span class="comment">/* Filter block */</span></span><br><span class="line">        __u16   code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">        __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">        __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">        __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How can we convert the BPF assembly language into bytecode? There are two solutions. First, there is a small helper tool called <code>bpf_asm</code>(which is provided along with the Linux kernel), and you can regard it as the BPF assembly language interpreter. But it is not recommended to application developers. </p>
<p>Second, we can use <code>tcpdump</code>, which provides the converting functionality. You can find the following information from the tcpdump man page: </p>
<ul>
<li><p>-d:   Dump the compiled packet-matching code in a human-readable form to standard output and stop.</p>
</li>
<li><p>-dd:  Dump packet-matching code as a C program fragment.</p>
</li>
<li><p>-ddd: Dump packet-matching code as decimal numbers (preceded with a count).</p>
</li>
</ul>
<p><code>tcpdump ip</code> means we want to capture all the IP packets. With options <strong>-d</strong>, <strong>-dd</strong> and <strong>-ddd</strong>, the output goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">baoqger@ubuntu:~$ sudo tcpdump -d ip</span><br><span class="line">[sudo] password <span class="keyword">for</span> baoqger:</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      <span class="comment">#0x800           jt 2    jf 3</span></span><br><span class="line">(002) ret      <span class="comment">#262144</span></span><br><span class="line">(003) ret      <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -dd ip</span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -ddd ip</span><br><span class="line">4</span><br><span class="line">40 0 0 12</span><br><span class="line">21 0 1 2048</span><br><span class="line">6 0 0 262144</span><br><span class="line">6 0 0 0</span><br></pre></td></tr></table></figure>
<p>Option <strong>-d</strong> prints the BPF instructions in assembly language (same as the example BPF program shown above). Options <strong>-dd</strong> prints the bytecode as a C program fragment. <strong>So tcpdump is the most convenient tool when you want to get the BPF bytecode</strong>.</p>
<p>The BPF filter bytecode (wrapped in the structure <code>sock_fprog</code>) can be passed to the kernel through <code>setsockopt</code> system call as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attach the filter to the socket</span></span><br><span class="line"><span class="comment">// the filter code is generated by running: tcpdump tcp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">BPF_code</span>[] = &#123;</span></span><br><span class="line">	&#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">Filter</span>;</span></span><br><span class="line"><span class="comment">// error prone code, .len field should be consistent with the real length of the filter code array</span></span><br><span class="line">Filter.len = <span class="keyword">sizeof</span>(BPF_code)/<span class="keyword">sizeof</span>(BPF_code[<span class="number">0</span>]); </span><br><span class="line">Filter.filter = BPF_code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">"setsockopt attach filter"</span>);</span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setsockopt</code> system call triggers two kernel functions: <code>sock_setsockopt</code> and <code>sk_attach_filter</code> (I’ll not show the details for these two functions), which <strong>binds the filters to the socket</strong>. And in <code>run_filter</code> kernel function (mentioned above), it can <strong>get the filters from the socket</strong> and <strong>execute the filters on the packet</strong>. </p>
<p>So far, every piece is connected. The puzzle of BPF is solved. The <code>BPF</code> machine allows the user-space applications to inject customized BPF programs straight into a kernel. Once loaded and verified, BPF programs execute in kernel context. These BPF programs operate inside kernel memory space with access to all the internal kernel states available to it. For example, the <code>cBPF</code> machine which uses the network packet data. But this power can be extended as <code>eBPF</code>, which can be used in many other varied applications. As someone <a href="https://www.brendangregg.com/bpf-performance-tools-book.html" target="_blank" rel="noopener">said</a> <strong>In some way, eBPF does to the kernel what Javascript does to the websites: it allows all sorts of new application to be created.</strong>  In the future, I plan to examine eBPF in depth. </p>
<img src="/images/bpf-run-instructions.png" title="BPF Run Instructions" width="600px" height="400px">

<h3 id="Process-the-packet"><a href="#Process-the-packet" class="headerlink" title="Process the packet"></a>Process the packet</h3><p>We examined the <code>BPF</code> filtering theory on the kernel level a lot in the above section. But for our tiny sniffer, the last step we need to do is process the network packet. </p>
<ul>
<li><p>First, the <code>recvfrom</code> system call reads the packet from the socket. And we put the system call in a <code>while</code> loop to keep reading the incoming packets. </p>
</li>
<li><p>Then, we print the source and destination <code>MAC</code> address in the packet(the packet we got is a raw Ethernet frame in Layer 2, right?). And if what this Ethernet frame contains is an <code>IP4</code> packet, then we print out the source and destination <code>IP</code> address. To understand more about it, you can study the header format of various network protocols. I will not cover in details here.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-----------\n"</span>);</span><br><span class="line">	n = recvfrom(sock, <span class="built_in">buffer</span>, <span class="number">2048</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d bytes read\n"</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check to see if the packet contains at least</span></span><br><span class="line"><span class="comment">	* complete Ethernet (14), IP (20) and TCP/UDP</span></span><br><span class="line"><span class="comment">	* (8) headers.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">42</span>) &#123;</span><br><span class="line">		perror(<span class="string">"recvfrom():"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Incomplete packet (errno is %d)\n"</span>, errno);</span><br><span class="line">		<span class="built_in">close</span>(sock);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ethhead = <span class="built_in">buffer</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Source MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n"</span>,</span><br><span class="line">		ethhead[<span class="number">0</span>], ethhead[<span class="number">1</span>], ethhead[<span class="number">2</span>], ethhead[<span class="number">3</span>], ethhead[<span class="number">4</span>], ethhead[<span class="number">5</span>]</span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Destination MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n"</span>,</span><br><span class="line">		ethhead[<span class="number">6</span>], ethhead[<span class="number">7</span>], ethhead[<span class="number">8</span>], ethhead[<span class="number">9</span>], ethhead[<span class="number">10</span>], ethhead[<span class="number">11</span>]</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	iphead = <span class="built_in">buffer</span> + <span class="number">14</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*iphead==<span class="number">0x45</span>) &#123; <span class="comment">/* Double check for IPv4</span></span><br><span class="line"><span class="comment">						* and no options present */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Source host %d.%d.%d.%d\n"</span>,</span><br><span class="line">				iphead[<span class="number">12</span>],iphead[<span class="number">13</span>],</span><br><span class="line">				iphead[<span class="number">14</span>],iphead[<span class="number">15</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Dest host %d.%d.%d.%d\n"</span>,</span><br><span class="line">				iphead[<span class="number">16</span>],iphead[<span class="number">17</span>],</span><br><span class="line">				iphead[<span class="number">18</span>],iphead[<span class="number">19</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Source,Dest ports %d,%d\n"</span>,</span><br><span class="line">				(iphead[<span class="number">20</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">21</span>],</span><br><span class="line">				(iphead[<span class="number">22</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">23</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Layer-4 protocol %s\n"</span>, transport_protocol(iphead[<span class="number">9</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find the complete source code of the sniffer in this Github <a href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c" target="_blank" rel="noopener">repo</a>.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to add filters to our sniffer. First, we analyze why the filter should be running inside kernel space instead of the application space. Then, this article examines the <code>BPF</code> machine design and implementation in detail based on the paper. We reviewed the kernel source code to understand how to implement the <code>BPF</code> virtual machine. As I mentioned above, the original <code>BPF</code>(<code>cBPF</code>) was extended to <code>eBPF</code> now. But the understanding of the BPF virtual machine is very helpful to <code>eBPF</code> as well.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" data-id="cl458i8bw001394mmeaix0h53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" class="article-date">
  <time datetime="2022-02-22T02:21:14.000Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>When we refer to network packet sniffer, some famous and popular tools come to your mind, like <code>tcpdump</code>. I have shown you how to capture network packets with such tools in my previous articles. But have you ever thought about writing a packet sniffer from scratch without dependencies on any third-party libraries? We need to dig deep into the operating system and find the weapons needed to build this tool. Sounds complex, right? In this article, let us do it. After reading this article, you can find that it is not as difficult as you think. </p>
<p>Note that different operating system kernels have different internal network implementations. This article will focus on the <code>Linux</code> platform. </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Firstly, we need to review how <code>tcpdump</code> is implemented. According to the official <a href="https://www.tcpdump.org/" target="_blank" rel="noopener">document</a>, <code>tcpdump</code> is built on the library <code>libpcap</code>, which is developed based on the remarkable research result from Berkeley, in details you can refer to <a href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" target="_blank" rel="noopener">this paper</a>.</p>
<p>As you know, different operating systems have different internal implementations of network stacks. <code>libpcap</code> covers all of these differences and provides the system-independent interface for user-level packet capture. I want to focus on the Linux platform, so how does <code>libpcap</code> work on the Linux system? According to some <a href="https://stackoverflow.com/questions/21200009/capturing-performance-with-pcap-vs-raw-socket" target="_blank" rel="noopener">documents</a>, it turns out that libpcap uses the <code>PF_PACKET</code> socket to capture packets on a network interface.</p>
<p>So the next question is: what the <code>PF_PACKET</code> socket is? </p>
<h3 id="PF-PACKET-socket"><a href="#PF-PACKET-socket" class="headerlink" title="PF_PACKET socket"></a>PF_PACKET socket</h3><p>In my previous <a href="https://organicprogrammer.com/2021/07/31/how-to-implement-simple-http-server-golang/" target="_blank" rel="noopener">article</a>, we mentioned that the socket interface is TCP/IP’s window on the world. In most modern systems incorporating TCP/IP, the socket interface is the only way applications can use the TCP/IP suite of protocols. </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>It is correct. This time, let’s dig deeper about <code>socket</code> by examining the system call executed when we create a new socket: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>When you want to create a socket with the above system call, you have to specify which domain (or protocol family) you want to use with that socket as the first argument. The most commonly used family is <code>PF_INET</code>, which is for communications based on IPv4 protocols (when you create a TCP server, you use this family). Moreover, you have to specify a type for your socket as the second argument. And the possible values depend on the family you specified. For example, when dealing with the <code>PF_INET</code> family, the values for type include <code>SOCK_STREAM</code>(for TCP) and <code>SOCK_DGRAM</code>(for UDP). For other detailed information about the socket system call, you can refer to the socket(3) man page. </p>
<p>You can find one potential value for the <code>domain</code> argument as follows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AF_PACKET    Low-level packet interface</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: <code>AF_PACKET</code> and <code>PF_PACKET</code> are same. It is called <code>PF_PACKET</code> in history and then renamed  <code>AF_PACKET</code> later. <code>PF</code> means protocol families, and <code>AF</code> means address families. In this article, I use <code>PF_PACKET</code>. </p>
<p>Different from <code>PF_INET</code> socket, which can give you TCP segment. By <code>PF_PACKET</code> socket, you can get the raw <code>Ethernet</code> frame which bypasses the usual upper layer handling of TCP/IP stack. It might sound a little bit crazy. But, that is, any packet received will be directly passed to the application. </p>
<p>For a better understanding of <code>PF_PACKET</code> socket, let us go deeper and roughly examine the path of a received packet from the network interface to the application level. </p>
<p>(As shown in the image above) When the network interface card(NIC) receives a packet, it is handled by the driver. The driver maintains a structure called <code>ring buffer</code> internally. And write the packet to kernel memory (the memory is pre-allocated with ring buffer)  with direct memory access(DMA). The packet is placed inside a structure called <strong><code>sk_buff</code></strong>(one of the most important structures related to kernel network subsystem).   </p>
<p>After entering the kernel space, the packet goes through protocol stack handling layer by layer, such as <code>IP processing</code> and <code>TCP/UDP processing</code>. And the packet goes into applications via the socket interface. You already understand this familiar path very well.</p>
<p>But for the <code>PF_PACKET</code> socket, the packet in <code>sk_buff</code> is cloned, then it skips the protocol stacks and directly goes to the application. The kernel needs the clone operation, because one copy is consumed by the <code>PF_PACKET</code> socket, and the other one goes through the usual protocol stacks.</p>
<p>In future articles, I’ll demonstrate more about Linux kernel network internals.</p>
<p>Next step, let us see how to create a <code>PF_PACKET</code> socket at the code level. For brevity, I omit some code and only show the essential part. You can refer to this Github <a href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c" target="_blank" rel="noopener">repo</a> in detail.  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"socket"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please ensure to include the system header files: <code>&lt;sys/socket.h&gt; &lt;sys/types.h&gt;</code>. </p>
<h3 id="Bind-to-one-network-interface"><a href="#Bind-to-one-network-interface" class="headerlink" title="Bind to one network interface"></a>Bind to one network interface</h3><p>Without the additional settings, the sniffer captures all the packets received on all the network devices. Next step, let us try to bind the sniffer to a specific network device. </p>
<p>Firstly, you can use <code>ifconfig</code> command to list all the available <code>network interfaces</code> on your machines. The network interface is a software interface to the networking hardware. </p>
<p>For example, the following image shows information of network interface <code>eth0</code>: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.230.49  netmask 255.255.240.0  broadcast 192.168.239.255</span><br><span class="line">        inet6 fe80::215:5dff:fefb:e31f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:fb:e3:1f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 260  bytes 87732 (87.7 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 178  bytes 29393 (29.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>Let’s bind the sniffer to <code>eth0</code> as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind to eth0 interface only</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *opt;</span><br><span class="line">opt = <span class="string">"eth0"</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, opt, <span class="built_in">strlen</span>(opt) + <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"setsockopt bind device"</span>);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We do it by calling the <code>setsockopt</code> system call. I leave the detailed usage of it to you. </p>
<p>Now the sniffer only captures network packets received on the specified network card. </p>
<h3 id="Non-promiscuous-and-promiscuous-mode"><a href="#Non-promiscuous-and-promiscuous-mode" class="headerlink" title="Non-promiscuous and promiscuous mode"></a>Non-promiscuous and promiscuous mode</h3><p>By default, each network card minds its own business and reads only the frames directed to it. It means that the network card discards all the packets that do not contain its own MAC address, which is called <code>non-promiscuous</code> mode. </p>
<p>Next, let us make the sniffer can work in <code>promiscuous</code> mode. In this way, it retrieves all the data packets. Even the ones that are not addressed to its host. </p>
<p>To set a network interface to promiscuous mode, all we have to do is issue the <code>ioctl()</code> system call to an open socket on that interface.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the network card in promiscuos mode*/</span></span><br><span class="line"><span class="comment">// An ioctl() request has encoded in it whether the argument is an in parameter or out parameter</span></span><br><span class="line"><span class="comment">// SIOCGIFFLAGS	0x8913		/* get flags			*/</span></span><br><span class="line"><span class="comment">// SIOCSIFFLAGS	0x8914		/* set flags			*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ethreq</span>;</span></span><br><span class="line"><span class="built_in">strncpy</span>(ethreq.ifr_name, <span class="string">"eth0"</span>, IF_NAMESIZE);</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCGIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"ioctl"</span>);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ethreq.ifr_flags |= IFF_PROMISC;</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCSIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"ioctl"</span>);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ioctl</code> stands for <strong>I/O control</strong>, which manipulates the underlying device parameters of specific files. <code>ioctl</code> takes three arguments: </p>
<ul>
<li>The first argument must be an open file descriptor. We use the socket file descriptor bound to the network interface in our case.</li>
<li>The second argument is a device-dependent request code. You can see we called <code>ioctl</code> twice. The first call uses request code <em>SIOC<strong>G</strong>IFFLAGS</em> to get flags, and the second call uses request code <em>SIOC<strong>S</strong>IFFLAGS</em> to set flags. Do not be fooled by these two constant values, which are spelled alike.</li>
<li>The third argument is for returning information to the requesting process.  </li>
</ul>
<p>Now the sniffer can retrieve all the data packets received on the network card, no matter to which host the packets are addressed.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>This article examined what <code>PF_PACKET</code> socket is, how it works and why the application can get raw Ethernet packets. Furthermore, we discussed how to bind the sniffer to one specific network interface and how can make the sniffer work in the promiscuous mode. The next article will examine how to implement the packet filter functionality, which is very useful to a network sniffer. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" data-id="cl458i8bv001294mmf8wp92rx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-stack-smashing-detect-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/07/stack-smashing-detect-in-c/" class="article-date">
  <time datetime="2022-02-07T05:12:08.000Z" itemprop="datePublished">2022-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/07/stack-smashing-detect-in-c/">stack-smashing-detect-in-c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/07/stack-smashing-detect-in-c/" data-id="cl458i8c9002994mm6bdice7i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-arp-spoof" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/28/how-to-implement-arp-spoof/" class="article-date">
  <time datetime="2022-01-28T09:29:48.000Z" itemprop="datePublished">2022-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/28/how-to-implement-arp-spoof/">how-to-implement-arp-spoof</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/01/28/how-to-implement-arp-spoof/" data-id="cl458i8bu000y94mm61gx5qvk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-extern-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/20/extern-in-c/" class="article-date">
  <time datetime="2022-01-20T03:47:18.000Z" itemprop="datePublished">2022-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/20/extern-in-c/">extern-in-c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/01/20/extern-in-c/" data-id="cl458i8bk000d94mm60aq8xbu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-md5-implementation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/12/md5-implementation/" class="article-date">
  <time datetime="2022-01-12T09:33:01.000Z" itemprop="datePublished">2022-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/12/md5-implementation/">md5-implementation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/01/12/md5-implementation/" data-id="cl458i8c5001w94mm00z70q63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-traceroute-works" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/24/how-traceroute-works/" class="article-date">
  <time datetime="2021-12-24T14:08:39.000Z" itemprop="datePublished">2021-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/24/how-traceroute-works/">how-traceroute-works</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/24/how-traceroute-works/" data-id="cl458i8bz001c94mm6k5admk5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http-1-1-client-golang-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/understand-http-1-1-client-golang-part2/" class="article-date">
  <time datetime="2021-12-15T06:01:03.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/understand-http-1-1-client-golang-part2/">How  HTTP1.1 protocol is implemented in Golang net/http package: part two -  write HTTP message to socket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">previous</a> article, I introduced the main workflow of an HTTP request implemented inside Golang <code>net/http</code> package. As the second article of this series, I’ll focus on how to pass the HTTP message to TCP/IP stack, and then it can be transported over the network. </p>
<h3 id="Architecture-diagram"><a href="#Architecture-diagram" class="headerlink" title="Architecture diagram"></a>Architecture diagram</h3><p>When the client application sends an HTTP request, it determines what is next step based on whether there is an available persistent connection in the cached connection pool. If no, then a new TCP connection will be established. If yes, then a persistent connection will be selected. </p>
<p>The details of the connection pool is not in this article’s scope. I’ll discuss it in the next article. For now you can regard it as a block box. </p>
<p>The overall diagram of this article goes as follows, we can review each piece of it in the below sections</p>
<img src="/images/golang-http1-1-flow-write-socket.png" title="write to socket" width="800px" height="600px">

<h3 id="persistConn"><a href="#persistConn" class="headerlink" title="persistConn"></a>persistConn</h3><p>The key structure in this part is <code>persistConn</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> persistConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	alt RoundTripper</span><br><span class="line">	t         *Transport</span><br><span class="line">	cacheKey  connectMethodKey</span><br><span class="line">	conn      net.Conn            <span class="comment">// underlying TCP connection</span></span><br><span class="line">	tlsState  *tls.ConnectionState</span><br><span class="line">	br        *bufio.Reader       </span><br><span class="line">	bw        *bufio.Writer       <span class="comment">// buffer io for writing data</span></span><br><span class="line">	nwrite    <span class="keyword">int64</span>               </span><br><span class="line">	reqch     <span class="keyword">chan</span> requestAndChan </span><br><span class="line">	writech   <span class="keyword">chan</span> writeRequest   <span class="comment">// channel for writing request</span></span><br><span class="line">	closech   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;      </span><br><span class="line">	isProxy   <span class="keyword">bool</span></span><br><span class="line">	sawEOF    <span class="keyword">bool</span>  </span><br><span class="line">	readLimit <span class="keyword">int64</span> </span><br><span class="line">	writeErrCh <span class="keyword">chan</span> error</span><br><span class="line">	writeLoopDone <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">	idleAt    time.Time   </span><br><span class="line">	idleTimer *time.Timer </span><br><span class="line">	mu                   sync.Mutex </span><br><span class="line">	numExpectedResponses <span class="keyword">int</span></span><br><span class="line">	closed               error </span><br><span class="line">	canceledErr          error </span><br><span class="line">	broken               <span class="keyword">bool</span> </span><br><span class="line">	reused               <span class="keyword">bool</span>  </span><br><span class="line">	mutateHeaderFunc <span class="function"><span class="keyword">func</span><span class="params">(Header)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are many fields defined in <code>persistConn</code>, but we can focus on these three: </p>
<ul>
<li><code>conn</code>: type of <code>net.Conn</code> which defines TCP connection in Golang;</li>
<li><code>bw</code>: type of <code>*bufio.Writer</code> which implements <code>buffer io</code> functionality;</li>
<li><code>writech</code>: type of <code>channel</code> which is used to communicate and sync data among different Goroutines in Golang.</li>
</ul>
<p>In next sections, let’s investigate how <code>persistConn</code> is used to write HTTP message to socket. </p>
<h3 id="New-connection"><a href="#New-connection" class="headerlink" title="New connection"></a>New connection</h3><p>First, let’s see how to establish a new TCP connection and bind it to <code>persistConn</code> structure. The job is done inside <strong>dialConn</strong> method of <strong>Transport</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dialConn in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">(ctx context.Context, cm connectMethod)</span> <span class="params">(pconn *persistConn, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// construct a new persistConn</span></span><br><span class="line">	pconn = &amp;persistConn&#123;</span><br><span class="line">		t:             t,</span><br><span class="line">		cacheKey:      cm.key(),</span><br><span class="line">		reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">		writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">		closech:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		writeErrCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">		writeLoopDone: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line">	wrapErr := <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;net.OpError&#123;Op: <span class="string">"proxyconnect"</span>, Net: <span class="string">"tcp"</span>, Err: err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cm.scheme() == <span class="string">"https"</span> &amp;&amp; t.hasCustomTLSDialer() &#123;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		<span class="comment">// dial secure TCP connection, assign to field pconn.conn</span></span><br><span class="line">		pconn.conn, err = t.customDialTLS(ctx, <span class="string">"tcp"</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tc, ok := pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeStart != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeStart()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := tc.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> pconn.conn.Close()</span><br><span class="line">				<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">					trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			cs := tc.ConnectionState()</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeDone(cs, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pconn.tlsState = &amp;cs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// dial TCP connection</span></span><br><span class="line">		conn, err := t.dial(ctx, <span class="string">"tcp"</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// assign to pconn.conn</span></span><br><span class="line">		pconn.conn = conn</span><br><span class="line">		<span class="keyword">if</span> cm.scheme() == <span class="string">"https"</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> firstTLSHost <span class="keyword">string</span></span><br><span class="line">			<span class="keyword">if</span> firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err = pconn.addTLS(firstTLSHost, trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL == <span class="literal">nil</span>:</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL.Scheme == <span class="string">"socks5"</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		d := socksNewDialer(<span class="string">"tcp"</span>, conn.RemoteAddr().String())</span><br><span class="line">		<span class="keyword">if</span> u := cm.proxyURL.User; u != <span class="literal">nil</span> &#123;</span><br><span class="line">			auth := &amp;socksUsernamePassword&#123;</span><br><span class="line">				Username: u.Username(),</span><br><span class="line">			&#125;</span><br><span class="line">			auth.Password, _ = u.Password()</span><br><span class="line">			d.AuthMethods = []socksAuthMethod&#123;</span><br><span class="line">				socksAuthMethodNotRequired,</span><br><span class="line">				socksAuthMethodUsernamePassword,</span><br><span class="line">			&#125;</span><br><span class="line">			d.Authenticate = auth.Authenticate</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := d.DialWithConn(ctx, conn, <span class="string">"tcp"</span>, cm.targetAddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">"http"</span>:</span><br><span class="line">		pconn.isProxy = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">""</span> &#123;</span><br><span class="line">			pconn.mutateHeaderFunc = <span class="function"><span class="keyword">func</span><span class="params">(h Header)</span></span> &#123;</span><br><span class="line">				h.Set(<span class="string">"Proxy-Authorization"</span>, pa)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">"https"</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		hdr := t.ProxyConnectHeader</span><br><span class="line">		<span class="keyword">if</span> hdr == <span class="literal">nil</span> &#123;</span><br><span class="line">			hdr = <span class="built_in">make</span>(Header)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">""</span> &#123;</span><br><span class="line">			hdr = hdr.Clone()</span><br><span class="line">			hdr.Set(<span class="string">"Proxy-Authorization"</span>, pa)</span><br><span class="line">		&#125;</span><br><span class="line">		connectReq := &amp;Request&#123;</span><br><span class="line">			Method: <span class="string">"CONNECT"</span>,</span><br><span class="line">			URL:    &amp;url.URL&#123;Opaque: cm.targetAddr&#125;,</span><br><span class="line">			Host:   cm.targetAddr,</span><br><span class="line">			Header: hdr,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		connectCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> ctx.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">			newCtx, cancel := context.WithTimeout(ctx, <span class="number">1</span>*time.Minute)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			connectCtx = newCtx</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		didReadResponse := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) </span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			resp *Response</span><br><span class="line">			err  error </span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">close</span>(didReadResponse)</span><br><span class="line">			err = connectReq.Write(conn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			br := bufio.NewReader(conn)</span><br><span class="line">			resp, err = ReadResponse(br, connectReq)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-connectCtx.Done():</span><br><span class="line">			conn.Close()</span><br><span class="line">			&lt;-didReadResponse</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, connectCtx.Err()</span><br><span class="line">		<span class="keyword">case</span> &lt;-didReadResponse:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">			f := strings.SplitN(resp.Status, <span class="string">" "</span>, <span class="number">2</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f) &lt; <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"unknown status code"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(f[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &amp;&amp; cm.targetScheme == <span class="string">"https"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := pconn.addTLS(cm.tlsHost(), trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s := pconn.tlsState; s != <span class="literal">nil</span> &amp;&amp; s.NegotiatedProtocolIsMutual &amp;&amp; s.NegotiatedProtocol != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> next, ok := t.TLSNextProto[s.NegotiatedProtocol]; ok &#123;</span><br><span class="line">			alt := next(cm.targetAddr, pconn.conn.(*tls.Conn))</span><br><span class="line">			<span class="keyword">if</span> e, ok := alt.(http2erringRoundTripper); ok &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, e.err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> &amp;persistConn&#123;t: t, cacheKey: pconn.cacheKey, alt: alt&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())</span><br><span class="line">	<span class="comment">// buffer io wrapper for writing request</span></span><br><span class="line">	pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br><span class="line">	<span class="comment">// read loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">	<span class="comment">// write loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">	<span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At <strong>line 4</strong>, it creates a new <code>persistConn</code> object, which is also the return value for this method. </p>
<p>At <strong>line 22</strong> and <strong>line 46</strong>, it calls <code>dial</code> method to establish a new TCP connection (note line 22 handles <code>TLS</code> case). In Golang a TCP connection is represented as <code>net.Conn</code> type. And then the underlying TCP connection is bound to the <code>conn</code> field of <code>persistConn</code>. </p>
<p>Now that we have the TCP connection, how can we use it? We’ll skip the many lines of code and go to the end to this function. </p>
<p>At <strong>line 166</strong>,  it creates <code>bufio.Writer</code> based on <code>persistConn</code>. <code>Buffer IO</code> is an interesting topic, in detail you can refer to my previous <a href="https://baoqger.github.io/2021/04/04/golang-bytes-buffer/">article</a>. In one word, it can optimize the performance by reducing the number of system calls. For example in the current case, it can avoid too many <code>socket</code> system calls. </p>
<p>At <strong>line 171</strong>, it creates a Goroutine and execute <code>writeLoop</code> method. Let’s take a look at it. </p>
<h3 id="writeLoop"><a href="#writeLoop" class="headerlink" title="writeLoop"></a>writeLoop</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writeLoop method in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">writeLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pc.writeLoopDone)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// receive request from writech channel</span></span><br><span class="line">		<span class="keyword">case</span> wr := &lt;-pc.writech:</span><br><span class="line">			startBytesWritten := pc.nwrite</span><br><span class="line">			<span class="comment">// call write method</span></span><br><span class="line">			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line">			<span class="keyword">if</span> bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">				err = bre.error</span><br><span class="line">				wr.req.setError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				err = pc.bw.Flush()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				wr.req.Request.closeBody()</span><br><span class="line">				<span class="keyword">if</span> pc.nwrite == startBytesWritten &#123;</span><br><span class="line">					err = nothingWrittenError&#123;err&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pc.writeErrCh &lt;- err <span class="comment">// to the body reader, which might recycle us</span></span><br><span class="line">			wr.ch &lt;- err         <span class="comment">// to the roundTrip function</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As the function name <strong>writeLoop</strong> implies, there is a <strong>for</strong> loop, and it keeps receiving data from the <strong>writech</strong> channel. Everytime it receive a request from the channel, call the <code>write</code> method at <strong>line 10</strong>. Then let’s review what message it actually writes:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method in request.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">write</span><span class="params">(w io.Writer, usingProxy <span class="keyword">bool</span>, extraHeaders Header, waitForContinue <span class="keyword">func</span>()</span> <span class="title">bool</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	trace := httptrace.ContextClientTrace(r.Context())</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			trace.WroteRequest(httptrace.WroteRequestInfo&#123;</span><br><span class="line">				Err: err,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	host := cleanHost(r.Host)</span><br><span class="line">	<span class="keyword">if</span> host == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errMissingHost</span><br><span class="line">		&#125;</span><br><span class="line">		host = cleanHost(r.URL.Host)</span><br><span class="line">	&#125;</span><br><span class="line">	host = removeZone(host)</span><br><span class="line">	ruri := r.URL.RequestURI()</span><br><span class="line">	<span class="keyword">if</span> usingProxy &amp;&amp; r.URL.Scheme != <span class="string">""</span> &amp;&amp; r.URL.Opaque == <span class="string">""</span> &#123;</span><br><span class="line">		ruri = r.URL.Scheme + <span class="string">"://"</span> + host + ruri</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> &amp;&amp; r.URL.Path == <span class="string">""</span> &#123;</span><br><span class="line">		ruri = host</span><br><span class="line">		<span class="keyword">if</span> r.URL.Opaque != <span class="string">""</span> &#123;</span><br><span class="line">			ruri = r.URL.Opaque</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> stringContainsCTLByte(ruri) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"net/http: can't write control character in Request.URL"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> bw *bufio.Writer</span><br><span class="line">	<span class="keyword">if</span> _, ok := w.(io.ByteWriter); !ok &#123;</span><br><span class="line">		bw = bufio.NewWriter(w)</span><br><span class="line">		w = bw</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request line</span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">"%s %s HTTP/1.1\r\n"</span>, valueOrDefault(r.Method, <span class="string">"GET"</span>), ruri)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request Host header </span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">"Host: %s\r\n"</span>, host)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaderField(<span class="string">"Host"</span>, []<span class="keyword">string</span>&#123;host&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	userAgent := defaultUserAgent</span><br><span class="line">	<span class="keyword">if</span> r.Header.has(<span class="string">"User-Agent"</span>) &#123;</span><br><span class="line">		userAgent = r.Header.Get(<span class="string">"User-Agent"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> userAgent != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// write HTTP request User-Agent header </span></span><br><span class="line">		_, err = fmt.Fprintf(w, <span class="string">"User-Agent: %s\r\n"</span>, userAgent)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.WroteHeaderField(<span class="string">"User-Agent"</span>, []<span class="keyword">string</span>&#123;userAgent&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tw, err := newTransferWriter(r)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeHeader(w, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = r.Header.writeSubset(w, reqWriteExcludeHeader, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> extraHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = extraHeaders.write(w, trace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write blank line after HTTP request headers</span></span><br><span class="line">	_, err = io.WriteString(w, <span class="string">"\r\n"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaders()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> waitForContinue != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &#123;</span><br><span class="line">			err = bw.Flush()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.Wait100Continue != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.Wait100Continue()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !waitForContinue() &#123;</span><br><span class="line">			r.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &amp;&amp; tw.FlushHeaders &#123;</span><br><span class="line">		<span class="keyword">if</span> err := bw.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeBody(w)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tw.bodyReadError == err &#123;</span><br><span class="line">			err = requestBodyReadError&#123;err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bw.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We will not go through every line of code in above function. But I bet you find many familiar information, for example, at line 37 it write <strong>HTTP request line</strong> as the first information in the HTTP message. Then it continues writing <strong>HTTP headers</strong> such as <strong>Host</strong> and <strong>User-Agent</strong>(at line 42 and line 56), and finally add the <strong>blank line</strong> after the headers (at line 86). An HTTP request message is built up bit by bit. All right.  </p>
<h3 id="Bufio-and-underlying-writer"><a href="#Bufio-and-underlying-writer" class="headerlink" title="Bufio and underlying writer"></a>Bufio and underlying writer</h3><p>Next piece of this puzzle is how it’s related to the underlying TCP connection. </p>
<p>Note this method call in the write loop: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method call in writeLoop</span></span><br><span class="line">wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br></pre></td></tr></table></figure>
<p>The first parameter is <code>pc.bw</code> mentioned above. It’s time to take a deep look at it. <code>pc.bw</code>, a <strong>bufio.Write</strong>, is created by calling the following method from <code>bufio</code> package: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pconn.bw is created by this method call</span></span><br><span class="line">pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br></pre></td></tr></table></figure>

<p>Note that this <strong>bufio.Writer</strong> isn’t based on <code>persistConn</code> directly, instead a simple wrapper over <code>persistConn</code> called <code>persistConnWriter</code> is used here. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="keyword">type</span> persistConnWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	pc *persistConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we need to understand is <strong>bufio.Writer wraps an io.Writer object, creating another Writer that also implements the interface but provides buffering functionality.</strong> And <strong>bufio.Writer’s Flush method writes the buffered data to the underlying io.Writer.</strong></p>
<p>In this case, the underlying io.Writer is <code>persistConnWriter</code>. Its <code>Write</code> method will be used to write the buffered data: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w persistConnWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	n, err = w.pc.conn.Write(p) <span class="comment">// TCP socket Write system call is called here!</span></span><br><span class="line">	w.pc.nwrite += <span class="keyword">int64</span>(n)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internally it delegates the task to the TCP connection bond to <code>pconn.conn</code>! </p>
<h3 id="roundTrip"><a href="#roundTrip" class="headerlink" title="roundTrip"></a>roundTrip</h3><p>As we mentioned above, <code>writeLoop</code> keeps receiving reqeusts from <code>writech</code> channel. So on the other hand, it means the requests should be sent to this channel somewhere. This is implemented inside the <code>roundTrip</code> method: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundTrip in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">roundTrip</span><span class="params">(req *transportRequest)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line">	testHookEnterRoundTrip()</span><br><span class="line">	<span class="keyword">if</span> !pc.t.replaceReqCanceler(req.cancelKey, pc.cancelRequest) &#123;</span><br><span class="line">		pc.t.putOrCloseIdleConn(pc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceled</span><br><span class="line">	&#125;</span><br><span class="line">	pc.mu.Lock()</span><br><span class="line">	pc.numExpectedResponses++</span><br><span class="line">	headerFn := pc.mutateHeaderFunc</span><br><span class="line">	pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> headerFn != <span class="literal">nil</span> &#123;</span><br><span class="line">		headerFn(req.extraHeaders())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestedGzip := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> !pc.t.DisableCompression &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">"Accept-Encoding"</span>) == <span class="string">""</span> &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">"Range"</span>) == <span class="string">""</span> &amp;&amp;</span><br><span class="line">		req.Method != <span class="string">"HEAD"</span> &#123;</span><br><span class="line">		requestedGzip = <span class="literal">true</span></span><br><span class="line">		req.extraHeaders().Set(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> continueCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.Body != <span class="literal">nil</span> &amp;&amp; req.expectsContinue() &#123;</span><br><span class="line">		continueCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pc.t.DisableKeepAlives &amp;&amp; !req.wantsClose() &#123;</span><br><span class="line">		req.extraHeaders().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(gone)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			pc.t.setReqCanceler(req.cancelKey, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> debugRoundTrip = <span class="literal">false</span></span><br><span class="line">	startBytesWritten := pc.nwrite</span><br><span class="line">	writeErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// send requet to pc.writech channel </span></span><br><span class="line">	pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line"></span><br><span class="line">	resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">	pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">		req:        req.Request,</span><br><span class="line">		cancelKey:  req.cancelKey,</span><br><span class="line">		ch:         resc,</span><br><span class="line">		addedGzip:  requestedGzip,</span><br><span class="line">		continueCh: continueCh,</span><br><span class="line">		callerGone: gone,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> respHeaderTimer &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	cancelChan := req.Request.Cancel</span><br><span class="line">	ctxDoneChan := req.Context().Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		testHookWaitResLoop()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-writeErrCh:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">"writeErrCh resv: %T/%#v"</span>, err, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(fmt.Errorf(<span class="string">"write error: %v"</span>, err))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> d := pc.t.ResponseHeaderTimeout; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">					req.logf(<span class="string">"starting timer for %v"</span>, d)</span><br><span class="line">				&#125;</span><br><span class="line">				timer := time.NewTimer(d)</span><br><span class="line">				<span class="keyword">defer</span> timer.Stop() </span><br><span class="line">				respHeaderTimer = timer.C</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">"closech recv: %T %#v"</span>, pc.closed, pc.closed)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, pc.closed)</span><br><span class="line">		<span class="keyword">case</span> &lt;-respHeaderTimer:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">"timeout waiting for response headers."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pc.<span class="built_in">close</span>(errTimeout)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line">		<span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">			<span class="keyword">if</span> (re.res == <span class="literal">nil</span>) == (re.err == <span class="literal">nil</span>) &#123;</span><br><span class="line">				<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"internal error: exactly one of res or err should be set; nil=%v"</span>, re.res == <span class="literal">nil</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">"resc recv: %p, %T/%#v"</span>, re.res, re.err, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> re.err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-cancelChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, errRequestCanceled)</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ctxDoneChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, req.Context().Err())</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">			ctxDoneChan = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At line 48, you can find it clearly. In <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">last article</a>, you can see that <code>pconn.roundTrip</code> is the end of the HTTP request workflow. Now we had put all parts together. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article (as the second part of this series), we reviewed how the HTTP request message is written to TCP/IP stack via socket system call.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/15/understand-http-1-1-client-golang-part2/" data-id="cl458i8ca002d94mmc4zrfedu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 20px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two- hello world module</a>
          </li>
        
          <li>
            <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
          </li>
        
          <li>
            <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
          </li>
        
          <li>
            <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
          </li>
        
          <li>
            <a href="/2022/02/07/stack-smashing-detect-in-c/">stack-smashing-detect-in-c</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>