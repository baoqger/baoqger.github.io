<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/page/2/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
          <a class="main-nav-link" href="/book-reviews">Book Review</a>
        
          <a class="main-nav-link" href="/solopreneur">Solopreneur</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-userland-memory-allocation-one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/05/userland-memory-allocation-one/" class="article-date">
  <time datetime="2022-08-05T12:31:11.000Z" itemprop="datePublished">2022-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/05/userland-memory-allocation-one/">Understand userland heap memory allocation: part one - overview</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In my eyes, compared with developing applications with high-level programming languages, one of the biggest differences for system programming with low-level languages like C and C++, is you have to manage the memory by yourself. So you call APIs like <code>malloc</code>, and <code>free</code> to allocate the memory based on your need and release the memory when the resource is no longer needed. It is not only one of the most frequent causes of <a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2021/11/01/debug-memory-errors-valgrind-and-gdb">bugs</a> in system programming; but also can lead to many <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_safety">security issues</a>. </p>
<p>It’s not difficult to understand the correct usage of APIs like <code>malloc</code>, and <code>free</code>. But have you ever wondered how they work, for example: </p>
<ul>
<li>When you call <code>malloc</code>, does it trigger system calls and delegate the task to the kernel or there are some other mechanisms? </li>
<li>When you call <code>malloc(10)</code> and try to allocate 10 bytes of heap memory, how many bytes of memory do you get? 10 bytes or more?</li>
<li>When the memory is allocated, where exactly the heap objects are located?</li>
<li>When you call <code>free</code>, is the memory directly returned to the kernel? </li>
</ul>
<p>This article will try to answer these questions. </p>
<p>Note that memory is a super complex topic, so I can’t cover everything about it in one article (In fact, what is covered in this article is very limited). This article will focus on <code>userland memory(heap) allocation</code>. </p>
<h3 id="Process-memory-management-overview"><a href="#Process-memory-management-overview" class="headerlink" title="Process memory management overview"></a>Process memory management overview</h3><h4 id="Process-virtual-memory"><a href="#Process-virtual-memory" class="headerlink" title="Process virtual memory"></a>Process virtual memory</h4><p>Every time we start a program, a memory area for that program is reserved, and that’s <code>process virtual memory</code> as shown in the following image: </p>
<img src="/images/process-memory-address.png" title="process virtual memory" width="400px" height="300px">

<p>You can note that each process has one <strong>invisible</strong> memory segment containing kernel codes and data structures. This invisible memory segment is important; since it’s directly related to <code>virtual memory</code>, which is employed by the kernel for memory management. Before we dive into the other different segments, let’s understand virtual memory first. </p>
<h4 id="Virtual-memory-technique"><a href="#Virtual-memory-technique" class="headerlink" title="Virtual memory technique"></a>Virtual memory technique</h4><img src="/images/virtual-memory-technique.png" title="virtual memory technique" width="600px" height="400px">

<p>Why do we need virtual memory? Virtual memory is a service provided by the kernel in the form of abstraction. Without virtual memory, applications would need to manage their physical memory space, coordinating with every other process running on the computer. Virtual memory leaves that management to the kernel by creating the maps that allow translation between virtual and physical memory.  The kernel creates an illusion that each process occupies the entire physical memory space. We can also realize <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_isolation">process isolation</a> based on virtual memory to enhance security. </p>
<p>Virtual memory is out of this article’s scope, if you’re interested, please take a look at the core techniques: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory_paging">paging</a> and <a target="_blank" rel="noopener" href="https://linuxhint.com/linux-memory-management-swap-space/">swapping</a>. </p>
<h4 id="Static-vs-Dynamic-memory-allocation"><a href="#Static-vs-Dynamic-memory-allocation" class="headerlink" title="Static vs Dynamic memory allocation"></a>Static vs Dynamic memory allocation</h4><p>Next, let’s take a close look at the process memory layout above and understand where they are from. Generally speaking, there are two ways via which memories can be allocated for storing data: <code>static</code> and <code>dynamic</code>. Static memory allocation happens at <code>compile time</code>, while dynamic memory allocation occurs at <code>runtime</code>. </p>
<p>When a program started, the executable file(on the Linux system, it’s called an <code>ELF</code> file) will be loaded into the memory as a <code>Process Image</code>. This <code>ELF</code> file contains the following segments:</p>
<ul>
<li>.TEXT: contains the executable part of the program with all the machine codes.</li>
<li>.DATA: contains <code>initialized</code> static and global variables. </li>
<li>.BSS: is short for <code>block started by symbol</code> contains <code>uninitialized</code> static and global variables. </li>
</ul>
<p>The <code>ELF</code> file will be loaded by the kernel and create a process image. And these static data will be mapped into the corresponding segments of the virtual memory. The <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/article/1060">ELF loader</a> is also an interesting topic, I will write another article about it in the future. Please keep watching my blog!</p>
<p>The <code>memory-mapped region</code> segment is used for storing the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2019/08/25/how-to-write-linux-c-program-with-external-library/">shared libraries</a>. </p>
<p>Finally, <code>stack</code> and <code>heap</code> segments are produced at runtime dynamically, which are used to store and operate on temporary variables that are used during the execution of the program. Previously, I once wrote an article about the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2020/08/19/stack-frame/">stack</a>, please refer to it if you want to know the details.</p>
<p>The only remaining segment we didn’t mention yet is the <code>heap</code>, which is this article’s focus! </p>
<p>You can check the memory layout of one process by examining this file <code>/proc/&#123;pid&#125;/maps</code> as below: </p>
<img src="/images/maps-capture.png" title="proc/pid/maps" width="800px" height="600px">

<p>Note that the above investigation doesn’t consider multiple threads. The memory layout of the process with multi-threads will be more complex, please refer to other online <a target="_blank" rel="noopener" href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">documents</a>.</p>
<p>In this section, we had a rough overview of memory management from top to bottom. Hope you can see the big picture and know where we are. Next, let’s dig into the <code>heap</code> segment and see how it works. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/08/05/userland-memory-allocation-one/" data-id="clvv1t4iv0030c8mmh4i37y4x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CPacketSniffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/22/CPacketSniffer/" class="article-date">
  <time datetime="2022-07-22T02:19:48.000Z" itemprop="datePublished">2022-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/22/CPacketSniffer/">cPacketSniffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this post, I want to introduce my new project: <a target="_blank" rel="noopener" href="https://github.com/baoqger/cPacketSniffer"><code>cPacketSniffer</code></a>. I worked on it for the past two months. Finally, I worked it out and feel very proud of putting it here!</p>
<h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Simply speaking, I want to sharpen my techniques in <code>network programming</code> and <code>Linux system programming</code>. Both of these two topics can lead you to the bottom of computers or software. Feynman said <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/There%27s_Plenty_of_Room_at_the_Bottom">“There is plenty of room at the bottom”</a>, I think this physics law can apply to software as well. </p>
<h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><p>It’s very lucky for me to come across this site <a target="_blank" rel="noopener" href="http://tcpip.marcolavoie.ca/index.html">“Network programming in Linux”</a>, which developed a network packet capturing tool with <code>C++</code>. After confirming that the documents and source code on this site is completed and clear, I decided to refactor it with C language. That’s the starting point for my project <code>cPacketSniffer</code>.      </p>
<h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>As a network packets sniffer, <code>cPacketSniffer</code> provides the following features: </p>
<img src="/images/cPacketSniffer.png" title="cPacketSniffer modules" width="600px" height="400px">

<ul>
<li>Integrate with <code>libpcap</code> to support: filtering captured packets, capturing packets offline, capturing packets on specific devices and capturing packets in promiscuous mode.</li>
<li>Analyze network packets at low layers of TCP/IP stack, including <code>Ethernet</code>, <code>ARP</code>, <code>ICMP</code>, <code>IP(IPv4)</code>, <code>TCP</code>, <code>UDP</code>, etc. Also one protocol in the application layer: <code>TFTP</code>. </li>
<li>Detect network security attacks:<ul>
<li>ARP spoofing detection.</li>
<li>Ping flood detection.</li>
</ul>
</li>
<li>Analyze and track network traffics:<ul>
<li>TCP session tracking and traffic analysis.</li>
<li>TFTP session tracking and traffic analysis.</li>
</ul>
</li>
</ul>
<p>The following images demonstrate some typical usages of <code>cPacketSniffer</code>:  </p>
<p><strong>Packet Analysis</strong>:</p>
<img src="/images/packet-analysis.png" title="packet analysis" width="600px" height="400px">

<p><strong>ARP Spoofing Detection</strong>:</p>
<img src="/images/arpspoof.png" title="arp spoofing detection" width="600px" height="400px">

<p><strong>PING Flood Detection</strong>:</p>
<img src="/images/pingflooddetection.png" title="ping flood detection" width="600px" height="400px">

<p><strong>TCP Session Tracking</strong>:</p>
<img src="/images/tcpsessiontrack.png" title="tcp session track" width="600px" height="400px">

<p>Besides the above network programming-related functionalities, it also covers the following points: </p>
<ul>
<li>Develop a generic data structure in C.</li>
<li>Error handling in C. </li>
<li>Data encapsulation (object-oriented style programming) in C.</li>
<li>Manual memory management in C.</li>
<li>etc.</li>
</ul>
<p>This article will not cover these points in detail, I will write articles on these topics separately in the future. Please keep watching my blog!</p>
<h3 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h3><p>Now <code>cPacketSniffer</code> can work as a network packet sniffer based on the design. Moreover, it can also serve as a testbed to try experimental features. Next step I plan to try the following ideas:</p>
<ul>
<li>Implement the network intrusion detection function. </li>
<li>Improve the performance with advanced data structures, like binary search trees. </li>
<li>Memory and cache performance tuning. </li>
<li>Automatic memory management by Garbage Collection.</li>
<li>Integrate <code>ncurses</code> for Text-based user interface.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/07/22/CPacketSniffer/" data-id="clvv1t4hx0003c8mm4xni59if" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/" class="article-date">
  <time datetime="2022-06-08T06:59:19.000Z" itemprop="datePublished">2022-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/">Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/">article</a>, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a <code>Netfilter</code> module as our mini-firewall.  </p>
<h3 id="Netfilter-architecture"><a href="#Netfilter-architecture" class="headerlink" title="Netfilter architecture."></a>Netfilter architecture.</h3><h5 id="Basics-of-Netfilter-hooks"><a href="#Basics-of-Netfilter-hooks" class="headerlink" title="Basics of Netfilter hooks"></a>Basics of Netfilter hooks</h5><p><strong>The <code>Netfilter</code> framework provides a bunch of <code>hooks</code> in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well</strong>. And Netfilter allows you to write modules and register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? </p>
<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

<p>Currently, Netfilter provides the following 5 hooks for <code>IPv4</code>:</p>
<ul>
<li><em>NF_INET_PRE_ROUTING</em>: is triggered right after the packet has been received on a network card. This hook is triggered before the <code>routing decision</code> was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. </li>
<li><em>NF_INET_LOCAL_IN</em>: is triggered for network packets that are destined for the current host. </li>
<li><em>NF_INET_FORWARD</em>: is triggered for network packets that should be forwarded. </li>
<li><em>NF_INET_POST_ROUTING</em>: is triggered for network packets that have been routed and before being sent out to the network card. </li>
<li><em>NF_INET_LOCAL_OUT</em>: is triggered for network packets generated by the processes on the current host.</li>
</ul>
<p>The hook function you defined in the module can mangle or filter the packets, but it eventually must return a status code to Netfilter. There are several possible values for the code, but for now, you only need to understand two of them: </p>
<ul>
<li><em>NF_ACCEPT</em>: this means the hook function accepts the packet and it can go on the network stack trip. </li>
<li><em>NF_DROP</em>: this means the packet is dropped and no further parts of the network stack will be traversed.</li>
</ul>
<p>Netfilter allows you to register multiple callback functions to the same hook with different priorities. If the first hook function accepts the packet, then the packet will be passed to the next functions with low priority. If the packet is dropped by one callback function, then the next functions(if existing) will not be traversed. </p>
<p>As you see, <code>Netfilter</code> has a big scope and I can’t cover every detail in the articles. So the mini-firewall developed here will work on the hook <code>NF_INET_PRE_ROUTING</code>, which means it works by controlling the inbound network traffic. But the way of registering the hook and handling the packet can be applied to all other hooks. </p>
<p><em>Note</em>: there is another remarkable question: what’s the difference between <code>Netfilter</code> and <code>eBPF</code>? If you don’t know eBPF, please refer to my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">article</a>. Both of them are important network features in the Linux kernel. The important thing is <code>Netfilter</code> and <code>eBPF</code> hooks are located in different layers of the Kernel. As I drew in the above diagram, <code>eBPF</code> is located in a lower layer. </p>
<h5 id="Kernel-code-of-Netfilter-hooks"><a href="#Kernel-code-of-Netfilter-hooks" class="headerlink" title="Kernel code of Netfilter hooks"></a>Kernel code of Netfilter hooks</h5><p>To have a clear understanding of how the <code>Netfilter</code> framework is implemented inside the protocol stack, let’s dig a little bit deeper and take a look at the kernel source code (Don’t worry, only shows several simple functions). Let’s use the hook <code>NF_INET_PRE_ROUTING</code> as an example; since the mini-firewall will be written based on it. </p>
<p>When an IPv4 packet is received, its handler function <code>ip_rcv</code> will be called as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/net/ipv4/ip_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">        skb = ip_rcv_core(skb, net);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">        <span class="comment">// run Netfilter NF_INET_PRE_ROUTING hook&#x27;s callback function</span></span><br><span class="line">        <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, </span><br><span class="line">                       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">                       ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this handler function, you can see the hook is passed to the function <code>NF_HOOK</code>. Based on the name <code>NF_HOOK</code>, you can guess that it is for triggering the Netfilter hooks. Right? Let’s continue to examine how <code>NF_HOOK</code> is implemented as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">                ret = okfn(net, sk, skb); <span class="comment">// in our case: okfn is ip_rcv_finish</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      nf_hook - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *      okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *      value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code omit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>NF_HOOK</code> contains two steps:</p>
<ul>
<li>First, runs the hook’s callback functions by calling the underlying function <code>nf_hook</code>. </li>
<li>Second, invokes the function <code>okfn</code> (passed to <em>NF_HOOK</em> as the argument), if the packet passes through the hook functions and doesn’t drop.</li>
</ul>
<p>For the hook <em>NF_INET_LOCAL_IN</em>, the function <code>ip_rcv_finish</code> will be invoked after the hook functions pass. Its job is to pass the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey! </p>
<p>The other 4 hooks all use the same function <code>NF_HOOK</code> to trigger the callback functions. The following table shows where the hooks are embedded in the kernel, I leave them to the readers. </p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>File</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>NF_INET_PRE_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_rcv()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_IN</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_local_deliver()</td>
</tr>
<tr>
<td>NF_INET_FORWARD</td>
<td>/kernel-src/net/ipv4/ip_forward.c</td>
<td>ip_forward()</td>
</tr>
<tr>
<td>NF_INET_POST_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_build_and_send_pkt()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_OUT</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_output()</td>
</tr>
</tbody></table>
<p>Next, Let’s review the Netfilter’s APIs to create and register the hook function. </p>
<h3 id="Netfilter-API"><a href="#Netfilter-API" class="headerlink" title="Netfilter API"></a>Netfilter API</h3><p>It’s straightforward to create a Netfilter module, which involves three steps: </p>
<ul>
<li>Define the hook function.</li>
<li>Register the hook function in the kernel module initialization process.</li>
<li>Unregister the hook function in the kernel module clean-up process. </li>
</ul>
<p>Let’s go through them quickly one by one. </p>
<h5 id="Define-a-hook-function"><a href="#Define-a-hook-function" class="headerlink" title="Define a hook function"></a>Define a hook function</h5><p>The hook function name can be whatever you want, but it must follow the signature below: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br></pre></td></tr></table></figure>

<p>The hook function can mangle or filter the packet whose data is stored in the <code>sk_buff</code> structure (we can ignore the other two parameters; since we don’t use them in our mini-firewall). As we mentioned above, the callback function must return a Netfilter status code which is an integer. For instance, the <code>accepted</code> and <code>dropped</code> status is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Responses from hook functions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_ACCEPT 1</span></span><br></pre></td></tr></table></figure>
<h5 id="Register-and-unregister-a-hook-function"><a href="#Register-and-unregister-a-hook-function" class="headerlink" title="Register and unregister a hook function"></a>Register and unregister a hook function</h5><p>To register a hook function, we should wrap the defined hook function with related information, such as which hook you want to bind to, the protocol family and the priority of the hook function,  into a structure <code>struct nf_hook_ops</code> and pass it to the function <code>nf_register_net_hook</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn               *hook;    <span class="comment">// callback function</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">dev</span>;</span>     <span class="comment">// network device interface</span></span><br><span class="line">        <span class="type">void</span>                    *priv; </span><br><span class="line">        <span class="type">u_int8_t</span>                pf;       <span class="comment">// protocol</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            hooknum;  <span class="comment">// Netfilter hook enum</span></span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="type">int</span>                     priority; <span class="comment">// priority of callback function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Most of the fields are very straightforward to understand. The one need to emphasize is the field <code>hooknum</code>, which is just the Netfilter hooks discussed above. They are defined as enumerators as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">	NF_INET_PRE_ROUTING,</span><br><span class="line">	NF_INET_LOCAL_IN,</span><br><span class="line">	NF_INET_FORWARD,</span><br><span class="line">	NF_INET_LOCAL_OUT,</span><br><span class="line">	NF_INET_POST_ROUTING,</span><br><span class="line">	NF_INET_NUMHOOKS,</span><br><span class="line">	NF_INET_INGRESS = NF_INET_NUMHOOKS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Next, let’s take a look at the functions to register and unregister hook functions goes as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Function to register/unregister hook points. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter <code>struct net</code> is related to the network namespace, we can ignore it for now and use a default value. </p>
<p>Next, let’s implement our mini-firewall based on these APIs. All right? </p>
<h3 id="Implement-mini-firewall"><a href="#Implement-mini-firewall" class="headerlink" title="Implement mini-firewall"></a>Implement mini-firewall</h3><p>First, we need to clarify the requirements for our mini-firewall. We’ll implement two network traffic control rules in the mini-firewall as follows:</p>
<ul>
<li><em>Network protocol rule</em>: drops the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a> protocol packets.</li>
<li><em>IP address rule</em>: drops the packets from one specific IP address.</li>
</ul>
<p>The completed code implementation is in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">repo</a>.</p>
<h5 id="Drop-ICMP-protocol-packets"><a href="#Drop-ICMP-protocol-packets" class="headerlink" title="Drop ICMP protocol packets"></a>Drop ICMP protocol packets</h5><p><code>ICMP</code> is a network protocol widely used in the real world. The popular diagnostic tools like <code>ping</code> and <code>traceroute</code> run the ICMP protocol. We can filter out the ICMP packets based on the protocol type in the IP headers with the following hook function: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockicmppkt_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span>   <span class="comment">// IP header</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span> <span class="comment">// UDP header</span></span><br><span class="line">	<span class="keyword">if</span>(!skb)</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	iph = ip_hdr(skb); <span class="comment">// retrieve the IP headers from the packet</span></span><br><span class="line">	<span class="keyword">if</span>(iph-&gt;protocol == IPPROTO_UDP) &#123; </span><br><span class="line">		udph = udp_hdr(skb);</span><br><span class="line">		<span class="keyword">if</span>(ntohs(udph-&gt;dest) == <span class="number">53</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept UDP packet</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;Drop ICMP packet \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> NF_DROP;   <span class="comment">// drop TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic in the above hook function is easy to understand. First, we retrieve the IP headers from the network packet. And then according to the <code>protocol</code> type field in the headers, we decided to accept TCP and UDP packets but drop the ICMP packets. The only technique we need to pay attention to is the function <code>ip_hdr</code>, which is the kernel function defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/ip.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">ip_hdr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In source code file /kernel-src/include/linux/skbuff.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>ip_hdr</code> delegates the task to the function <code>skb_network_header</code>. It gets IP headers based on the following two data: </p>
<ul>
<li>head: is the pointer to the packet;</li>
<li>network_header: is the offset between the pointer to the packet and the pointer to the network layer protocol header. In detail, you can refer to this <a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html">document</a>.</li>
</ul>
<p>Next, we can register the above hook function as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">nf_blockicmppkt_ops</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	nf_blockicmppkt_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hook = (nf_hookfn*)nf_blockicmppkt_handler;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;priority = NF_IP_PRI_FIRST; <span class="comment">// set the priority</span></span><br><span class="line">		</span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">nf_minifirewall_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_unregister_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">		kfree(nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(nf_minifirewall_init);</span><br><span class="line">module_exit(nf_minifirewall_exit);</span><br></pre></td></tr></table></figure>

<p>The above logic is self-explaining. I will not spend too much time here. </p>
<p>Next, it’s time to demo how our mini-firewall works. </p>
<h5 id="Demo-time"><a href="#Demo-time" class="headerlink" title="Demo time"></a>Demo time</h5><p>Before we load the mini-firewall module, the <code>ping</code> command can work as expected: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">3</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">4</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time 3005ms</span><br><span class="line">rtt <span class="built_in">min</span>/avg/<span class="built_in">max</span>/mdev = <span class="number">71.857</span>/<span class="number">71.902</span>/<span class="number">71.961</span>/<span class="number">0.193</span> ms</span><br></pre></td></tr></table></figure>

<p>In contrast, after the mini-firewall module is built and loaded (based on the commands we discussed previously): </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">mini_firewall          <span class="number">16384</span>  <span class="number">0</span></span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.105</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">6</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 5097ms</span><br></pre></td></tr></table></figure>

<p>You can see all the packets are lost; because it is dropped by our mini-firewall. We can verify this by running the command <code>dmesg</code>: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">1260.184712</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1261.208637</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1262.232669</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1263.256757</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1264.280733</span>] Drop ICMP packet</span><br></pre></td></tr></table></figure>

<p>But other protocol packets can still run through the firewall. For instance, the command <code>wget 142.250.4.103</code> can return normally as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">302</span> Moved Temporarily</span><br><span class="line">Location: http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f [following]</span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">3248</span> (<span class="number">3.2</span>K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                                           <span class="number">100</span>%[===================================================================================================================&gt;]   <span class="number">3.17</span>K  --.-KB/s    <span class="keyword">in</span> 0s</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span> (<span class="number">332</span> MB/s) - ‘index.html’ saved [<span class="number">3248</span>/<span class="number">3248</span>]</span><br></pre></td></tr></table></figure>

<p>Next, let’s try to ban the traffic from this IP address. </p>
<h5 id="Drop-packets-source-from-one-specific-IP-address"><a href="#Drop-packets-source-from-one-specific-IP-address" class="headerlink" title="Drop packets source from one specific IP address"></a>Drop packets source from one specific IP address</h5><p>As we mentioned above, multiple callback functions are allowed to be registered on the same Netfilter hook. So we will define the second hook function with a different priority. The logic of this hook function goes like this: we can get the source IP address from the IP headers and make the drop or accept decision according to it. The code goes as follows</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS(addr) \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[3], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[2], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[1], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[0]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ip_addr_rule = <span class="string">&quot;142.250.4.103&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockipaddr_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">char</span> *str = (<span class="type">char</span> *)kmalloc(<span class="number">16</span>, GFP_KERNEL);</span><br><span class="line">		u32 sip;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">sb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">		sb = skb;</span><br><span class="line">		iph = ip_hdr(sb);</span><br><span class="line">		sip = ntohl(iph-&gt;saddr); <span class="comment">// get source ip address; </span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sprintf</span>(str, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, IPADDRESS(sip)); <span class="comment">// convert to standard IP address format</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str, ip_addr_rule)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This hook function uses two interesting techniques:</p>
<ul>
<li><p><code>ntohl</code>: is a kernel function, which is used to convert the value from <code>network byte order</code> to <code>host byte order</code>. <code>Byte order</code> is related to the computer science concept of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness"><code>Endianness</code></a>. Endianness defines the order or sequence of bytes of a word of digital data in computer memory. A <code>big-endian</code> system stores the most significant byte of a word at the smallest memory address.  A <code>little-endian</code> system, in contrast, stores the least-significant byte at the smallest address. Network protocol uses the <code>big-endian</code> system. But different OS and platforms run various Endianness system. So it may need such conversion based on the host machine.</p>
</li>
<li><p><code>IPADDRESS</code>: is a macro, which generates the standard IP address format(four 8-bit fields separated by periods) from a 32-bit integer. It uses the technique of <a target="_blank" rel="noopener" href="https://www.eskimo.com/~scs/cclass/notes/sx10e.html"><code>the equivalence of arrays and pointers in C</code></a>. I will write another article to examine what it is and how it works. Please keep watching my updates!</p>
</li>
</ul>
<p>Next, we can register this hook function in the same way discussed above. The only remarkable point is this callback function should have a different priority as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">	nf_blockipaddr_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockipaddr_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hook = (nf_hookfn*)nf_blockipaddr_handler;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hooknum = NF_INET_PRE_ROUTING;  <span class="comment">// register to the same hook</span></span><br><span class="line">		nf_blockipaddr_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockipaddr_ops-&gt;priority = NF_IP_PRI_FIRST + <span class="number">1</span>; <span class="comment">// set a higher priority</span></span><br><span class="line"></span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockipaddr_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s see how it works with a demo. </p>
<h5 id="Demo-time-1"><a href="#Demo-time-1" class="headerlink" title="Demo time"></a>Demo time</h5><p>After re-build and re-load the module, we can get: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">20</span>:07--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. failed: Connection timed out.</span><br><span class="line">Retrying.</span><br></pre></td></tr></table></figure>

<p>The <code>wget 142.250.4.103</code> can’t return response. Because it is dropped by our mini-firewall. Great!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">3162.064284</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.089466</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.288603</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.345463</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.480123</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br></pre></td></tr></table></figure>

<h3 id="More-space-to-expand"><a href="#More-space-to-expand" class="headerlink" title="More space to expand"></a>More space to expand</h3><p>You can find the full code implementation <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">here</a>. But I have to say, our mini-firewall only touches the surface of what Netfilter can provide. You can keep expanding the functionalities. For example, currently, the rules are hardcoded, why not make it possible to config the rules dynamically. There are many cool ideas worth trying. I leave it for the readers.  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we implement the mini-firewall step by step and examined many detailed techniques. Not only code; but we also verify the behavior of the mini-firewall by running real demos.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/06/08/how-to-write-a-netfilter-firewall-part3/" data-id="clvv1t4j7003yc8mmhvogheab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/" class="article-date">
  <time datetime="2022-05-05T10:06:50.000Z" itemprop="datePublished">2022-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two - hello world module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the last <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/04/how-to-write-a-netfilter-firewall-part1/">article</a>, we examined the basics of <code>Netfilter</code> and <code>Linux kernel modules</code> in theory. Starting from this article, we will make our hands dirty and start implementing our mini-firewall. We will walk through the whole process step by step. In this article, let’s write our first Linux kernel module using a simple <code>hello world</code> demo. Then let’s learn how to build the module(which is very different from compiling an application in the user space) and how to load it in the kernel. After understanding how to write a module, in the next article, let’s write the initial version of our mini-firewall module using <a target="_blank" rel="noopener" href="https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks">Netfilter’s hook architecture</a>. All right. Let’s start the journey. </p>
<h3 id="Make-the-first-Kernel-module"><a href="#Make-the-first-Kernel-module" class="headerlink" title="Make the first Kernel module"></a>Make the first Kernel module</h3><p>First, I have to admit that Linux Kernel module development is a kind of large and complex technology topic. And there are many great <a target="_blank" rel="noopener" href="https://sysprog21.github.io/lkmpg/">online resources</a> about it. This series of articles is focusing on developing the mini-firewall based on Netfilter, so we can’t cover all the aspects of the Kernel module itself. In future articles, I’ll examine more in-depth knowledge of kernel modules. </p>
<h4 id="Write-the-module"><a href="#Write-the-module" class="headerlink" title="Write the module"></a>Write the module</h4><p>You can write the <code>hello world</code> Kernel module with a single <code>C</code> source code file <code>hello.c</code> as follows:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>We can write a Kernel module in such an easy and simple way because the Linux Kernel does the magic for you. Remember the design philosophy of Linux(Unix): <strong><em>Design for simplicity; add complexity only where you must</em></strong>. </p>
<p>Let’s examine several technical points worth to remark as follows: </p>
<p>First, Kernel modules must have at least two functions: a “start” function which is called when the module is loaded into the kernel, and an “end” function which is called just before it is removed from the kernel. Before kernel 2.3.13, the names of these two functions are hardcoded as <code>init_module()</code> and <code>cleanup_module()</code>. But in the new versions, you can use whatever name you like for the start and end functions of a module by using the <code>module_init</code> and <code>module_exit</code> macros. The macros are defined in <code>include/linux/module.h</code> and <code>include/linux/init.h</code>. You can refer there for detailed information. </p>
<p>Typically, <code>module_init</code> either registers a handler for something with the kernel (for example, the mini-firewall developed in this article), or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <code>module_exit</code> function is supposed to undo whatever <code>module_init</code> did, so the module can be unloaded safely.</p>
<p>Second, <code>printk</code> function provides similar behaviors to <code>printf</code>, which accepts the <code>format string</code> as the first argument. The <code>printk</code> function prototype goes as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br></pre></td></tr></table></figure>

<p><code>printk</code> function allows a caller to specify <code>log level</code> to indicate the type and importance of the message being sent to the kernel message log. For example, in the above code, the log level <code>KERN_INFO</code> is specified by prepending to the format string. In C programming, this syntax is called <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/String_literal#String_literal_concatenation"><code>string literal concatenation</code></a>. (In other high-level programming languages, string concatenation is generally done with <code>+</code> operator). For the function <code>printk</code> and <code>log level</code>, you can find more information in <code>include/linux/kern_levels.h</code> and <code>include/linux/printk.h</code>.   </p>
<p>Note: The path to header files for Linux kernel module development is different from the one you often used for the application development. Don’t try to find the header file inside <em>/usr/include/linux</em>, instead please use the following path <em>/lib/modules/`uname -r`/build/include/linux</em> (<code>uname -r</code> command returns your kernel version).</p>
<p>Next, let’s build this hello-world kernel module.</p>
<h4 id="Build-the-module"><a href="#Build-the-module" class="headerlink" title="Build the module"></a>Build the module</h4><p>The way to build a kernel module is a little different from how to build a user-space application. The efficient solution to build kernel image and its modules is <code>Kernel Build System(Kbuild)</code>. </p>
<p><code>Kbuild</code> is a complex topic and I won’t explain it in too much detail here. Simply speaking, <code>Kbuild</code> allows you to create highly customized kernel binary images and modules. Technically, each subdirectory contains a <code>Makefile</code> compiling only the source code files in its directory. And a top-level Makefile recursively executes each subdirectory’s Makefile to generate the binary objects. And you can control which subdirectories are included by defining <code>config files</code>. In detail, you can refer to other <a target="_blank" rel="noopener" href="https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system">documents</a>. </p>
<p>The following is the Makefile for the <code>hello world</code> module: </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>The <code>make -C dir</code> command changes to directory dir before reading the makefiles or doing anything else. The top-level Makefile in <em>/lib/modules/$(shell uname -r)/build</em> will be used. You can find that command <code>make M=dir modules</code> is used to make all modules in specified dir.</p>
<p>And in the module-level Makefile, the <code>obj-m</code> syntax tells <code>kbuild</code> system to build <code>module_name.o</code> from <code>module_name.c</code>, and after linking, will result in the kernel module <code>module_name.ko</code>. In our case, the module name is <code>hello</code>.</p>
<p>The build process goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ sudo make</span><br><span class="line">make -C /lib/modules/4.15.0-176-generic/build M=/home/DIR/jbao6/develop/kernel/hello-1  modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br><span class="line">  CC [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/DIR/jbao6/develop/kernel/hello-1/hello.mod.o</span><br><span class="line">  LD [M]  /home/DIR/jbao6/develop/kernel/hello-1/hello.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/linux-headers-4.15.0-176-generic&#x27;</span></span><br></pre></td></tr></table></figure>
<p>After the build, you can get several new files in the same directory: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~/develop/kernel/hello-1$ <span class="built_in">ls</span></span><br><span class="line">hello.c  hello.ko  hello.mod.c  hello.mod.o  hello.o  Makefile  modules.order  Module.symvers</span><br></pre></td></tr></table></figure>
<p>The file ends with <code>.ko</code> is the kernel module. You can ignore other files now, I will write another article later to have a deep discussion about the kernel module system. </p>
<h4 id="Load-the-module"><a href="#Load-the-module" class="headerlink" title="Load the module"></a>Load the module</h4><p>With the <code>file</code> command, you can note that the kernel module is an <code>ELF(Executable and Linkable Format)</code> format file. ELF files are typically the output of a compiler or linker and are a binary format. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrisba:~/develop/kernel/hello-1$ file hello.ko</span><br><span class="line">hello.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=f0da99c757751e7e9f9c4e55f527fb034a0a4253, not stripped</span><br></pre></td></tr></table></figure>

<p>Next step, let’s try to install and remove the module dynamically. You need to know the following three commands: </p>
<ul>
<li><em>lsmod</em>: shows the list of kernel modules currently loaded.</li>
<li><em>insmod</em>: inserts a module into the Linux Kernel by running <code>sudo insmod module_name.ko</code></li>
<li><em>rmmod</em>: removes a module from the Linux Kernel by running <code>sudo rmmod module_name</code></li>
</ul>
<p>Since the <code>hello world</code> module is quite simple, you can easily install and remove the module as you wish. I will not show the detailed commands here and leave it to the readers. </p>
<p><strong>Note</strong>: It doesn’t mean that you can easily install and remove any kernel module without any issues. If the module you are loading has bugs, the entire system can crash. </p>
<h4 id="Debug-the-module"><a href="#Debug-the-module" class="headerlink" title="Debug the module"></a>Debug the module</h4><p>Next step, let’s prove that the <code>hello world</code> module is installed and removed as expected. We will use <code>dmesg</code> command. <code>dmesg</code> (diagnostic messages) can print the messages in the <code>kernel ring buffer</code>. </p>
<p>First, a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circular_buffer"><code>ring buffer</code></a> is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. The <code>kernel ring buffer</code> is a ring buffer that records messages related to the operation of the kernel. As we mentioned above, the kernel logs printed by the <code>printk</code> function will be sent to the kernel ring buffer. </p>
<p>We can find the messages produced by our module with command <code>dmesg | grep world</code> as follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao:~$ dmesg | grep world</span><br><span class="line"></span><br><span class="line">[2147137.177254] Hello, world</span><br><span class="line">[3281962.445169] Goodbye, world</span><br><span class="line">[3282008.037591] Hello, world</span><br><span class="line">[3282054.921824] Goodbye, world</span><br></pre></td></tr></table></figure>

<p>Now you can see that the <code>hello world</code> is loaded into the kernel correctly. And it can be removed dynamically as well. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to write a kernel module, how to build it and how to install it into the kernel dynamically. Next article we can work on the mini-firewall as a <code>Netfilter</code> module. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/05/how-to-write-a-netfilter-firewall-part2/" data-id="clvv1t4ii001nc8mmdblpcq20" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-write-a-netfilter-firewall-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/" class="article-date">
  <time datetime="2022-05-04T10:06:50.000Z" itemprop="datePublished">2022-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><code>Firewalls</code> are an important tool that can be configured to protect your servers and infrastructure. Firewalls’ main functionalities are filtering data, redirecting traffic, and protecting against network attacks. There are both hardware-based firewalls and software-based firewalls. I will not discuss too much about the background here, since you can find many online documents about <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Firewall_(computing)">it</a>.</p>
<p>Have you ever thought of implementing a simple firewall from scratch? Sounds crazy? But with the power of Linux, you can do that. After you read this series of articles, you will find that actually, it is quite simple. </p>
<p>You may once use various firewalls on Linux such as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iptables">iptables</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nftables">nftables</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall">UFW</a>, etc. All of these firewall tools are user-space utility programs, and they are all relying on <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Netfilter"><code>Netfilter</code></a>. <code>Netfilter</code> is the Linux kernel subsystem that allows various networking-related operations to be implemented. <code>Netfilter</code> allows you to develop your firewall using the <code>Linux Kernel Module</code>.  If you don’t know the techniques such as the Linux Kernel module and Netfilter, don’t worry. In this article, let’s write a Linux firewall from scratch based on Netfilter. You can learn the following interesting points:</p>
<ul>
<li>Linux kernel module development.</li>
<li>Linux kernel network programming. </li>
<li>Netfilter module development.</li>
</ul>
<h3 id="Netfilter-and-Kernel-modules"><a href="#Netfilter-and-Kernel-modules" class="headerlink" title="Netfilter and Kernel modules"></a>Netfilter and Kernel modules</h3><h4 id="Basics-of-Netfilter"><a href="#Basics-of-Netfilter" class="headerlink" title="Basics of Netfilter"></a>Basics of Netfilter</h4><p><code>Netfilter</code> can be considered to be the third generation of <code>firewall</code> on Linux. Before <code>Netfilter</code>was introduced in Linux Kernel 2.4, there are two older generations of firewalls on Linux as follows: </p>
<ul>
<li>The first generation was a port of an early version of BSD UNIX’s <code>ipfw</code> to Linux 1.1. </li>
<li>The second generation was <code>ipchains</code> developed in the 2.2 series of Linux Kernel. </li>
</ul>
<p>As we mentioned above, <code>Netfilter</code> was designed to provide the infrastructure inside the Linux kernel for various networking operations. So <code>firewall</code> is just one of the multiple functionalities provided by <code>Netfilter</code> as follows:</p>
<img src="/images/netfilter-arch.png" title="Netfilter architecture" width="600px" height="400px">

<ul>
<li><strong>Packet filtering</strong>: is in charge of filtering the packets based on the rules. It is also the topic of this article. </li>
<li><strong>NAT (Network address translation)</strong>: is in charge of translating the IP address of network packets. <code>NAT</code> is an important protocol, which has become a popular and essential tool in <code>conserving global address space in the face of IPv4 address exhaustion</code>. If you don’t know <code>NAT</code> protocol, you can refer to other <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_address_translation">documents</a>. I will examine it in other future articles. </li>
<li><strong>Packet mangling</strong>: is in charge of modifying the packet content(In fact, <code>NAT</code> is one kind of packet mangling, which modifies the source or destination IP address). For example, <code>MSS (Maximum Segment Size)</code> value of TCP SYN packets can be altered to allow large-size packets transported over the network. </li>
</ul>
<p>Note: this article will focus on building a simple firewall to filter packets based on Netfilter. So the <code>NAT</code> and <code>Packet Mangling</code> parts are not in the scope of this article. </p>
<p>Packet filtering can only be done inside the Linux kernel (Netfilter’s code is in the kernel as well), if we want to write a mini firewall, it has to run in the kernel space. Right? Does it mean we need to add our code into the kernel and recompile the kernel? Imagine you have to recompile the kernel each time you want to add a new packet filtering rule. That’s a bad idea. The good news is that <code>Netfilter</code> allows you to add extensions using the <a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/Kernel_module"><code>Linux kernel modules</code></a>. </p>
<h4 id="Basics-of-Linux-Kernel-modules"><a href="#Basics-of-Linux-Kernel-modules" class="headerlink" title="Basics of Linux Kernel modules"></a>Basics of Linux Kernel modules</h4><p>Although Linux is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Monolithic_kernel"><code>monolithic kernel</code></a>, it can be extended using kernel modules. Modules can be inserted into the kernel and removed on demand. Linux isolates the kernel but allows you to add specific functionality on the fly through modules. In this way, Linux keeps a balance between stability and usability. </p>
<p>I want to examine one confusing point about the kernel module here: what is the difference between <code>driver</code> and <code>module</code>:</p>
<ul>
<li>A driver is a bit of code that runs in the kernel to talk to some hardware device. It drives the hardware. Standard practice is to build drivers as kernel modules where possible, rather than link them statically to the kernel since that gives more flexibility. </li>
<li>A kernel module may not be a device driver at all.    </li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In the first post of this series, we examine the basics of Netfilter and Linux kernel modules. In the next post, let’s start implementing the mini firewall. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/05/04/how-to-write-a-netfilter-firewall-part1/" data-id="clvv1t4ii001lc8mm4a9yejrh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" class="article-date">
  <time datetime="2022-03-28T06:15:15.000Z" itemprop="datePublished">2022-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">previous article</a>, we examined how to develop a network sniffer with <code>PF_SOCKET</code> socket in Linux platform. The sniffer developed in the last article captures all the network packets. But a powerful network sniffer like <code>tcpdump</code> should provide the packet filtering functionality. For instance, the sniffer can only capture the <code>TCP</code> segment(and skip the UPD), or it can only capture the packets from a specific source IP address. In this article, let’s continue to explore how to do that. </p>
<h3 id="Background-of-BPF"><a href="#Background-of-BPF" class="headerlink" title="Background of BPF"></a>Background of BPF</h3><p><code>Berkeley Packet Filter(BPF)</code> is the essential underlying technology for packet capture in Unix-like operating systems.<br>Search BPF as the keyword online, and the result is very confusing. It turns out that <code>BPF</code> keeps evolving, and there are several associated concepts such as <code>BPF</code> <code>cBPF</code> <code>eBPF</code> and <code>LSF</code>. So let us examine those concepts along the timeline:</p>
<ul>
<li><p>In <strong>1992</strong>, <code>BPF</code> was first introduced to the BSD Unix system for filtering unwanted network packets. The proposal of BPF was from researchers in Lawrence Berkeley Laboratory, who also developed the <code>libpcap</code> and <code>tcpdump</code>. </p>
</li>
<li><p>In <strong>1997</strong>, Linux Socket Filter(LSF) was developed based on BPF and introduced in Linux kernel version 2.1.75. Note that <code>LSF</code> and <code>BPF</code> have some distinct differences, but in the Linux context, when we speak of BPF or LSF, we mean the same packet filtering mechanism in the Linux kernel. We’ll examine the detailed theory and design of BPF in the following sections. </p>
</li>
<li><p>Originally, BPF was designed as a network packet filter. But in <strong>2013</strong>, BPF was widely extended, and it can be used for non-networking purposes such as performance analysis and troubleshooting. Nowadays, the extended BPF is called <code>eBPF</code>, and the original and obsolete version is renamed to classic BPF (<code>cBPF</code>). <strong>Note that what we examine in this article is cBPF, and eBPF is not inside the scope of this article</strong>. <code>eBPF</code> is the hottest technology in today’s software world, and I’ll talk about it in the future. </p>
</li>
</ul>
<h3 id="Where-to-place-BPF"><a href="#Where-to-place-BPF" class="headerlink" title="Where to place BPF"></a>Where to place BPF</h3><p>The first question to answer is where should we place the filter. The last article examines the path of a received packet  as follows: </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>The best solution to this question is to put the filter as early as possible in the path. Since copying a large amount of data from kernel space to the user space produces a huge overhead, which can influence the system performance a lot. So BPF is a kernel feature. The filter should be triggered immediately when a packet is received at the network interface.As the original BPF <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> said <strong>To minimize memory traffic, the major bottleneck in most modern system, the packet should be filtered ‘in place’ (e.g., where the network interface DMA engine put it) rather than copied to some other kernel buffer before filtering.</strong><br>Let’s verify this behavior by examining the kernel source code as follows (<strong>Note</strong> the kernel code shown in this article is based on version 2.6, which contains the <code>cBPF</code> implementation.): </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source code file of net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* packet_create: create socket */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">	po = pkt_sk(sk);</span><br><span class="line">	sk-&gt;sk_family = PF_PACKET;</span><br><span class="line">	po-&gt;num = proto;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;po-&gt;bind_lock);</span><br><span class="line">	po-&gt;prot_hook.func = packet_rcv; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">		po-&gt;prot_hook.func = packet_rcv_spkt; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proto) &#123;</span><br><span class="line">		po-&gt;prot_hook.type = proto;</span><br><span class="line">		dev_add_pack(&amp;po-&gt;prot_hook);</span><br><span class="line">		sock_hold(sk);</span><br><span class="line">		po-&gt;running = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_create</code> function handles the socket creation when the application calls the <code>socket</code> system call. In lines 11 and 14, it attaches the hook function to the socket. The hook function executes when the packet is received.</p>
<p>The following code block shows the hook function <code>packet_rcv</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hook function packet_rcv is triggered, when the packet is received */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    sk = pt-&gt;af_packet_priv;</span><br><span class="line">    snaplen = skb-&gt;len;</span><br><span class="line">    res = run_filter(skb, sk, snaplen); <span class="comment">// filter logic</span></span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">	    <span class="keyword">goto</span> drop_n_restore; <span class="comment">// drop the packet</span></span><br><span class="line"></span><br><span class="line">    __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb); <span class="comment">// put the packet into the queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_rcv</code> function calls <code>run_filter</code>, which is just the BPF logic part(Currently, you can regard it as a black box. In the next section, we’ll examine the details). Based on the return value of <code>run_filter</code> the packet can be filtered out or put into the queue. </p>
<p>So far, you can understand BPF(or the packet filtering) is working inside kernel space. But the packet sniffer is a user-space application. The next question is how to link the filtering rules in user space to the filtering handler in kernel space. </p>
<p>To answer this question, we have to understand BPF itself. It’s right time to understand this great piece of work. </p>
<h3 id="BPF-machine"><a href="#BPF-machine" class="headerlink" title="BPF machine"></a>BPF machine</h3><p>As I mentioned above, <code>BPF</code> was introduced in this original <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> written by researchers from Berkeley. I strongly recommend you read this great paper based on my own experience. In the beginning, I felt crazy to read it, so I read other related documents and tried to understand BPF. But most documents only cover one portion of the entire system, so it is difficult to piece all the information together. Finally, I read the original paper and connected all parts together. <strong>As the saying goes, sometimes taking time is actually a shortcut.</strong></p>
<h5 id="Virtual-CPU"><a href="#Virtual-CPU" class="headerlink" title="Virtual CPU"></a>Virtual CPU</h5><p>A packet filter is simply a boolean-valued function on a packet. If the value of the function is true the kernel copies the packet for the application; if it is false the packet is ignored. </p>
<p>In order to be as flexible as possible and not to limit the application to a set of predefined conditions, the <code>BPF</code> is actually implemented as a <code>register-based virtual machine</code> (for the difference between stack-based and register-based virtual machine, you can refer to <a target="_blank" rel="noopener" href="http://troubles.md/wasm-is-not-a-stack-machine/">this article</a>) running a user-defined program.  </p>
<p>You can regard the <code>BPF</code> as a <code>virtual CPU</code>. And it consists of an <code>accumulator</code>, an <code>index register(x)</code>, a scratch memory store, and an implicit <code>program counter</code>. If you’re not familiar with these concepts, I add some simple illustrations as follows:</p>
<ul>
<li>An <code>accumulator</code> is a type of register included in a CPU. It acts as a temporary storage location holding an intermediate value in mathematical and logical calculations. For example, in the operation of “1+2+3”, the accumulator would hold the value 1, then the value 3, then the value 6. The benefit of an accumulator is that it does not need to be explicitly referenced.</li>
<li>An <code>index register</code> in a computer’s CPU is a processor register or assigned memory location used for modifying operand addresses during the run of a program. </li>
<li>A <code>program counter</code> is a CPU register in the computer processor which has the address of the next instruction to be executed from memory. </li>
</ul>
<p>In the BPF machine, the accumulator is used for arithmetic operations, while the index register provides offsets into the packet or the scratch memory areas.  </p>
<h5 id="Instructions-set-and-addressing-mode"><a href="#Instructions-set-and-addressing-mode" class="headerlink" title="Instructions set and addressing mode"></a>Instructions set and addressing mode</h5><p>Same as the physical CPU, the <code>BPF</code> provides a small set of arithmetic, logical and jump instructions as follows, these instructions run on the BPF virtual machine(or CPU): </p>
<img src="/images/bpf-instructions.png" title="BPF instructions" width="400px" height="300px">

<p>The first column <em>opcodes</em> lists the BPF instructions written in an assembly language style. For example, <strong>ld</strong>, <strong>ldh</strong> and <strong>ldb</strong> means to copy the indicated value into the <code>accumulator</code>. <strong>ldx</strong> means to copy the indicated value into the <code>index register</code>. <strong>jeq</strong> means jump to the target instruction if the <code>accumulator</code> equals the indicated value. <strong>ret</strong> means return the indicated value. You can check the functionality of the instructions set in detail in the paper. </p>
<p>This kind of assembly-like style is more readable to humans. But when we develop an application (like the sniffer written in this article), we use binary code directly as the BPF instruction. This kind of binary format is called <code>BPF Bytecode</code>. I’ll examine the way to convert this assembly language to bytecode later. </p>
<p>The second column <em>addr modes</em> lists the addressing modes allowed for each instruction. The semantics of the addressing modes are listed in the following table: </p>
<img src="/images/address-mode.png" title="BPF instructions address mode" width="400px" height="300px">

<p>For instance, <strong>[k]</strong> means the data at byte offset k in the packet. <strong>#k</strong> means the literal value stored in k. You can read the paper in detail to check the meaning of other address modes.  </p>
<h5 id="Example-BPF-program"><a href="#Example-BPF-program" class="headerlink" title="Example BPF program"></a>Example BPF program</h5><p>Now let’s try to understand the following small BPF program based on the knowledge above: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2    jf 3</span><br><span class="line">(002) ret      #262144</span><br><span class="line">(003) ret      #0</span><br></pre></td></tr></table></figure>
<p>The BPF program consists of an array of BPF instructions. For example, the above BPF program contains four instructions. </p>
<p>The first instruction <strong>ldh</strong> loads a half-word(16-bit) value into the accumulator from offset 12 in the Ethernet packet. According to the Ethernet frame format shown below, the value is just the <code>Ethernet type</code> field. The Ethernet type is used to indicate which protocol is encapsulated in the frame’s payload (for example,  0x0806 for ARP, <strong>0x0800</strong> for IPv4, and 0x86DD for IPv6).</p>
<img src="/images/ethernet-frame-format.png" title="Ethernet frame fromat" width="600px" height="400px">

<p>The second instruction <strong>jeq</strong> compares the accumulator (currently stores <code>Ethernet type</code> field) to <code>0x800</code>(stands for IPv4). If the comparison fails, zero is returned, and the packet is rejected. If it is successful, a non-zero value is returned, and the packet is accepted. <strong>So the small BPF program filters and accepts all IP packets</strong>. You can find other BPF programs in the original paper. Go to read it, and you can feel the flexibility of BPF as well as the beauty of the design. </p>
<h5 id="Kernel-implementation-of-BPF"><a href="#Kernel-implementation-of-BPF" class="headerlink" title="Kernel implementation of BPF"></a>Kernel implementation of BPF</h5><p>Next, let’s examine how kernel implements BPF. As mentioned above, the hook function <code>packet_rcv</code> calls <code>run_filter</code> to handle the filtering logic. <code>run_filter</code> is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copied from net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* function run_filter is called in packet_rcv*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">int</span> res)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	filter = rcu_dereference(sk-&gt;sk_filter); <span class="comment">// get the filter bound to the socket</span></span><br><span class="line">	<span class="keyword">if</span> (filter != <span class="literal">NULL</span>)</span><br><span class="line">		res = sk_run_filter(skb, filter-&gt;insns, filter-&gt;len); <span class="comment">// the filtering is inside sk_run_filter function</span></span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find that the real filtering logic is inside <code>sk_run_filter</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sk_run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock_filter *filter, <span class="type">int</span> flen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">fentry</span>;</span>	<span class="comment">/* We walk down these */</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	u32 A = <span class="number">0</span>;			<span class="comment">/* Accumulator */</span></span><br><span class="line">	u32 X = <span class="number">0</span>;			<span class="comment">/* Index Register */</span></span><br><span class="line">	u32 mem[BPF_MEMWORDS];		<span class="comment">/* Scratch Memory Store */</span></span><br><span class="line">	u32 tmp;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">int</span> pc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Process array of filter instructions.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (pc = <span class="number">0</span>; pc &lt; flen; pc++) &#123;</span><br><span class="line">		fentry = &amp;filter[pc];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (fentry-&gt;code) &#123;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_X:</span><br><span class="line">			A += X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_K:</span><br><span class="line">			A += fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_X:</span><br><span class="line">			A -= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_K:</span><br><span class="line">			A -= fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_MUL|BPF_X:</span><br><span class="line">			A *= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* some code omitted ... */</span></span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_K:</span><br><span class="line">			<span class="keyword">return</span> fentry-&gt;k;</span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_A:</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		<span class="keyword">case</span> BPF_ST:</span><br><span class="line">			mem[fentry-&gt;k] = A;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_STX:</span><br><span class="line">			mem[fentry-&gt;k] = X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Same as we mentioned, <code>sk_run_filter</code> is simply a boolean-valued function on a packet. It maintains the accumulator, the index register, etc. as local variables. And process the array of BPF filter instructions in a <code>for</code> loop. Each instruction will update the value of local variables. In this way, it simulates a virtual CPU. Interesting, right? </p>
<h5 id="BPF-JIT"><a href="#BPF-JIT" class="headerlink" title="BPF JIT"></a>BPF JIT</h5><p>Since each network packet must go through the filtering function, it becomes the performance bottleneck of the entire system. </p>
<p>A <code>just-in-time (JIT)</code> compiler was introduced into the kernel in <strong>2011</strong> to speed up BPF bytecode execution. </p>
<ul>
<li>What is a <code>JIT</code> compiler? A <code>JIT</code> compiler runs <strong>after</strong> the program has started and compiles the code(usually bytecode or some type of VM instructions) on the fly(or just in time) into a form that’s usually faster, typically the host CPU’s native instruction set. This is in contrast to a <code>traditional compiler</code> that compiles all the code to machine language <strong>before</strong> the program is first run. </li>
</ul>
<p>In the <code>BPF</code> case, the <code>JIT</code> compiler translates BPF bytecode into a host system’s assembly code directly, which can optimize the performance a lot. I’ll not show details about JIT in this article. You can refer to the <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.19.8/source/arch/arm/net/bpf_jit_32.c#L868">kernel code</a>.  </p>
<h3 id="Set-BPF-in-sniffer"><a href="#Set-BPF-in-sniffer" class="headerlink" title="Set BPF in sniffer"></a>Set BPF in sniffer</h3><p>Next, let’s add BPF into our packet sniffer. As we mentioned above in the application level, the BPF instructions should use bytecode format with the following data structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>    <span class="comment">/* Filter block */</span></span><br><span class="line">        __u16   code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">        __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">        __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">        __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How can we convert the BPF assembly language into bytecode? There are two solutions. First, there is a small helper tool called <code>bpf_asm</code>(which is provided along with the Linux kernel), and you can regard it as the BPF assembly language interpreter. But it is not recommended to application developers. </p>
<p>Second, we can use <code>tcpdump</code>, which provides the converting functionality. You can find the following information from the tcpdump man page: </p>
<ul>
<li><p>-d:   Dump the compiled packet-matching code in a human-readable form to standard output and stop.</p>
</li>
<li><p>-dd:  Dump packet-matching code as a C program fragment.</p>
</li>
<li><p>-ddd: Dump packet-matching code as decimal numbers (preceded with a count).</p>
</li>
</ul>
<p><code>tcpdump ip</code> means we want to capture all the IP packets. With options <strong>-d</strong>, <strong>-dd</strong> and <strong>-ddd</strong>, the output goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">baoqger@ubuntu:~$ sudo tcpdump -d ip</span><br><span class="line">[sudo] password <span class="keyword">for</span> baoqger:</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      <span class="comment">#0x800           jt 2    jf 3</span></span><br><span class="line">(002) ret      <span class="comment">#262144</span></span><br><span class="line">(003) ret      <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -<span class="built_in">dd</span> ip</span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -ddd ip</span><br><span class="line">4</span><br><span class="line">40 0 0 12</span><br><span class="line">21 0 1 2048</span><br><span class="line">6 0 0 262144</span><br><span class="line">6 0 0 0</span><br></pre></td></tr></table></figure>
<p>Option <strong>-d</strong> prints the BPF instructions in assembly language (same as the example BPF program shown above). Options <strong>-dd</strong> prints the bytecode as a C program fragment. <strong>So tcpdump is the most convenient tool when you want to get the BPF bytecode</strong>.</p>
<p>The BPF filter bytecode (wrapped in the structure <code>sock_fprog</code>) can be passed to the kernel through <code>setsockopt</code> system call as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attach the filter to the socket</span></span><br><span class="line"><span class="comment">// the filter code is generated by running: tcpdump tcp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">BPF_code</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">Filter</span>;</span></span><br><span class="line"><span class="comment">// error prone code, .len field should be consistent with the real length of the filter code array</span></span><br><span class="line">Filter.len = <span class="keyword">sizeof</span>(BPF_code)/<span class="keyword">sizeof</span>(BPF_code[<span class="number">0</span>]); </span><br><span class="line">Filter.filter = BPF_code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;setsockopt attach filter&quot;</span>);</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>setsockopt</code> system call triggers two kernel functions: <code>sock_setsockopt</code> and <code>sk_attach_filter</code> (I’ll not show the details for these two functions), which <strong>binds the filters to the socket</strong>. And in <code>run_filter</code> kernel function (mentioned above), it can <strong>get the filters from the socket</strong> and <strong>execute the filters on the packet</strong>. </p>
<p>So far, every piece is connected. The puzzle of BPF is solved. The <code>BPF</code> machine allows the user-space applications to inject customized BPF programs straight into a kernel. Once loaded and verified, BPF programs execute in kernel context. These BPF programs operate inside kernel memory space with access to all the internal kernel states available to it. For example, the <code>cBPF</code> machine which uses the network packet data. But this power can be extended as <code>eBPF</code>, which can be used in many other varied applications. As someone <a target="_blank" rel="noopener" href="https://www.brendangregg.com/bpf-performance-tools-book.html">said</a> <strong>In some way, eBPF does to the kernel what Javascript does to the websites: it allows all sorts of new application to be created.</strong>  In the future, I plan to examine eBPF in depth. </p>
<img src="/images/bpf-run-instructions.png" title="BPF Run Instructions" width="600px" height="400px">

<h3 id="Process-the-packet"><a href="#Process-the-packet" class="headerlink" title="Process the packet"></a>Process the packet</h3><p>We examined the <code>BPF</code> filtering theory on the kernel level a lot in the above section. But for our tiny sniffer, the last step we need to do is process the network packet. </p>
<ul>
<li><p>First, the <code>recvfrom</code> system call reads the packet from the socket. And we put the system call in a <code>while</code> loop to keep reading the incoming packets. </p>
</li>
<li><p>Then, we print the source and destination <code>MAC</code> address in the packet(the packet we got is a raw Ethernet frame in Layer 2, right?). And if what this Ethernet frame contains is an <code>IP4</code> packet, then we print out the source and destination <code>IP</code> address. To understand more about it, you can study the header format of various network protocols. I will not cover in details here.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------\n&quot;</span>);</span><br><span class="line">	n = recvfrom(sock, buffer, <span class="number">2048</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d bytes read\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check to see if the packet contains at least</span></span><br><span class="line"><span class="comment">	* complete Ethernet (14), IP (20) and TCP/UDP</span></span><br><span class="line"><span class="comment">	* (8) headers.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">42</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;recvfrom():&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Incomplete packet (errno is %d)\n&quot;</span>, errno);</span><br><span class="line">		close(sock);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ethhead = buffer;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Source MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">0</span>], ethhead[<span class="number">1</span>], ethhead[<span class="number">2</span>], ethhead[<span class="number">3</span>], ethhead[<span class="number">4</span>], ethhead[<span class="number">5</span>]</span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Destination MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">6</span>], ethhead[<span class="number">7</span>], ethhead[<span class="number">8</span>], ethhead[<span class="number">9</span>], ethhead[<span class="number">10</span>], ethhead[<span class="number">11</span>]</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	iphead = buffer + <span class="number">14</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*iphead==<span class="number">0x45</span>) &#123; <span class="comment">/* Double check for IPv4</span></span><br><span class="line"><span class="comment">						* and no options present */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">12</span>],iphead[<span class="number">13</span>],</span><br><span class="line">				iphead[<span class="number">14</span>],iphead[<span class="number">15</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dest host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">16</span>],iphead[<span class="number">17</span>],</span><br><span class="line">				iphead[<span class="number">18</span>],iphead[<span class="number">19</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source,Dest ports %d,%d\n&quot;</span>,</span><br><span class="line">				(iphead[<span class="number">20</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">21</span>],</span><br><span class="line">				(iphead[<span class="number">22</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">23</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Layer-4 protocol %s\n&quot;</span>, transport_protocol(iphead[<span class="number">9</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find the complete source code of the sniffer in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c">repo</a>.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to add filters to our sniffer. First, we analyze why the filter should be running inside kernel space instead of the application space. Then, this article examines the <code>BPF</code> machine design and implementation in detail based on the paper. We reviewed the kernel source code to understand how to implement the <code>BPF</code> virtual machine. As I mentioned above, the original <code>BPF</code>(<code>cBPF</code>) was extended to <code>eBPF</code> now. But the understanding of the BPF virtual machine is very helpful to <code>eBPF</code> as well.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" data-id="clvv1t4j6003wc8mmdk18d9vu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" class="article-date">
  <time datetime="2022-02-22T02:21:14.000Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>When we refer to network packet sniffer, some famous and popular tools come to your mind, like <code>tcpdump</code>. I have shown you how to capture network packets with such tools in my previous articles. But have you ever thought about writing a packet sniffer from scratch without dependencies on any third-party libraries? We need to dig deep into the operating system and find the weapons needed to build this tool. Sounds complex, right? In this article, let us do it. After reading this article, you can find that it is not as difficult as you think. </p>
<p>Note that different operating system kernels have different internal network implementations. This article will focus on the <code>Linux</code> platform. </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Firstly, we need to review how <code>tcpdump</code> is implemented. According to the official <a target="_blank" rel="noopener" href="https://www.tcpdump.org/">document</a>, <code>tcpdump</code> is built on the library <code>libpcap</code>, which is developed based on the remarkable research result from Berkeley, in details you can refer to <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">this paper</a>.</p>
<p>As you know, different operating systems have different internal implementations of network stacks. <code>libpcap</code> covers all of these differences and provides the system-independent interface for user-level packet capture. I want to focus on the Linux platform, so how does <code>libpcap</code> work on the Linux system? According to some <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21200009/capturing-performance-with-pcap-vs-raw-socket">documents</a>, it turns out that libpcap uses the <code>PF_PACKET</code> socket to capture packets on a network interface.</p>
<p>So the next question is: what the <code>PF_PACKET</code> socket is? </p>
<h3 id="PF-PACKET-socket"><a href="#PF-PACKET-socket" class="headerlink" title="PF_PACKET socket"></a>PF_PACKET socket</h3><p>In my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2021/07/31/how-to-implement-simple-http-server-golang/">article</a>, we mentioned that the socket interface is TCP/IP’s window on the world. In most modern systems incorporating TCP/IP, the socket interface is the only way applications can use the TCP/IP suite of protocols. </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>It is correct. This time, let’s dig deeper about <code>socket</code> by examining the system call executed when we create a new socket: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>When you want to create a socket with the above system call, you have to specify which domain (or protocol family) you want to use with that socket as the first argument. The most commonly used family is <code>PF_INET</code>, which is for communications based on IPv4 protocols (when you create a TCP server, you use this family). Moreover, you have to specify a type for your socket as the second argument. And the possible values depend on the family you specified. For example, when dealing with the <code>PF_INET</code> family, the values for type include <code>SOCK_STREAM</code>(for TCP) and <code>SOCK_DGRAM</code>(for UDP). For other detailed information about the socket system call, you can refer to the socket(3) man page. </p>
<p>You can find one potential value for the <code>domain</code> argument as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AF_PACKET    Low-level packet interface</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: <code>AF_PACKET</code> and <code>PF_PACKET</code> are same. It is called <code>PF_PACKET</code> in history and then renamed  <code>AF_PACKET</code> later. <code>PF</code> means protocol families, and <code>AF</code> means address families. In this article, I use <code>PF_PACKET</code>. </p>
<p>Different from <code>PF_INET</code> socket, which can give you TCP segment. By <code>PF_PACKET</code> socket, you can get the raw <code>Ethernet</code> frame which bypasses the usual upper layer handling of TCP/IP stack. It might sound a little bit crazy. But, that is, any packet received will be directly passed to the application. </p>
<p>For a better understanding of <code>PF_PACKET</code> socket, let us go deeper and roughly examine the path of a received packet from the network interface to the application level. </p>
<p>(As shown in the image above) When the network interface card(NIC) receives a packet, it is handled by the driver. The driver maintains a structure called <code>ring buffer</code> internally. And write the packet to kernel memory (the memory is pre-allocated with ring buffer)  with direct memory access(DMA). The packet is placed inside a structure called <strong><code>sk_buff</code></strong>(one of the most important structures related to kernel network subsystem).   </p>
<p>After entering the kernel space, the packet goes through protocol stack handling layer by layer, such as <code>IP processing</code> and <code>TCP/UDP processing</code>. And the packet goes into applications via the socket interface. You already understand this familiar path very well.</p>
<p>But for the <code>PF_PACKET</code> socket, the packet in <code>sk_buff</code> is cloned, then it skips the protocol stacks and directly goes to the application. The kernel needs the clone operation, because one copy is consumed by the <code>PF_PACKET</code> socket, and the other one goes through the usual protocol stacks.</p>
<p>In future articles, I’ll demonstrate more about Linux kernel network internals.</p>
<p>Next step, let us see how to create a <code>PF_PACKET</code> socket at the code level. For brevity, I omit some code and only show the essential part. You can refer to this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c">repo</a> in detail.  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((sock = <span class="built_in">socket</span>(PF_PACKET, SOCK_RAW, <span class="built_in">htons</span>(ETH_P_IP))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please ensure to include the system header files: <code>&lt;sys/socket.h&gt; &lt;sys/types.h&gt;</code>. </p>
<h3 id="Bind-to-one-network-interface"><a href="#Bind-to-one-network-interface" class="headerlink" title="Bind to one network interface"></a>Bind to one network interface</h3><p>Without the additional settings, the sniffer captures all the packets received on all the network devices. Next step, let us try to bind the sniffer to a specific network device. </p>
<p>Firstly, you can use <code>ifconfig</code> command to list all the available <code>network interfaces</code> on your machines. The network interface is a software interface to the networking hardware. </p>
<p>For example, the following image shows information of network interface <code>eth0</code>: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.230.49  netmask 255.255.240.0  broadcast 192.168.239.255</span><br><span class="line">        inet6 fe80::215:5dff:fefb:e31f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:fb:e3:1f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 260  bytes 87732 (87.7 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 178  bytes 29393 (29.3 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>Let’s bind the sniffer to <code>eth0</code> as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind to eth0 interface only</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *opt;</span><br><span class="line">opt = <span class="string">&quot;eth0&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_BINDTODEVICE, opt, <span class="built_in">strlen</span>(opt) + <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt bind device&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We do it by calling the <code>setsockopt</code> system call. I leave the detailed usage of it to you. </p>
<p>Now the sniffer only captures network packets received on the specified network card. </p>
<h3 id="Non-promiscuous-and-promiscuous-mode"><a href="#Non-promiscuous-and-promiscuous-mode" class="headerlink" title="Non-promiscuous and promiscuous mode"></a>Non-promiscuous and promiscuous mode</h3><p>By default, each network card minds its own business and reads only the frames directed to it. It means that the network card discards all the packets that do not contain its own MAC address, which is called <code>non-promiscuous</code> mode. </p>
<p>Next, let us make the sniffer can work in <code>promiscuous</code> mode. In this way, it retrieves all the data packets. Even the ones that are not addressed to its host. </p>
<p>To set a network interface to promiscuous mode, all we have to do is issue the <code>ioctl()</code> system call to an open socket on that interface.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the network card in promiscuos mode*/</span></span><br><span class="line"><span class="comment">// An ioctl() request has encoded in it whether the argument is an in parameter or out parameter</span></span><br><span class="line"><span class="comment">// SIOCGIFFLAGS	0x8913		/* get flags			*/</span></span><br><span class="line"><span class="comment">// SIOCSIFFLAGS	0x8914		/* set flags			*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ethreq</span>;</span></span><br><span class="line"><span class="built_in">strncpy</span>(ethreq.ifr_name, <span class="string">&quot;eth0&quot;</span>, IF_NAMESIZE);</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCGIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ethreq.ifr_flags |= IFF_PROMISC;</span><br><span class="line"><span class="keyword">if</span> (ioctl(sock, SIOCSIFFLAGS, &amp;ethreq) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ioctl</code> stands for <strong>I/O control</strong>, which manipulates the underlying device parameters of specific files. <code>ioctl</code> takes three arguments: </p>
<ul>
<li>The first argument must be an open file descriptor. We use the socket file descriptor bound to the network interface in our case.</li>
<li>The second argument is a device-dependent request code. You can see we called <code>ioctl</code> twice. The first call uses request code <em>SIOC<strong>G</strong>IFFLAGS</em> to get flags, and the second call uses request code <em>SIOC<strong>S</strong>IFFLAGS</em> to set flags. Do not be fooled by these two constant values, which are spelled alike.</li>
<li>The third argument is for returning information to the requesting process.  </li>
</ul>
<p>Now the sniffer can retrieve all the data packets received on the network card, no matter to which host the packets are addressed.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>This article examined what <code>PF_PACKET</code> socket is, how it works and why the application can get raw Ethernet packets. Furthermore, we discussed how to bind the sniffer to one specific network interface and how can make the sniffer work in the promiscuous mode. The next article will examine how to implement the packet filter functionality, which is very useful to a network sniffer. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" data-id="clvv1t4ih001hc8mm9oz04asy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-stack-smashing-detect-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/07/stack-smashing-detect-in-c/" class="article-date">
  <time datetime="2022-02-07T05:12:08.000Z" itemprop="datePublished">2022-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/07/stack-smashing-detect-in-c/">stack-smashing-detect-in-c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/02/07/stack-smashing-detect-in-c/" data-id="clvv1t4it002rc8mm51654es1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-arp-spoof" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/28/how-to-implement-arp-spoof/" class="article-date">
  <time datetime="2022-01-28T09:29:48.000Z" itemprop="datePublished">2022-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/28/how-to-implement-arp-spoof/">how-to-implement-arp-spoof</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/01/28/how-to-implement-arp-spoof/" data-id="clvv1t4ig001dc8mmfh8b90hd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-extern-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/20/extern-in-c/" class="article-date">
  <time datetime="2022-01-20T03:47:18.000Z" itemprop="datePublished">2022-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/20/extern-in-c/">extern-in-c</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/01/20/extern-in-c/" data-id="clvv1t4i3000fc8mm6v238a61" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binary-Search-Tree-delete-balanced-performance/" rel="tag">Binary Search Tree, delete, balanced, performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Foundation-Scholarship-LIFT/" rel="tag">Linux Foundation, Scholarship, LIFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scalability-AWS/" rel="tag">Scalability, AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" rel="tag">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnet-GC-memory-leak-WinDbg/" rel="tag">dotnet, GC, memory leak, WinDbg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Binary-Search-Tree-delete-balanced-performance/" style="font-size: 10px;">Binary Search Tree, delete, balanced, performance</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-Foundation-Scholarship-LIFT/" style="font-size: 10px;">Linux Foundation, Scholarship, LIFT</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/Scalability-AWS/" style="font-size: 10px;">Scalability, AWS</a> <a href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" style="font-size: 10px;">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/dotnet-GC-memory-leak-WinDbg/" style="font-size: 10px;">dotnet, GC, memory leak, WinDbg</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/01/dotnet-gc-memory-leak-windbg/">Diagnose Memory Leaks in .NET Applications with WinDbg: A Hands-on Approach</a>
          </li>
        
          <li>
            <a href="/2023/06/09/lift-scholarship-program/">Linux Foundation Scholarship</a>
          </li>
        
          <li>
            <a href="/2023/04/09/understand-more-aws-service-by-negative-cases/">Scalability Lessons Learned from Amazon Return to The Monolith</a>
          </li>
        
          <li>
            <a href="/2023/03/20/guide-to-service-fabric-architecture/">Build Microservices with Service Fabric: A Hands-on Approach</a>
          </li>
        
          <li>
            <a href="/2023/02/13/note-on-red-black-tree/">Understand Red Black Tree: part one - background</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
    <a href="/book-reviews" class="mobile-nav-link">Book Review</a>
  
    <a href="/solopreneur" class="mobile-nav-link">Solopreneur</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>