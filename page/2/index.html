<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/page/2/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-understand-http-1-1-client-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/01/understand-http-1-1-client-golang/" class="article-date">
  <time datetime="2021-12-01T02:02:34.000Z" itemprop="datePublished">2021-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/01/understand-http-1-1-client-golang/">How  HTTP1.1 protocol is implemented in Golang net/http package: part one - request workflow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this article, I’ll write about one topic: how to implement the HTTP protocol. I keep planning to write about this topic for a long time. In my previous articles, I already wrote several articles about HTTP protocol:</p>
<ul>
<li><a href="https://baoqger.github.io/2021/07/31/how-to-implement-simple-http-server-golang/">How to write a Golang HTTP server with Linux system calls</a></li>
<li><a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">Understand how HTTP/1.1 persistent connection works based on Golang: part one - sequential requests</a></li>
<li><a href="https://baoqger.github.io/2021/10/27/understand-http1-1-persitent-connection-golang-part2/">Understand how HTTP/1.1 persistent connection works based on Golang: part two - concurrent requests</a></li>
</ul>
<p>I recommend you to read these articles above before this one. </p>
<p>As you know, HTTP protocol is in the application layer, which is the closest one to the end-user in the protocol stack. </p>
<p>So relatively speaking, HTTP protocol is not as mysterious as other protocols in the lower layers of this stack. Software engineers use HTTP every day and take it for granted. Have you ever thought about how we can implement a fully functional HTTP protocol library? </p>
<p>It turns out to be a very complex and big work in terms of software engineering. Frankly speaking, I can’t work it out by myself in a short period. So in this article, we’ll try to understand how to do it by investigating Golang <code>net/http</code> package as an example. We’ll read a lot of source code and draw diagrams to help your understanding of the source code.</p>
<p><strong>Note</strong> HTTP protocol itself has evolved a lot from <code>HTTP1.1</code> to <code>HTTP2</code> and <code>HTTP3</code>, not to mention <code>HTTPS</code>. In this article, we’ll focus on the mechanism of <code>HTTP1.1</code>, but what you learned here can help you understand other new versions of HTTP protocol. </p>
<p><strong>Note</strong> HTTP protocol is on the basis of client-server model. This article will focus on the client-side. For the HTTP server part, I’ll write another article next. </p>
<h3 id="Main-workflow-of-http-Client"><a href="#Main-workflow-of-http-Client" class="headerlink" title="Main workflow of http.Client"></a>Main workflow of http.Client</h3><p>HTTP client’s request starts from the application’s call to <code>Get</code> method of <code>net/http</code> package, and ends by writing the HTTP message to the TCP socket. The whole workflow can be simplified to the following diagram:   </p>
<img src="/images/golang-http1-1-client-flow.png" title="golang client flow" width="800px" height="600px">

<p>First, the public <code>Get</code> method calls Get method of <code>DefaultClient</code>, which is a global variable of type <code>Client</code>,  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DefaultClient.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultClient is a global variable in net/http package</span></span><br><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct type Client</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transport RoundTripper</span><br><span class="line"></span><br><span class="line">	CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">	Jar CookieJar</span><br><span class="line"></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, <code>NewRequest</code> method is used to construct a new request of type <code>Request</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span> &#123;</span><br><span class="line">	req, err := NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(*Request, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewRequestWithContext(context.Background(), method, url, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’ll not show the function body of <code>NewRequestWithContext</code>, since it’s very long. But only paste the block of code for actually building the <code>Request</code> object as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req := &amp;Request&#123;</span><br><span class="line">    <span class="comment">// omit some code </span></span><br><span class="line">    Proto:      <span class="string">"HTTP/1.1"</span>, <span class="comment">// the default HTTP protocol version is set to 1.1</span></span><br><span class="line">    ProtoMajor: <span class="number">1</span>,</span><br><span class="line">    ProtoMinor: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// omit some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that by default the HTTP protocol version is set to 1.1. If you want to send HTTP2 request, then you need other solutions, and I’ll write about it in other articles.  </p>
<p>Next, <code>Do</code> method is called, which delegates the work to the private <code>do</code> method.  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do</code> method handles the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" target="_blank" rel="noopener"><code>HTTP redirect</code></a> behavior, which is very interesting. But since the code block is too long, I’ll not show its function body here. You can refer to the source code of it <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.3:src/net/http/client.go;drc=refs%2Ftags%2Fgo1.17.3;l=598" target="_blank" rel="noopener">here</a>.</p>
<p>Next, <code>send</code> method of Client is called which goes as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">			req.AddCookie(cookie)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// call send method here</span></span><br><span class="line">	resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It handles cookies for the request, then calls the private method <code>send</code> with three parameters.</p>
<p>We already talked about the first parameter above. Let’s take a look at the second parameter <code>c.transport()</code> as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.Transport</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is extremely important for HTTP client workflow. Let’s examine how it works bit by bit.  First of all, it’s type of <code>RoundTripper</code> interface. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this interface is defined inside client.go file </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// RoundTrip executes a single HTTP transaction, returning</span></span><br><span class="line">	<span class="comment">// a Response for the provided Request.</span></span><br><span class="line">	RoundTrip(*Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RoundTripper</code> interface only defines one method <code>RoundTrip</code>, all right. </p>
<p>If you don’t have any special settings, the <code>DefaultTransport</code> will be used for <code>c.Transport</code> above. </p>
<p>The <code>DefaultTransport</code> is going as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defined in transport.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">	Proxy: ProxyFromEnvironment,</span><br><span class="line">	DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">		Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">		KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">		DualStack: <span class="literal">true</span>,</span><br><span class="line">	&#125;).DialContext,</span><br><span class="line">	ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">	MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">	IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">	TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">	ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that its actual type  is <code>Transport</code> as below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">	idleMu       sync.Mutex</span><br><span class="line">	closeIdle    <span class="keyword">bool</span>                                <span class="comment">// user has requested to close all idle conns</span></span><br><span class="line">	idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">	idleConnWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue  <span class="comment">// waiting getConns</span></span><br><span class="line">	idleLRU      connLRU</span><br><span class="line">	reqMu       sync.Mutex</span><br><span class="line">	reqCanceler <span class="keyword">map</span>[cancelKey]<span class="function"><span class="keyword">func</span><span class="params">(error)</span></span></span><br><span class="line">	altMu    sync.Mutex   <span class="comment">// guards changing altProto only</span></span><br><span class="line">	altProto atomic.Value <span class="comment">// of nil or map[string]RoundTripper, key is URI scheme</span></span><br><span class="line">	connsPerHostMu   sync.Mutex</span><br><span class="line">	connsPerHost     <span class="keyword">map</span>[connectMethodKey]<span class="keyword">int</span></span><br><span class="line">	connsPerHostWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue <span class="comment">// waiting getConns</span></span><br><span class="line">	Proxy <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span></span></span><br><span class="line">	DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">	Dial <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">	DialTLSContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">	DialTLS <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">	TLSClientConfig *tls.Config</span><br><span class="line">	TLSHandshakeTimeout time.Duration</span><br><span class="line">	DisableKeepAlives <span class="keyword">bool</span></span><br><span class="line">	DisableCompression <span class="keyword">bool</span></span><br><span class="line">	MaxIdleConns <span class="keyword">int</span></span><br><span class="line">	MaxIdleConnsPerHost <span class="keyword">int</span></span><br><span class="line">	MaxConnsPerHost <span class="keyword">int</span></span><br><span class="line">	IdleConnTimeout time.Duration</span><br><span class="line">	ResponseHeaderTimeout time.Duration</span><br><span class="line">	ExpectContinueTimeout time.Duration</span><br><span class="line">	TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(authority <span class="keyword">string</span>, c *tls.Conn)</span> <span class="title">RoundTripper</span></span></span><br><span class="line">	ProxyConnectHeader Header</span><br><span class="line">	MaxResponseHeaderBytes <span class="keyword">int64</span></span><br><span class="line">	WriteBufferSize <span class="keyword">int</span></span><br><span class="line">	ReadBufferSize <span class="keyword">int</span></span><br><span class="line">	nextProtoOnce      sync.Once</span><br><span class="line">	h2transport        h2Transport <span class="comment">// non-nil if http2 wired up</span></span><br><span class="line">	tlsNextProtoWasNil <span class="keyword">bool</span>        <span class="comment">// whether TLSNextProto was nil when the Once fired</span></span><br><span class="line">	ForceAttemptHTTP2 <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I list the full content of <code>Transport</code> struct here, although it contains many fields, and many of them will not be discussed in this article.</p>
<p>As we just mentioned, <code>Transport</code> is type of <code>RoundTripper</code> interface, it must implement the method <code>RoundTrip</code>, right? </p>
<p>You can find the <code>RoundTrip</code> method implementation of <code>Transport</code> struct type in <strong>roundtrip.go</strong> file as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip method in roundtrip.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the beginning, I thought this method should be included inside <code>transport.go</code> file, but it is defined inside another file.  </p>
<p>Let’s back to the <code>send</code> method which takes <code>c.Transport</code> as the second argument:  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send method in client.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">	req := ireq <span class="comment">// req is either the original request, or a modified fork</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: no Client.Transport or DefaultTransport"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: nil Request.URL"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.RequestURI != <span class="string">""</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">"http: Request.RequestURI can't be set in client requests"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// forkReq forks req into a shallow clone of ireq the first</span></span><br><span class="line">	<span class="comment">// time it's called.</span></span><br><span class="line">	forkReq := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ireq == req &#123;</span><br><span class="line">			req = <span class="built_in">new</span>(Request)</span><br><span class="line">			*req = *ireq <span class="comment">// shallow clone</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Most the callers of send (Get, Post, et al) don't need</span></span><br><span class="line">	<span class="comment">// Headers, leaving it uninitialized. We guarantee to the</span></span><br><span class="line">	<span class="comment">// Transport that this has been initialized, though.</span></span><br><span class="line">	<span class="keyword">if</span> req.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		forkReq()</span><br><span class="line">		req.Header = <span class="built_in">make</span>(Header)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> u := req.URL.User; u != <span class="literal">nil</span> &amp;&amp; req.Header.Get(<span class="string">"Authorization"</span>) == <span class="string">""</span> &#123;</span><br><span class="line">		username := u.Username()</span><br><span class="line">		password, _ := u.Password()</span><br><span class="line">		forkReq()</span><br><span class="line">		req.Header = cloneOrMakeHeader(ireq.Header)</span><br><span class="line">		req.Header.Set(<span class="string">"Authorization"</span>, <span class="string">"Basic "</span>+basicAuth(username, password))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !deadline.IsZero() &#123;</span><br><span class="line">		forkReq()</span><br><span class="line">	&#125;</span><br><span class="line">	stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line"></span><br><span class="line">	resp, err = rt.RoundTrip(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		stopTimer()</span><br><span class="line">		<span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">"RoundTripper returned a response &amp; error; ignoring response"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tlsErr, ok := err.(tls.RecordHeaderError); ok &#123;</span><br><span class="line">			<span class="comment">// If we get a bad TLS record header, check to see if the</span></span><br><span class="line">			<span class="comment">// response looks like HTTP and give a more helpful error.</span></span><br><span class="line">			<span class="comment">// See golang.org/issue/11111.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">string</span>(tlsErr.RecordHeader[:]) == <span class="string">"HTTP/"</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">"http: server gave HTTP response to HTTPS client"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">"http: RoundTripper implementation (%T) returned a nil *Response with a nil error"</span>, rt)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.Body == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// The documentation on the Body field says “The http Client and Transport</span></span><br><span class="line">		<span class="comment">// guarantee that Body is always non-nil, even on responses without a body</span></span><br><span class="line">		<span class="comment">// or responses with a zero-length body.” Unfortunately, we didn't document</span></span><br><span class="line">		<span class="comment">// that same constraint for arbitrary RoundTripper implementations, and</span></span><br><span class="line">		<span class="comment">// RoundTripper implementations in the wild (mostly in tests) assume that</span></span><br><span class="line">		<span class="comment">// they can use a nil Body to mean an empty one (similar to Request.Body).</span></span><br><span class="line">		<span class="comment">// (See https://golang.org/issue/38095.)</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// If the ContentLength allows the Body to be empty, fill in an empty one</span></span><br><span class="line">		<span class="comment">// here to ensure that it is non-nil.</span></span><br><span class="line">		<span class="keyword">if</span> resp.ContentLength &gt; <span class="number">0</span> &amp;&amp; req.Method != <span class="string">"HEAD"</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">"http: RoundTripper implementation (%T) returned a *Response with content length %d but a nil Body"</span>, rt, resp.ContentLength)</span><br><span class="line">		&#125;</span><br><span class="line">		resp.Body = ioutil.NopCloser(strings.NewReader(<span class="string">""</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !deadline.IsZero() &#123;</span><br><span class="line">		resp.Body = &amp;cancelTimerBody&#123;</span><br><span class="line">			stop:          stopTimer,</span><br><span class="line">			rc:            resp.Body,</span><br><span class="line">			reqDidTimeout: didTimeout,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At <strong>line 50</strong> of <code>send</code> method above: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err = rt.RoundTrip(req)</span><br></pre></td></tr></table></figure>

<p><code>RoundTrip</code> method is called to send the request. Based on the comments in the source code, you can understand it in the following way:</p>
<ul>
<li>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</li>
</ul>
<p>Next, let’s go to <code>roundTrip</code> method of <code>Transport</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundTrip method in transport.go, which is called by RoundTrip method internally </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roundTrip implements a RoundTripper over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">	ctx := req.Context()</span><br><span class="line">	trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: nil Request.URL"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: nil Request.Header"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	scheme := req.URL.Scheme</span><br><span class="line">	isHTTP := scheme == <span class="string">"http"</span> || scheme == <span class="string">"https"</span></span><br><span class="line">	<span class="keyword">if</span> isHTTP &#123;</span><br><span class="line">		<span class="keyword">for</span> k, vv := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">			<span class="keyword">if</span> !httpguts.ValidHeaderFieldName(k) &#123;</span><br><span class="line">				req.closeBody()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid header field name %q"</span>, k)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> vv &#123;</span><br><span class="line">				<span class="keyword">if</span> !httpguts.ValidHeaderFieldValue(v) &#123;</span><br><span class="line">					req.closeBody()</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid header field value %q for key %v"</span>, v, k)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	origReq := req</span><br><span class="line">	cancelKey := cancelKey&#123;origReq&#125;</span><br><span class="line">	req = setupRewindBody(req)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> altRT := t.alternateRoundTripper(req); altRT != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol &#123;</span><br><span class="line">			<span class="keyword">return</span> resp, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		req, err = rewindBody(req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isHTTP &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, badStringError(<span class="string">"unsupported protocol scheme"</span>, scheme)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.Method != <span class="string">""</span> &amp;&amp; !validMethod(req.Method) &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"net/http: invalid method %q"</span>, req.Method)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.URL.Host == <span class="string">""</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: no Host in request URL"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// treq gets modified by roundTrip, so we need to recreate for each retry.</span></span><br><span class="line">		treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;</span><br><span class="line">		cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the cached or newly-created connection to either the</span></span><br><span class="line">		<span class="comment">// host (for http or https), the http proxy, or the http proxy</span></span><br><span class="line">		<span class="comment">// pre-CONNECTed to https server. In any case, we'll be ready</span></span><br><span class="line">		<span class="comment">// to send it requests.</span></span><br><span class="line">		pconn, err := t.getConn(treq, cm)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.setReqCanceler(cancelKey, <span class="literal">nil</span>)</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> resp *Response</span><br><span class="line">		<span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// HTTP/2 path.</span></span><br><span class="line">			t.setReqCanceler(cancelKey, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">			resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resp, err = pconn.roundTrip(treq)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			resp.Request = origReq</span><br><span class="line">			<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Failed. Clean up and determine whether to retry.</span></span><br><span class="line">		<span class="keyword">if</span> http2isNoCachedConnError(err) &#123;</span><br><span class="line">			<span class="keyword">if</span> t.removeIdleConn(pconn) &#123;</span><br><span class="line">				t.decConnsPerHost(pconn.cacheKey)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !pconn.shouldRetryRequest(req, err) &#123;</span><br><span class="line">			<span class="comment">// Issue 16465: return underlying net.Conn.Read error from peek,</span></span><br><span class="line">			<span class="comment">// as we've historically done.</span></span><br><span class="line">			<span class="keyword">if</span> e, ok := err.(transportReadFromServerError); ok &#123;</span><br><span class="line">				err = e.err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		testHookRoundTripRetried()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Rewind the body if we're able to.</span></span><br><span class="line">		req, err = rewindBody(req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are three key points:</p>
<ul>
<li>at <strong>line 70</strong>, a new variable of type <code>transportRequest</code>, which embeds <code>Request</code>, is created.  </li>
<li>at <strong>line 81</strong>, <code>getConn</code> method is called, which implements the cached <code>connection pool</code> to support the <code>persistent connection</code> mode. Of course, if no cached connection is available, a new connection will be created and added to the connection pool. I will explain this behavior in detail next section. </li>
<li>from <strong>line 89</strong> to <strong>line 95</strong>, <code>pconn.roundTrip</code> is called. The name of variable <code>pconn</code> is self-explaining which means it is type of <code>persistConn</code>. </li>
</ul>
<p><code>transportRequest</code> is passed as parameter to <code>getConn</code> method, which returns <code>pconn</code>. <code>pconn.roundTrip</code> is called to execute the HTTP request. we have covered all the steps in the above workflow diagram. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this first article of this series, we talked about the workflow of sending an HTTP request step by step. And I’ll discuss how to send the HTTP message to the TCP stack in the second article.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/01/understand-http-1-1-client-golang/" data-id="cl458i8ca002e94mm2ai68u9i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http1-1-persitent-connection-golang-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/27/understand-http1-1-persitent-connection-golang-part2/" class="article-date">
  <time datetime="2021-10-27T09:51:29.000Z" itemprop="datePublished">2021-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/27/understand-http1-1-persitent-connection-golang-part2/">Understand how HTTP/1.1 persistent connection works based on Golang: part two - concurrent requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">last post</a>, I show you how HTTP/1.1 persistent connection works in a simple demo app, which sends sequential requests.</p>
<p>We observe the underlying TCP connection behavior based on the network analysis tool: <code>netstat</code> and <code>tcpdump</code>.</p>
<p>In this article, I will modify the demo app and make it send concurrent requests. In this way, we can have more understanding about HTTP/1.1’s persistent connection.  </p>
<h3 id="Concurrent-requests"><a href="#Concurrent-requests" class="headerlink" title="Concurrent requests"></a>Concurrent requests</h3><p>The <a href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/concurrent/non-persistent-connection/non-persistent-connection-concurrent.go" target="_blank" rel="noopener">demo code</a> goes as follows:  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">(index <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := http.Get(<span class="string">"http://localhost:8080/"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Error: %v"</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// fully read the response body</span></span><br><span class="line">		resp.Body.Close()                  <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">"HTTP request #%v in Goroutine #%v"</span>, counter, index)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> startHTTPRequest(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We create 10 goroutines, and each goroutine sends 10 sequential requests concurrently. </p>
<p><strong>Note</strong>: In HTTP/1.1 protocol, concurrent requests will establish multiple TCP connections. That’s the restriction of HTTP/1.1, the way to enhance it is using <code>HTTP/2</code> which can multiplex one TCP connection for multiple parallel HTTP connections. <code>HTTP/2</code> is not in the scope of this post. I will talk about it in another article. </p>
<p>Note that in the above demo, we have fully read the response body and closed it, and based on the discussion in <a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">last article</a>, the HTTP requests should work in the persistent connection model. </p>
<p>Before we use the network tool to analyze the behavior, let’s imagine how many TCP connections will be established. As there are 10 concurrent goroutines, 10 TCP connections should be established, and all the HTTP requests should re-use these 10 TCP connections, right? That’s our expectation. </p>
<p>Next, let’s verify our expectation with <code>netstat</code> as follows: </p>
<img src="/images/netstat-concurrent-non-persistent.png" title="tcp termination" width="600px" height="400px">

<p>It shows that the number of TCP connections is much more than 10. The persistent connection does not work as we expect. </p>
<p>After reading the source code of <code>net/http</code> package, I find the following hints: </p>
<p>The <code>Client</code> is defined inside <a href="https://golang.org/src/net/http/client.go" target="_blank" rel="noopener">client.go</a> which is the type for HTTP client, and <code>Transport</code> is one of the properties.  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transport RoundTripper</span><br><span class="line"></span><br><span class="line">	CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">	Jar CookieJar</span><br><span class="line"></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is defined in <a href="https://golang.org/src/net/http/transport.go" target="_blank" rel="noopener">transport.go</a> like this: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultTransport is the default implementation of Transport and is</span></span><br><span class="line"><span class="comment">// used by DefaultClient. It establishes network connections as needed</span></span><br><span class="line"><span class="comment">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span></span><br><span class="line"><span class="comment">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span></span><br><span class="line"><span class="comment">// $no_proxy) environment variables.</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">	Proxy: ProxyFromEnvironment,</span><br><span class="line">	DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">		Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">		KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">	&#125;).DialContext,</span><br><span class="line">	ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">	MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">	IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">	TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">	ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultMaxIdleConnsPerHost is the default value of Transport's</span></span><br><span class="line"><span class="comment">// MaxIdleConnsPerHost.</span></span><br><span class="line"><span class="keyword">const</span> DefaultMaxIdleConnsPerHost = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is type of  <code>RoundTripper</code>, which is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request. <code>RoundTripper</code> is a very important structure in <code>net/http</code> package, we’ll review (and analyze) the source code in the next article. In this article, we’ll not discuss the details. </p>
<p>Note that there are two parameters of <code>Transport</code>: </p>
<ul>
<li><strong>MaxIdleConns</strong>: controls the maximum number of idle (keep-alive) connections across all hosts.</li>
<li><strong>MaxIdleConnsPerHost</strong>: controls the maximum idle (keep-alive) connections to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used.</li>
</ul>
<p>By default, MaxIdleConns is <strong>100</strong> and MaxIdleConnsPerHost is <strong>2</strong>.</p>
<p>In our demo case, ten goroutines send requests to the same host (which is localhost:8080). Although MaxIdleConns is 100, but <strong>only 2 idle connections can be cached</strong> for this host because MaxIdleConnsPerHost is 2. That’s why you saw much more TCP connections are established. </p>
<p>Based on this analysis, let’s refactor the code as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	httpClient *http.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	httpClient = &amp;http.Client&#123;</span><br><span class="line">		Transport: &amp;http.Transport&#123;</span><br><span class="line">			MaxIdleConnsPerHost: <span class="number">10</span>, <span class="comment">// set connection pool size for each host</span></span><br><span class="line">			MaxIdleConns:        <span class="number">100</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">(index <span class="keyword">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := httpClient.Get(<span class="string">"http://localhost:8080/"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Error: %v"</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// fully read the response body</span></span><br><span class="line">		resp.Body.Close()                  <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">"HTTP request #%v in Goroutine #%v"</span>, counter, index)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> startHTTPRequest(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This time we don’t use the default httpClient, instead we create a customized client which sets MaxIdleConnsPerHost to be <strong>10</strong>. This means the size of the connection pool is changed to 10, which can cache 10 idle TCP connections for each host.</p>
<p>Verify the behavior with <code>netstat</code> again: </p>
<img src="/images/netstat-concurrent-persistent.png" title="tcp termination" width="600px" height="400px">

<p>Now the result is what we expect. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we discussed how to make HTTP/1.1 persistent connection work in a concurrent case by tunning the parameters for the connection pool. In the next article, let’s review the source code to study how to implement HTTP client.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/27/understand-http1-1-persitent-connection-golang-part2/" data-id="cl458i8cb002h94mma2qr73d3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http1-1-persistent-connection-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/25/understand-http1-1-persistent-connection-golang/" class="article-date">
  <time datetime="2021-10-25T03:11:28.000Z" itemprop="datePublished">2021-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/25/understand-http1-1-persistent-connection-golang/">Understand how HTTP/1.1 persistent connection works based on Golang: part one - sequential requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Initially, <code>HTTP</code> was a single request-and-response model. An <code>HTTP</code> client opens the <code>TCP</code> connection, requests a resource, gets the response, and the connection is closed. And establishing and terminating each <code>TCP</code> connection is a resource-consuming operation (in detail, you can refer to my previous <a href="https://baoqger.github.io/2019/07/14/why-tcp-four-way-handshake/">article</a>). As the web application becomes more and more complex, displaying a single page may require several HTTP requests, too many TCP connection operations will have a bad impact on the performance. </p>
<img src="/images/short-lived-connection.png" title="tcp termination" width="400px" height="300px">

<p>So <code>persistent-connection</code> (which is also called <code>keep-alive</code>) model is created in <code>HTTP/1.1</code> protocol. In this model, TCP connections keep open between several successive requests, and in this way, the time needed to open new connections will be reduced. </p>
<img src="/images/persistent-http.png" title="tcp termination" width="400px" height="300px">

<p>In this article, I will show you how <code>persistent connection</code> works based on a Golang application. We will do some experiments based on the demo app, and verify the TCP connection behavior with some popular network packet analysis tools. In short, After reading this article, you will learn:</p>
<ul>
<li>Golang <code>http.Client</code> usage (and a little bit source code analysis)</li>
<li>network analysis with <code>netstat</code> and <code>tcpdump</code></li>
</ul>
<p>You can find the demo Golang application in this Github <a href="https://github.com/baoqger/http-persistent-connection-golang" target="_blank" rel="noopener">repo</a>.</p>
<h3 id="Sequential-requests"><a href="#Sequential-requests" class="headerlink" title="Sequential requests"></a>Sequential requests</h3><p>Let’s start from the simple case where the client keeps sending <code>sequential</code> requests to the server. The <a href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/sequence/non-persistent-connection/non-persistent-connection.go" target="_blank" rel="noopener">code</a> goes as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		_, err := http.Get(<span class="string">"http://localhost:8080/"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Error: %v"</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">"HTTP request #%v"</span>, counter)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line"></span><br><span class="line">	startHTTPRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We start an HTTP server in a Goroutine, and keep sending ten sequential requests to it. Right? Let’s run the application and check the numbers and status of TCP connections.</p>
<p>After running the above code, you can see the following output: </p>
<img src="/images/sequential-request.png" title="tcp termination" width="800px" height="600px">

<p>When the application stops running, we can run the following <code>netstat</code> command: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n  | grep 8080</span><br></pre></td></tr></table></figure>

<p>The TCP connections are listed as follows:</p>
<img src="/images/sequential-request-netstat.png" title="tcp termination" width="800px" height="600px">

<p>Obviously, the 10 HTTP requests are not persistent since 10 TCP connections are opened. </p>
<p><strong>Note</strong>: the last column of <code>netstat</code> shows the state of TCP connection. The state of TCP connection termination process can be explained with the following image: </p>
<img src="/images/state-tcp-connection.png" title="state tcp termination" width="600px" height="400px">

<p>I will not cover the details in this article. But we need to understand the meaning of <code>TIME-WAIT</code>. </p>
<p>In the <code>four-way handshake</code> process, the client will send the <code>ACK</code> packet to terminate the connection, but the state of TCP can’t immediately go to <code>CLOSED</code>. The client has to wait for some time and the state in this waiting process is called <code>TIME-WAIT</code>. The TCP connection needs this <code>TIME-WAIT</code> state for two main reasons. </p>
<ul>
<li>The first is to provide enough time that the <code>ACK</code> is received by the other peer. </li>
<li>The second is to provide a buffer period between the end of current connection and any subsequent ones. If not for this period, it’s possible that packets from different connections could be mixed. In detail, you can refer to this <a href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-3.htm" target="_blank" rel="noopener">book</a>.</li>
</ul>
<p>In our demo application case, if you wait for a while after the program stops, and run the <code>netstat</code> command again then no TCP connection will be listed in the output since they’re all closed. </p>
<p>Another tool to verify the TCP connections is <code>tcpdump</code>, which can capture every network packet send to your machine. In our case, you can run the following <code>tcpdump</code> command: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any -n host localhost</span><br></pre></td></tr></table></figure>

<p>It will capture all the network packets send from or to the localhost (we’re running the server in localhost, right?). <code>tcpdump</code> is a great tool to help you understand the network, you can refer to its <a href="https://www.tcpdump.org/" target="_blank" rel="noopener">document</a> for more help.</p>
<p><strong>Note</strong>: in our demo code above, we send 10 HTTP requests in sequence, which will make the capture result from <code>tcpdump</code> too long. So I modified the for loop to only send 2 sequential requests, which is enough to verify the behavior of <code>persistent connection</code>. The result goes as follows: </p>
<img src="/images/tcpdump-non-persistent.png" title="tcpdump" width="1200px" height="1000px">

<p>In <code>tcpdump</code> output, the <code>Flag [S]</code> represents <code>SYN</code> flag, which is used to establish the TCP connection. The above snapshot contains two <code>Flag [S]</code> packets. The first <code>Flag [S]</code> is triggered by the first HTTP call, and the following packets are HTTP request and response. Then you can see the second <code>Flag [S]</code> packet to open a new TCP connection, which means the second HTTP request is not <code>persistent connection</code> as we hope. </p>
<p>Next step, let’s see how to make HTTP work as a persistent connection in Golang. </p>
<p>In fact,this is a well known issue in Golang ecosystem, you can find the information in the <a href="https://pkg.go.dev/net/http#Client" target="_blank" rel="noopener">official document</a>:</p>
<ul>
<li>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client’s underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent “keep-alive” request.</li>
</ul>
<p>The fix will be straightforward by just adding two more lines of code as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"Hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := http.Get(<span class="string">"http://localhost:8080/"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Error: %v"</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// read the response body</span></span><br><span class="line">		resp.Body.Close() <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">"HTTP request #%v"</span>, counter)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPServer()</span><br><span class="line"></span><br><span class="line">	startHTTPRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let’s verify by running <code>netstat</code> command, the result goes as follows: </p>
<img src="/images/netstat-persistent.png" title="tcpdump" width="800px" height="600px">

<p>This time 10 sequential HTTP requests establish only one TCP connection. This behavior is just what we hope: <code>persistent connection</code>.  </p>
<p>We can double verify it by doing the same experiment as above: run two HTTP requests in sequence and capture packets with <code>tcpdump</code>: </p>
<img src="/images/tcpdump-persistent.png" title="tcpdump" width="1200px" height="1000px">

<p>This time, only one <code>Flag [S]</code> packet is there! The two sequential HTTP request re-use the same underlying TCP connection. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we showed how HTTP <code>persistent connection</code> works in the case of sequential requests. In the next article, we can show you the case of concurrent requests. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/" data-id="cl458i8cb002i94mm5mi661e3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-why-only-13-dns-root-server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/12/why-only-13-dns-root-server/" class="article-date">
  <time datetime="2021-10-12T05:48:41.000Z" itemprop="datePublished">2021-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/12/why-only-13-dns-root-server/">why-only-13-dns-root-server</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/12/why-only-13-dns-root-server/" data-id="cl458i8cc002k94mmgk8v5t2n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-packet-sniffer-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/08/packet-sniffer-golang/" class="article-date">
  <time datetime="2021-10-08T03:37:36.000Z" itemprop="datePublished">2021-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/08/packet-sniffer-golang/">packet-sniffer-golang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/08/packet-sniffer-golang/" data-id="cl458i8c7002194mm8zzngtq0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-build-packet-sniffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/08/how-to-build-packet-sniffer/" class="article-date">
  <time datetime="2021-10-08T03:36:45.000Z" itemprop="datePublished">2021-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/08/how-to-build-packet-sniffer/">how-to-build-packet-sniffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/08/how-to-build-packet-sniffer/" data-id="cl458i8br000u94mm4sro2deb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cgo-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/25/cgo-golang/" class="article-date">
  <time datetime="2021-08-25T08:14:36.000Z" itemprop="datePublished">2021-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/25/cgo-golang/">cgo-golang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/08/25/cgo-golang/" data-id="cl458i8bd000294mm0gid7e4p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-win-wsl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/06/win-wsl/" class="article-date">
  <time datetime="2021-08-06T01:19:41.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/06/win-wsl/">New way to set up Linux development environment in Windows with WSL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>I like system programming which can allow you to touch more software development skills in the bottom level.  </p>
<p>Linux is the perfect platform when you want to do system programming. But if you’re using a computer running Windows on it, then you have to spend some time to set up the Linux development environment. Generally speaking there are two traditional ways to do that: <code>virtual machine</code> and <code>dualboot</code>, both need some effort. Or you can try to do that with <code>container</code> technology, for example, I once shared one <a href="https://baoqger.github.io/2020/07/28/linux-cpp-docker/">article</a> about how to do it with <code>Docker</code>. </p>
<p>In this article, I will introduce a new and easier way to do this without too much overhead. </p>
<h3 id="Windows-Subsystem-for-Linux"><a href="#Windows-Subsystem-for-Linux" class="headerlink" title="Windows Subsystem for Linux"></a>Windows Subsystem for Linux</h3><p>The new way is <code>Windows Subsystem for Linux (WSL)</code>. I have to admit that the operating system is complex and difficult so for now I don’t know how Microsoft make <code>WSL</code> works. In details, you can refer to this <a href="https://devblogs.microsoft.com/commandline/a-deep-dive-into-how-wsl-allows-windows-to-access-linux-files/" target="_blank" rel="noopener">article</a> to learn how <code>WSL</code> allows Windows to access Linux files. In this article let’s focus on how to set it up and what kind of benefits it can provide to developers.</p>
<p>Based on the <a href="https://docs.microsoft.com/en-us/windows/wsl/about" target="_blank" rel="noopener">official document</a>, with <code>WSL</code> you can</p>
<ul>
<li>Run common command-line tools such as <code>grep</code>, <code>sed</code>, <code>awk</code>.</li>
<li>Run Bash shell scripts and GNU/Linux command-line applications including:<ul>
<li>Tools: vim, emacs, tmux.</li>
<li>Languages: NodeJS, Javascript, Python, Ruby, C/C++, C# &amp; F#, Rust, Go, etc.</li>
<li>Services: SSHD, MySQL, Apache, lighttpd, MongoDB, PostgreSQL.</li>
</ul>
</li>
<li>Install additional software using your own GNU/Linux distribution package manager.</li>
</ul>
<p>With these conditions, you can set up a completed Linux development environment. </p>
<h3 id="Install-WSL"><a href="#Install-WSL" class="headerlink" title="Install WSL"></a>Install WSL</h3><p>For detail steps to install <code>WSL</code>, you can find it on the official document. Based on my experience, I follow the document to download and install Linux Ubuntu distribution smoothly, which is much easier than settig the virtual machine.</p>
<h3 id="File-mount"><a href="#File-mount" class="headerlink" title="File mount"></a>File mount</h3><p>By default, you can also access your local machine’s file system from within the Linux Bash shell. Since your local drives are mounted under the <strong>/mnt</strong> folder of the subsystem. </p>
<p>In this way, you can develop the code with the productivity tools in Windows and build it in Linux environment.</p>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>This is another convenient point. <code>WSL</code> shares the IP address of Windows, as it is running on Windows.<br>As such you can access any ports on localhost e.g. if you had a web server running on port 8080, you could access it just by visiting <strong><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></strong> into your Windows browser.</p>
<h3 id="Set-up-the-development-environment"><a href="#Set-up-the-development-environment" class="headerlink" title="Set up the development environment"></a>Set up the development environment</h3><p>After install the Ubuntu system, I also install tools to prepare the development environment. For example, <code>GCC</code> to develop C language program as below. </p>
<img src="/images/linux-gcc.png" title="gcc in Linux" width="800px" height="600px">

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Based on my testing and experience, <code>WSL</code> can save developers’ time to set up Linux environment.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/08/06/win-wsl/" data-id="cl458i8cd002o94mm4qb59evl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-simple-http-server-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/31/how-to-implement-simple-http-server-golang/" class="article-date">
  <time datetime="2021-07-31T02:15:25.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/31/how-to-implement-simple-http-server-golang/">How to write a Golang HTTP server with Linux system calls</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><code>HTTP</code> is everywhere. As a software engineer, you’re using the <code>HTTP</code> protocol every day. Starting an <code>HTTP</code> server will be an easy task if you’re using any modern language or framework. For example, in Golang you can do that with the following lines of code:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hi"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hi"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8081"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can finish the job easily because <code>net/http</code> package implements the <code>HTTP</code> protocol completely. How can you do that without <code>net/http</code> package ? That’s the target of this article. </p>
<p><strong>Note</strong>: This article is inspired by <a href="https://joe.schafer.dev/go-server-with-syscalls/" target="_blank" rel="noopener">Joe Schafer’s post</a> a lot. My implementation has something different which totally removes dependency on Golang’s <code>net</code> package, but the idea of using <code>system call</code> in Golang to setup the TCP/IP connetion is the same. Thanks very much for Joe Schafer’s interesting post.</p>
<p>Another thing I need to mention is this article will cover many concepts, but it’s very difficult to discuss all of them in detail. To understand this article smoothly, you need some prerequisite knowledge such as <code>OSI model</code>, <code>TCP/IP stack</code>, <code>socket programming</code>, <code>HTTP protocol</code> and <code>system call</code>. I will add some explanations on these topics to help you understand this article and give some references and links to let you continue exploring more in advanced level. </p>
<h3 id="OSI-network-model"><a href="#OSI-network-model" class="headerlink" title="OSI network model"></a>OSI network model</h3><p><a href="https://en.wikipedia.org/wiki/OSI_model" target="_blank" rel="noopener"><code>OSI model</code></a> partitions the data flow in a communication system into <strong>seven abstraction layers</strong>. These layers form a protocol stack, with each layer communicating with the layer above and the layer below as follows: </p>
<img src="/images/osi_model.png" title="network" width="400px" height="300px">

<p>For example, <code>HTTP</code> is in <strong>layer 7</strong>, <code>TCP</code> is in <strong>layer 4</strong> and <code>IP</code> is in <strong>layer 3</strong>. </p>
<p>OSI is a general model, which was first specified in the early 1980s. <strong>But neither traditional nor modern networking protocols fit into this model neatly</strong>. For example, <code>TCP/IP</code> stack does not define the three upper layers: session, presentation, and application. In fact, it does not define anything above the transport layer. From the viewpoint of <code>TCP/IP</code>, everything above the transport layer is part of<br>the application. So the layered network model more  consistent with Linux (TCP/IP stack is implemented in Linux kernel) is as follows: </p>
<ul>
<li>Application Layer (telnet, ftp, http)</li>
<li>Host-to-Host Transport Layer (TCP, UDP)</li>
<li>Internet Layer (IP and routing)</li>
<li>Network Access Layer (Ethernet, wi-fi)</li>
</ul>
<p>Once again, <strong>it is important to point out that the upper layers—Layers 5, 6, and 7—are not part of the TCP/IP stack</strong>. </p>
<p>Another critical point to understand is <code>data encapsulation</code>.  The data flow goes from the bottom physical level to the highest-level representation of data in an application.</p>
<p>Each layer has administrative information that it has to keep about its own layer. It does this by adding header information to the packet it receives from the layer above, as the packet passes down. Each header contains information regarding the message contents. For example, one <code>HTTP</code> server sends data from one host to another. It uses the <code>TCP</code> protocol on top of the <code>IP</code> protocol, which may be sent over <code>Ethernet</code>. This looks like: </p>
<img src="/images/data_encapsulation.png" title="network" width="400px" height="300px">



<p>The packet transmitted over ethernet, is the bottom one. On the receiving side, these headers are removed as the packet moves up.</p>
<p>Next let’s see how <code>TCP/IP</code> stack encapsulates <code>HTTP</code> message and send it over the network through <code>socket</code>. The idea can be illustrated with the following image: </p>
<img src="/images/socket_network.png" title="network" width="600px" height="400px">

<p>I will explain how it works by writing a HTTP server from scratch, you can refer to this <a href="https://github.com/baoqger/http-server-scratch" target="_blank" rel="noopener">Github repo</a> to get all the code. </p>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p><code>TCP/IP</code> stack is originated from <a href="https://en.wikipedia.org/wiki/ARPANET" target="_blank" rel="noopener"><code>ARPANET</code></a> project, which is integrated into Unix BSD OS as the first implementation of <code>TCP/IP</code> protocols.</p>
<p>Nowadays, <code>TCP/IP</code> is still implemented in the operating system level. For Linux system, you can find the source code inside the kernel. The detailed implementation is outside the scope of this article. You can study it in this Github <a href="https://github.com/torvalds/linux/tree/master/net/ipv4" target="_blank" rel="noopener">link</a>. </p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>As I mentioned in the above sections, HTTP server is running in the application level. How it can work with <code>TCP/IP</code> stack which lives in the kernel? The answer is <code>socket</code>. </p>
<p>The <code>socket</code> interface was originally developed as part of the BSD operating system. Sockets provide an interface between the application level programs and the TCP/IP stack. Linux (or other OS) provides an API and sockets, and applications use this API to access the networking facilities in the kernel. </p>
<p>The socket interface is really TCP/IP’s window on the world. In most modern systems incorporating TCP/IP, the socket interface is the only way that applications make use of the TCP/IP suite of protocols. </p>
<p>One main advantage of sockets in Unix or Linux system is that the socket is treated as a <code>file descriptor</code>, and all the standard I/O functions work on sockets in the same way they work on a local file. File descriptor is simply an integer associated with an open file. </p>
<p>You may heard <strong>everything in Unix is a file</strong>. The file can be a network connection, a pipe, a real file in the disk, a device or anything else. So when you want to send data to another program over the Interent you will do it through a file descriptor.   </p>
<p>In our HTTP server case, <strong>it will get the request by reading data from the socket and send the response by writing data to the socket</strong>.  </p>
<p>Next, let’s review the source code to see how the HTTP server is implemented.</p>
<p>First, we need setup the TCP connection through socket, the process can be described in the following image: </p>
<img src="/images/socket_tcp.png" title="network" width="600px" height="400px">

<p>In Golang, <code>net</code> package provides all the socket related functionalities. Since this article’s purpose is writing a HTTP server from scratch, so I create a package named <strong>simplenet</strong> to provide the very basic implementation. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplenet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netSocket <span class="keyword">struct</span> &#123;</span><br><span class="line">	fd <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNetSocket</span><span class="params">(ip IP, port <span class="keyword">int</span>)</span> <span class="params">(*netSocket, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// ForkLock docs state that socket syscall requires the lock.</span></span><br><span class="line">	syscall.ForkLock.Lock()</span><br><span class="line">	<span class="comment">// AF_INET = Address Family for IPv4</span></span><br><span class="line">	<span class="comment">// SOCK_STREAM = virtual circuit service</span></span><br><span class="line">	<span class="comment">// 0: the protocol for SOCK_STREAM, there's only 1.</span></span><br><span class="line">	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">"socket"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	syscall.ForkLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow reuse of recently-used addresses.</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		syscall.Close(fd)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">"setsockopt"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bind the socket to a port</span></span><br><span class="line">	sa := &amp;syscall.SockaddrInet4&#123;Port: port&#125;</span><br><span class="line">	<span class="built_in">copy</span>(sa.Addr[:], ip)</span><br><span class="line">	<span class="keyword">if</span> err = syscall.Bind(fd, sa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">"bind"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Listen for incoming connections.</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.Listen(fd, syscall.SOMAXCONN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">"listen"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;netSocket&#123;fd: fd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns netSocket)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n, err := syscall.Read(ns.fd, p) <span class="comment">// read from socket file descriptor</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns netSocket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n, err := syscall.Write(ns.fd, p) <span class="comment">// write to socket file descriptor</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new netSocket for the next pending connection request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns *netSocket)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(*netSocket, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// syscall.ForkLock doc states lock not needed for blocking accept.</span></span><br><span class="line">	nfd, _, err := syscall.Accept(ns.fd)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		syscall.CloseOnExec(nfd)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;netSocket&#123;nfd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns *netSocket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall.Close(ns.fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>netSocket</strong> data model is created to represent the socket, which contains only one field <strong>fd</strong> means file descriptor. And all the socket related APIs: <strong>Read</strong>, <strong>Write</strong>,  <strong>Accept</strong> and <strong>Close</strong>, are defined. The usage of socket API is not in this article’s scope, you can easily find a lot of great documents about it online. </p>
<p>The logic of <strong>netSocket</strong> is not complicated, because it delegates the job to the kernel by <code>system call</code>. A system call is a programmatic way a program requests a service from the kernel, in detail you can refer to this <a href="https://opensource.com/article/19/10/strace" target="_blank" rel="noopener">article</a>. In Golang, all the system calls are wrapped inside the <code>syscall</code> standard package.  </p>
<p>One thing need to mention is different platform have different <code>syscall</code> usages, so the demo code shown in this article can only be compiled and build on Linux system. </p>
<p>Now we setup the TCP server and wait for connection request from client side. Next, let’s see how to read or write HTTP request and response through socket. </p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>The main workflow is as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"http-server-scratch/simplenet"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ipFlag := flag.String(<span class="string">"ip_addr"</span>, <span class="string">"127.0.0.1"</span>, <span class="string">"The IP address to use"</span>)</span><br><span class="line">	portFlag := flag.Int(<span class="string">"port"</span>, <span class="number">8080</span>, <span class="string">"The port to use."</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	ip := simplenet.ParseIP(*ipFlag)</span><br><span class="line">	port := *portFlag</span><br><span class="line">	socket, err := simplenet.NewNetSocket(ip, port)</span><br><span class="line">	<span class="keyword">defer</span> socket.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Print(<span class="string">"==============="</span>)</span><br><span class="line">	log.Print(<span class="string">"Server Started!"</span>)</span><br><span class="line">	log.Print(<span class="string">"==============="</span>)</span><br><span class="line">	log.Print()</span><br><span class="line">	log.Printf(<span class="string">"addr: http://%s:%d"</span>, ip, port)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Block until incoming connection</span></span><br><span class="line">		rw, e := socket.Accept()</span><br><span class="line">		log.Print()</span><br><span class="line">		log.Print()</span><br><span class="line">		log.Printf(<span class="string">"Incoming connection"</span>)</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read request</span></span><br><span class="line">		log.Print(<span class="string">"Reading request"</span>)</span><br><span class="line">		req, err := simplenet.ParseRequest(rw)</span><br><span class="line">		log.Print(<span class="string">"request: "</span>, req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Write response</span></span><br><span class="line">		log.Print(<span class="string">"Writing response"</span>)</span><br><span class="line">		simplenet.WriteString(rw, <span class="string">"HTTP/1.1 200 OK\r\n"</span>+</span><br><span class="line">			<span class="string">"Content-Type: text/html; charset=utf-8\r\n"</span>+</span><br><span class="line">			<span class="string">"Content-Length: 20\r\n"</span>+</span><br><span class="line">			<span class="string">"\r\n"</span>+</span><br><span class="line">			<span class="string">"&lt;h1&gt;hello world&lt;/h1&gt;"</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Print(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the HTTP request parsing logic is defined in the <strong>ParseRequest</strong> method in <strong>simplenet</strong> package. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplenet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"http-server-scratch/simplenet/simpleTextProto"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">	method <span class="keyword">string</span> <span class="comment">// GET, POST, etc.</span></span><br><span class="line">	header simpleTextProto.MIMEHeader</span><br><span class="line">	body   []<span class="keyword">byte</span></span><br><span class="line">	uri    <span class="keyword">string</span> <span class="comment">// The raw URI from the request</span></span><br><span class="line">	proto  <span class="keyword">string</span> <span class="comment">// "HTTP/1.1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseRequest</span><span class="params">(c *netSocket)</span> <span class="params">(*request, error)</span></span> &#123;</span><br><span class="line">	b := bufio.NewReader(*c)</span><br><span class="line">	tp := simpleTextProto.NewReader(b) <span class="comment">// need replace</span></span><br><span class="line">	req := <span class="built_in">new</span>(request)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request line: parse "GET /index.html HTTP/1.0"</span></span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	s, _ = tp.ReadLine() <span class="comment">// need replace</span></span><br><span class="line">	sp := strings.Split(s, <span class="string">" "</span>)</span><br><span class="line">	req.method, req.uri, req.proto = sp[<span class="number">0</span>], sp[<span class="number">1</span>], sp[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request headers</span></span><br><span class="line">	mimeHeader, _ := tp.ReadMIMEHeader() <span class="comment">// need replace</span></span><br><span class="line">	req.header = mimeHeader</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request body</span></span><br><span class="line">	<span class="keyword">if</span> req.method == <span class="string">"GET"</span> || req.method == <span class="string">"HEAD"</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.header[<span class="string">"Content-Length"</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"no content length"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	length, err := strconv.Atoi(req.header[<span class="string">"Content-Length"</span>][<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	body := <span class="built_in">make</span>([]<span class="keyword">byte</span>, length)</span><br><span class="line">	<span class="keyword">if</span> _, err = io.ReadFull(b, body); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req.body = body</span><br><span class="line">	<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The HTTP request message can be divided into three parts <code>request line</code>, <code>request headers</code> and <code>request body</code> as follows: </p>
<img src="/images/http_message_format.png" title="network" width="600px" height="400px">


<p>The logic inside <strong>ParseRequest</strong> handles these 3 parts step by step. You can refer to the comments in the demo code. </p>
<p>One thing need to emphasis is that <strong>ParseRequest</strong> method doesn’t depends on <code>net</code> package. Because I want to show how HTTP server works in the bottom level, so I copy the request parsing logics from <code>net</code> package into my <code>simplenet</code> package. The parsing for request header part is kind of complex, but it doesn’t influence your understanding about the main concept of HTTP server. If you want to know the details, you can refer to the <code>simplenet/simpleTextProto</code> package. The important thing to understand is HTTP server reads the request message with <strong>Read</strong> method of <strong>netSocket</strong> . And the <strong>Read</strong> method makes socket read system call to get network data from TCP stack: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Read(ns.fd, p)</span><br></pre></td></tr></table></figure>

<p>On the other side,  HTTP response is sent back by calling <code>WriteString</code> method of <code>simplenet</code> package</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(c *netSocket, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriteString</code> simply calls <strong>Write</strong> method of <strong>netsocket</strong>, which makes socket write system call to send data over Interent with TCP stack:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Write(ns.fd, p)</span><br></pre></td></tr></table></figure>
<p>That’s all for the code part. Next let’s try to run this simple HTTP server we build from scratch.</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>Build (need Linux platform) and run this HTTP server with default options setting and send request to it with <code>curl</code>. The result goes as follows: </p>
<img src="/images/golang_http_server_demo.png" title="network" width="600px" height="400px">

<p>the server works as expected. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/31/how-to-implement-simple-http-server-golang/" data-id="cl458i8bx001694mm4v6ofbf7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-collect-metrics-k8s" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/14/how-to-collect-metrics-k8s/" class="article-date">
  <time datetime="2021-07-14T02:37:52.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/14/how-to-collect-metrics-k8s/">how-to-collect-metrics-k8s</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/14/how-to-collect-metrics-k8s/" data-id="cl458i8bq000q94mma4oe3v7k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 20px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two- hello world module</a>
          </li>
        
          <li>
            <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
          </li>
        
          <li>
            <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
          </li>
        
          <li>
            <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
          </li>
        
          <li>
            <a href="/2022/02/07/stack-smashing-detect-in-c/">stack-smashing-detect-in-c</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>