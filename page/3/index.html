<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/page/3/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
          <a class="main-nav-link" href="/book-reviews">Book Review</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-how-traceroute-works" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/24/how-traceroute-works/" class="article-date">
  <time datetime="2021-12-24T14:08:39.000Z" itemprop="datePublished">2021-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/24/how-traceroute-works/">how-traceroute-works</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/24/how-traceroute-works/" data-id="clkgd3397001nvommcmo06r12" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http-1-1-client-golang-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/understand-http-1-1-client-golang-part2/" class="article-date">
  <time datetime="2021-12-15T06:01:03.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/understand-http-1-1-client-golang-part2/">How  HTTP1.1 protocol is implemented in Golang net/http package: part two -  write HTTP message to socket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">previous</a> article, I introduced the main workflow of an HTTP request implemented inside Golang <code>net/http</code> package. As the second article of this series, I’ll focus on how to pass the HTTP message to TCP/IP stack, and then it can be transported over the network. </p>
<h3 id="Architecture-diagram"><a href="#Architecture-diagram" class="headerlink" title="Architecture diagram"></a>Architecture diagram</h3><p>When the client application sends an HTTP request, it determines what is next step based on whether there is an available persistent connection in the cached connection pool. If no, then a new TCP connection will be established. If yes, then a persistent connection will be selected. </p>
<p>The details of the connection pool is not in this article’s scope. I’ll discuss it in the next article. For now you can regard it as a block box. </p>
<p>The overall diagram of this article goes as follows, we can review each piece of it in the below sections</p>
<img src="/images/golang-http1-1-flow-write-socket.png" title="write to socket" width="800px" height="600px">

<h3 id="persistConn"><a href="#persistConn" class="headerlink" title="persistConn"></a>persistConn</h3><p>The key structure in this part is <code>persistConn</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> persistConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	alt RoundTripper</span><br><span class="line">	t         *Transport</span><br><span class="line">	cacheKey  connectMethodKey</span><br><span class="line">	conn      net.Conn            <span class="comment">// underlying TCP connection</span></span><br><span class="line">	tlsState  *tls.ConnectionState</span><br><span class="line">	br        *bufio.Reader       </span><br><span class="line">	bw        *bufio.Writer       <span class="comment">// buffer io for writing data</span></span><br><span class="line">	nwrite    <span class="type">int64</span>               </span><br><span class="line">	reqch     <span class="keyword">chan</span> requestAndChan </span><br><span class="line">	writech   <span class="keyword">chan</span> writeRequest   <span class="comment">// channel for writing request</span></span><br><span class="line">	closech   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;      </span><br><span class="line">	isProxy   <span class="type">bool</span></span><br><span class="line">	sawEOF    <span class="type">bool</span>  </span><br><span class="line">	readLimit <span class="type">int64</span> </span><br><span class="line">	writeErrCh <span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line">	writeLoopDone <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">	idleAt    time.Time   </span><br><span class="line">	idleTimer *time.Timer </span><br><span class="line">	mu                   sync.Mutex </span><br><span class="line">	numExpectedResponses <span class="type">int</span></span><br><span class="line">	closed               <span class="type">error</span> </span><br><span class="line">	canceledErr          <span class="type">error</span> </span><br><span class="line">	broken               <span class="type">bool</span> </span><br><span class="line">	reused               <span class="type">bool</span>  </span><br><span class="line">	mutateHeaderFunc <span class="function"><span class="keyword">func</span><span class="params">(Header)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are many fields defined in <code>persistConn</code>, but we can focus on these three: </p>
<ul>
<li><code>conn</code>: type of <code>net.Conn</code> which defines TCP connection in Golang;</li>
<li><code>bw</code>: type of <code>*bufio.Writer</code> which implements <code>buffer io</code> functionality;</li>
<li><code>writech</code>: type of <code>channel</code> which is used to communicate and sync data among different Goroutines in Golang.</li>
</ul>
<p>In next sections, let’s investigate how <code>persistConn</code> is used to write HTTP message to socket. </p>
<h3 id="New-connection"><a href="#New-connection" class="headerlink" title="New connection"></a>New connection</h3><p>First, let’s see how to establish a new TCP connection and bind it to <code>persistConn</code> structure. The job is done inside <strong>dialConn</strong> method of <strong>Transport</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dialConn in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// construct a new persistConn</span></span><br><span class="line">	pconn = &amp;persistConn&#123;</span><br><span class="line">		t:             t,</span><br><span class="line">		cacheKey:      cm.key(),</span><br><span class="line">		reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">		writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">		closech:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		writeErrCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">		writeLoopDone: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line">	wrapErr := <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;net.OpError&#123;Op: <span class="string">&quot;proxyconnect&quot;</span>, Net: <span class="string">&quot;tcp&quot;</span>, Err: err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cm.scheme() == <span class="string">&quot;https&quot;</span> &amp;&amp; t.hasCustomTLSDialer() &#123;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="comment">// dial secure TCP connection, assign to field pconn.conn</span></span><br><span class="line">		pconn.conn, err = t.customDialTLS(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tc, ok := pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeStart != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeStart()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := tc.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> pconn.conn.Close()</span><br><span class="line">				<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">					trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			cs := tc.ConnectionState()</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeDone(cs, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pconn.tlsState = &amp;cs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// dial TCP connection</span></span><br><span class="line">		conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// assign to pconn.conn</span></span><br><span class="line">		pconn.conn = conn</span><br><span class="line">		<span class="keyword">if</span> cm.scheme() == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> firstTLSHost <span class="type">string</span></span><br><span class="line">			<span class="keyword">if</span> firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err = pconn.addTLS(firstTLSHost, trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL == <span class="literal">nil</span>:</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL.Scheme == <span class="string">&quot;socks5&quot;</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		d := socksNewDialer(<span class="string">&quot;tcp&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">		<span class="keyword">if</span> u := cm.proxyURL.User; u != <span class="literal">nil</span> &#123;</span><br><span class="line">			auth := &amp;socksUsernamePassword&#123;</span><br><span class="line">				Username: u.Username(),</span><br><span class="line">			&#125;</span><br><span class="line">			auth.Password, _ = u.Password()</span><br><span class="line">			d.AuthMethods = []socksAuthMethod&#123;</span><br><span class="line">				socksAuthMethodNotRequired,</span><br><span class="line">				socksAuthMethodUsernamePassword,</span><br><span class="line">			&#125;</span><br><span class="line">			d.Authenticate = auth.Authenticate</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := d.DialWithConn(ctx, conn, <span class="string">&quot;tcp&quot;</span>, cm.targetAddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">&quot;http&quot;</span>:</span><br><span class="line">		pconn.isProxy = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			pconn.mutateHeaderFunc = <span class="function"><span class="keyword">func</span><span class="params">(h Header)</span></span> &#123;</span><br><span class="line">				h.Set(<span class="string">&quot;Proxy-Authorization&quot;</span>, pa)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">&quot;https&quot;</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		hdr := t.ProxyConnectHeader</span><br><span class="line">		<span class="keyword">if</span> hdr == <span class="literal">nil</span> &#123;</span><br><span class="line">			hdr = <span class="built_in">make</span>(Header)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			hdr = hdr.Clone()</span><br><span class="line">			hdr.Set(<span class="string">&quot;Proxy-Authorization&quot;</span>, pa)</span><br><span class="line">		&#125;</span><br><span class="line">		connectReq := &amp;Request&#123;</span><br><span class="line">			Method: <span class="string">&quot;CONNECT&quot;</span>,</span><br><span class="line">			URL:    &amp;url.URL&#123;Opaque: cm.targetAddr&#125;,</span><br><span class="line">			Host:   cm.targetAddr,</span><br><span class="line">			Header: hdr,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		connectCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> ctx.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">			newCtx, cancel := context.WithTimeout(ctx, <span class="number">1</span>*time.Minute)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			connectCtx = newCtx</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		didReadResponse := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) </span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			resp *Response</span><br><span class="line">			err  <span class="type">error</span> </span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">close</span>(didReadResponse)</span><br><span class="line">			err = connectReq.Write(conn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			br := bufio.NewReader(conn)</span><br><span class="line">			resp, err = ReadResponse(br, connectReq)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-connectCtx.Done():</span><br><span class="line">			conn.Close()</span><br><span class="line">			&lt;-didReadResponse</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, connectCtx.Err()</span><br><span class="line">		<span class="keyword">case</span> &lt;-didReadResponse:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">			f := strings.SplitN(resp.Status, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f) &lt; <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unknown status code&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(f[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &amp;&amp; cm.targetScheme == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := pconn.addTLS(cm.tlsHost(), trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s := pconn.tlsState; s != <span class="literal">nil</span> &amp;&amp; s.NegotiatedProtocolIsMutual &amp;&amp; s.NegotiatedProtocol != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> next, ok := t.TLSNextProto[s.NegotiatedProtocol]; ok &#123;</span><br><span class="line">			alt := next(cm.targetAddr, pconn.conn.(*tls.Conn))</span><br><span class="line">			<span class="keyword">if</span> e, ok := alt.(http2erringRoundTripper); ok &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, e.err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> &amp;persistConn&#123;t: t, cacheKey: pconn.cacheKey, alt: alt&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())</span><br><span class="line">	<span class="comment">// buffer io wrapper for writing request</span></span><br><span class="line">	pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br><span class="line">	<span class="comment">// read loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">	<span class="comment">// write loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">	<span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At <strong>line 4</strong>, it creates a new <code>persistConn</code> object, which is also the return value for this method. </p>
<p>At <strong>line 22</strong> and <strong>line 46</strong>, it calls <code>dial</code> method to establish a new TCP connection (note line 22 handles <code>TLS</code> case). In Golang a TCP connection is represented as <code>net.Conn</code> type. And then the underlying TCP connection is bound to the <code>conn</code> field of <code>persistConn</code>. </p>
<p>Now that we have the TCP connection, how can we use it? We’ll skip the many lines of code and go to the end to this function. </p>
<p>At <strong>line 166</strong>,  it creates <code>bufio.Writer</code> based on <code>persistConn</code>. <code>Buffer IO</code> is an interesting topic, in detail you can refer to my previous <a href="https://baoqger.github.io/2021/04/04/golang-bytes-buffer/">article</a>. In one word, it can optimize the performance by reducing the number of system calls. For example in the current case, it can avoid too many <code>socket</code> system calls. </p>
<p>At <strong>line 171</strong>, it creates a Goroutine and execute <code>writeLoop</code> method. Let’s take a look at it. </p>
<h3 id="writeLoop"><a href="#writeLoop" class="headerlink" title="writeLoop"></a>writeLoop</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writeLoop method in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> writeLoop() &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pc.writeLoopDone)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// receive request from writech channel</span></span><br><span class="line">		<span class="keyword">case</span> wr := &lt;-pc.writech:</span><br><span class="line">			startBytesWritten := pc.nwrite</span><br><span class="line">			<span class="comment">// call write method</span></span><br><span class="line">			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line">			<span class="keyword">if</span> bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">				err = bre.<span class="type">error</span></span><br><span class="line">				wr.req.setError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				err = pc.bw.Flush()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				wr.req.Request.closeBody()</span><br><span class="line">				<span class="keyword">if</span> pc.nwrite == startBytesWritten &#123;</span><br><span class="line">					err = nothingWrittenError&#123;err&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pc.writeErrCh &lt;- err <span class="comment">// to the body reader, which might recycle us</span></span><br><span class="line">			wr.ch &lt;- err         <span class="comment">// to the roundTrip function</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As the function name <strong>writeLoop</strong> implies, there is a <strong>for</strong> loop, and it keeps receiving data from the <strong>writech</strong> channel. Everytime it receive a request from the channel, call the <code>write</code> method at <strong>line 10</strong>. Then let’s review what message it actually writes:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method in request.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> write(w io.Writer, usingProxy <span class="type">bool</span>, extraHeaders Header, waitForContinue <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	trace := httptrace.ContextClientTrace(r.Context())</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			trace.WroteRequest(httptrace.WroteRequestInfo&#123;</span><br><span class="line">				Err: err,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	host := cleanHost(r.Host)</span><br><span class="line">	<span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errMissingHost</span><br><span class="line">		&#125;</span><br><span class="line">		host = cleanHost(r.URL.Host)</span><br><span class="line">	&#125;</span><br><span class="line">	host = removeZone(host)</span><br><span class="line">	ruri := r.URL.RequestURI()</span><br><span class="line">	<span class="keyword">if</span> usingProxy &amp;&amp; r.URL.Scheme != <span class="string">&quot;&quot;</span> &amp;&amp; r.URL.Opaque == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ruri = r.URL.Scheme + <span class="string">&quot;://&quot;</span> + host + ruri</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> r.Method == <span class="string">&quot;CONNECT&quot;</span> &amp;&amp; r.URL.Path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ruri = host</span><br><span class="line">		<span class="keyword">if</span> r.URL.Opaque != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			ruri = r.URL.Opaque</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> stringContainsCTLByte(ruri) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;net/http: can&#x27;t write control character in Request.URL&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> bw *bufio.Writer</span><br><span class="line">	<span class="keyword">if</span> _, ok := w.(io.ByteWriter); !ok &#123;</span><br><span class="line">		bw = bufio.NewWriter(w)</span><br><span class="line">		w = bw</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request line</span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">&quot;%s %s HTTP/1.1\r\n&quot;</span>, valueOrDefault(r.Method, <span class="string">&quot;GET&quot;</span>), ruri)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request Host header </span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">&quot;Host: %s\r\n&quot;</span>, host)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaderField(<span class="string">&quot;Host&quot;</span>, []<span class="type">string</span>&#123;host&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	userAgent := defaultUserAgent</span><br><span class="line">	<span class="keyword">if</span> r.Header.has(<span class="string">&quot;User-Agent&quot;</span>) &#123;</span><br><span class="line">		userAgent = r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> userAgent != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// write HTTP request User-Agent header </span></span><br><span class="line">		_, err = fmt.Fprintf(w, <span class="string">&quot;User-Agent: %s\r\n&quot;</span>, userAgent)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.WroteHeaderField(<span class="string">&quot;User-Agent&quot;</span>, []<span class="type">string</span>&#123;userAgent&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tw, err := newTransferWriter(r)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeHeader(w, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = r.Header.writeSubset(w, reqWriteExcludeHeader, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> extraHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = extraHeaders.write(w, trace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write blank line after HTTP request headers</span></span><br><span class="line">	_, err = io.WriteString(w, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaders()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> waitForContinue != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &#123;</span><br><span class="line">			err = bw.Flush()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.Wait100Continue != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.Wait100Continue()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !waitForContinue() &#123;</span><br><span class="line">			r.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &amp;&amp; tw.FlushHeaders &#123;</span><br><span class="line">		<span class="keyword">if</span> err := bw.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeBody(w)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tw.bodyReadError == err &#123;</span><br><span class="line">			err = requestBodyReadError&#123;err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bw.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We will not go through every line of code in above function. But I bet you find many familiar information, for example, at line 37 it write <strong>HTTP request line</strong> as the first information in the HTTP message. Then it continues writing <strong>HTTP headers</strong> such as <strong>Host</strong> and <strong>User-Agent</strong>(at line 42 and line 56), and finally add the <strong>blank line</strong> after the headers (at line 86). An HTTP request message is built up bit by bit. All right.  </p>
<h3 id="Bufio-and-underlying-writer"><a href="#Bufio-and-underlying-writer" class="headerlink" title="Bufio and underlying writer"></a>Bufio and underlying writer</h3><p>Next piece of this puzzle is how it’s related to the underlying TCP connection. </p>
<p>Note this method call in the write loop: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method call in writeLoop</span></span><br><span class="line">wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br></pre></td></tr></table></figure>
<p>The first parameter is <code>pc.bw</code> mentioned above. It’s time to take a deep look at it. <code>pc.bw</code>, a <strong>bufio.Write</strong>, is created by calling the following method from <code>bufio</code> package: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pconn.bw is created by this method call</span></span><br><span class="line">pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br></pre></td></tr></table></figure>

<p>Note that this <strong>bufio.Writer</strong> isn’t based on <code>persistConn</code> directly, instead a simple wrapper over <code>persistConn</code> called <code>persistConnWriter</code> is used here. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="keyword">type</span> persistConnWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	pc *persistConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we need to understand is <strong>bufio.Writer wraps an io.Writer object, creating another Writer that also implements the interface but provides buffering functionality.</strong> And <strong>bufio.Writer’s Flush method writes the buffered data to the underlying io.Writer.</strong></p>
<p>In this case, the underlying io.Writer is <code>persistConnWriter</code>. Its <code>Write</code> method will be used to write the buffered data: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w persistConnWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	n, err = w.pc.conn.Write(p) <span class="comment">// TCP socket Write system call is called here!</span></span><br><span class="line">	w.pc.nwrite += <span class="type">int64</span>(n)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internally it delegates the task to the TCP connection bond to <code>pconn.conn</code>! </p>
<h3 id="roundTrip"><a href="#roundTrip" class="headerlink" title="roundTrip"></a>roundTrip</h3><p>As we mentioned above, <code>writeLoop</code> keeps receiving reqeusts from <code>writech</code> channel. So on the other hand, it means the requests should be sent to this channel somewhere. This is implemented inside the <code>roundTrip</code> method: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundTrip in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> roundTrip(req *transportRequest) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">	testHookEnterRoundTrip()</span><br><span class="line">	<span class="keyword">if</span> !pc.t.replaceReqCanceler(req.cancelKey, pc.cancelRequest) &#123;</span><br><span class="line">		pc.t.putOrCloseIdleConn(pc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceled</span><br><span class="line">	&#125;</span><br><span class="line">	pc.mu.Lock()</span><br><span class="line">	pc.numExpectedResponses++</span><br><span class="line">	headerFn := pc.mutateHeaderFunc</span><br><span class="line">	pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> headerFn != <span class="literal">nil</span> &#123;</span><br><span class="line">		headerFn(req.extraHeaders())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestedGzip := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> !pc.t.DisableCompression &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">&quot;Range&quot;</span>) == <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">		req.Method != <span class="string">&quot;HEAD&quot;</span> &#123;</span><br><span class="line">		requestedGzip = <span class="literal">true</span></span><br><span class="line">		req.extraHeaders().Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> continueCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.Body != <span class="literal">nil</span> &amp;&amp; req.expectsContinue() &#123;</span><br><span class="line">		continueCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pc.t.DisableKeepAlives &amp;&amp; !req.wantsClose() &#123;</span><br><span class="line">		req.extraHeaders().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(gone)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			pc.t.setReqCanceler(req.cancelKey, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> debugRoundTrip = <span class="literal">false</span></span><br><span class="line">	startBytesWritten := pc.nwrite</span><br><span class="line">	writeErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// send requet to pc.writech channel </span></span><br><span class="line">	pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line"></span><br><span class="line">	resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">	pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">		req:        req.Request,</span><br><span class="line">		cancelKey:  req.cancelKey,</span><br><span class="line">		ch:         resc,</span><br><span class="line">		addedGzip:  requestedGzip,</span><br><span class="line">		continueCh: continueCh,</span><br><span class="line">		callerGone: gone,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> respHeaderTimer &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	cancelChan := req.Request.Cancel</span><br><span class="line">	ctxDoneChan := req.Context().Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		testHookWaitResLoop()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-writeErrCh:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;writeErrCh resv: %T/%#v&quot;</span>, err, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(fmt.Errorf(<span class="string">&quot;write error: %v&quot;</span>, err))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> d := pc.t.ResponseHeaderTimeout; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">					req.logf(<span class="string">&quot;starting timer for %v&quot;</span>, d)</span><br><span class="line">				&#125;</span><br><span class="line">				timer := time.NewTimer(d)</span><br><span class="line">				<span class="keyword">defer</span> timer.Stop() </span><br><span class="line">				respHeaderTimer = timer.C</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;closech recv: %T %#v&quot;</span>, pc.closed, pc.closed)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, pc.closed)</span><br><span class="line">		<span class="keyword">case</span> &lt;-respHeaderTimer:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;timeout waiting for response headers.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pc.<span class="built_in">close</span>(errTimeout)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line">		<span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">			<span class="keyword">if</span> (re.res == <span class="literal">nil</span>) == (re.err == <span class="literal">nil</span>) &#123;</span><br><span class="line">				<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;internal error: exactly one of res or err should be set; nil=%v&quot;</span>, re.res == <span class="literal">nil</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;resc recv: %p, %T/%#v&quot;</span>, re.res, re.err, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> re.err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-cancelChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, errRequestCanceled)</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ctxDoneChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, req.Context().Err())</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">			ctxDoneChan = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At line 48, you can find it clearly. In <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">last article</a>, you can see that <code>pconn.roundTrip</code> is the end of the HTTP request workflow. Now we had put all parts together. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article (as the second part of this series), we reviewed how the HTTP request message is written to TCP/IP stack via socket system call.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/15/understand-http-1-1-client-golang-part2/" data-id="clkgd339x003vvomm2yglgwc7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http-1-1-client-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/01/understand-http-1-1-client-golang/" class="article-date">
  <time datetime="2021-12-01T02:02:34.000Z" itemprop="datePublished">2021-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/01/understand-http-1-1-client-golang/">How  HTTP1.1 protocol is implemented in Golang net/http package: part one - request workflow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this article, I’ll write about one topic: how to implement the HTTP protocol. I keep planning to write about this topic for a long time. In my previous articles, I already wrote several articles about HTTP protocol:</p>
<ul>
<li><a href="https://baoqger.github.io/2021/07/31/how-to-implement-simple-http-server-golang/">How to write a Golang HTTP server with Linux system calls</a></li>
<li><a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">Understand how HTTP/1.1 persistent connection works based on Golang: part one - sequential requests</a></li>
<li><a href="https://baoqger.github.io/2021/10/27/understand-http1-1-persitent-connection-golang-part2/">Understand how HTTP/1.1 persistent connection works based on Golang: part two - concurrent requests</a></li>
</ul>
<p>I recommend you to read these articles above before this one. </p>
<p>As you know, HTTP protocol is in the application layer, which is the closest one to the end-user in the protocol stack. </p>
<p>So relatively speaking, HTTP protocol is not as mysterious as other protocols in the lower layers of this stack. Software engineers use HTTP every day and take it for granted. Have you ever thought about how we can implement a fully functional HTTP protocol library? </p>
<p>It turns out to be a very complex and big work in terms of software engineering. Frankly speaking, I can’t work it out by myself in a short period. So in this article, we’ll try to understand how to do it by investigating Golang <code>net/http</code> package as an example. We’ll read a lot of source code and draw diagrams to help your understanding of the source code.</p>
<p><strong>Note</strong> HTTP protocol itself has evolved a lot from <code>HTTP1.1</code> to <code>HTTP2</code> and <code>HTTP3</code>, not to mention <code>HTTPS</code>. In this article, we’ll focus on the mechanism of <code>HTTP1.1</code>, but what you learned here can help you understand other new versions of HTTP protocol. </p>
<p><strong>Note</strong> HTTP protocol is on the basis of client-server model. This article will focus on the client-side. For the HTTP server part, I’ll write another article next. </p>
<h3 id="Main-workflow-of-http-Client"><a href="#Main-workflow-of-http-Client" class="headerlink" title="Main workflow of http.Client"></a>Main workflow of http.Client</h3><p>HTTP client’s request starts from the application’s call to <code>Get</code> method of <code>net/http</code> package, and ends by writing the HTTP message to the TCP socket. The whole workflow can be simplified to the following diagram:   </p>
<img src="/images/golang-http1-1-client-flow.png" title="golang client flow" width="800px" height="600px">

<p>First, the public <code>Get</code> method calls Get method of <code>DefaultClient</code>, which is a global variable of type <code>Client</code>,  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="type">string</span>)</span></span> (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> DefaultClient.Get(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultClient is a global variable in net/http package</span></span><br><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct type Client</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transport RoundTripper</span><br><span class="line"></span><br><span class="line">	CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	Jar CookieJar</span><br><span class="line"></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, <code>NewRequest</code> method is used to construct a new request of type <code>Request</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Get(url <span class="type">string</span>) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">	req, err := NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequest</span><span class="params">(method, url <span class="type">string</span>, body io.Reader)</span></span> (*Request, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> NewRequestWithContext(context.Background(), method, url, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’ll not show the function body of <code>NewRequestWithContext</code>, since it’s very long. But only paste the block of code for actually building the <code>Request</code> object as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req := &amp;Request&#123;</span><br><span class="line">    <span class="comment">// omit some code </span></span><br><span class="line">    Proto:      <span class="string">&quot;HTTP/1.1&quot;</span>, <span class="comment">// the default HTTP protocol version is set to 1.1</span></span><br><span class="line">    ProtoMajor: <span class="number">1</span>,</span><br><span class="line">    ProtoMinor: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// omit some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that by default the HTTP protocol version is set to 1.1. If you want to send HTTP2 request, then you need other solutions, and I’ll write about it in other articles.  </p>
<p>Next, <code>Do</code> method is called, which delegates the work to the private <code>do</code> method.  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Do(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do</code> method handles the <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections"><code>HTTP redirect</code></a> behavior, which is very interesting. But since the code block is too long, I’ll not show its function body here. You can refer to the source code of it <a target="_blank" rel="noopener" href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.3:src/net/http/client.go;drc=refs%2Ftags%2Fgo1.17.3;l=598">here</a>.</p>
<p>Next, <code>send</code> method of Client is called which goes as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> send(req *Request, deadline time.Time) (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, cookie := <span class="keyword">range</span> c.Jar.Cookies(req.URL) &#123;</span><br><span class="line">			req.AddCookie(cookie)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// call send method here</span></span><br><span class="line">	resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.Jar != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rc := resp.Cookies(); <span class="built_in">len</span>(rc) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			c.Jar.SetCookies(req.URL, rc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It handles cookies for the request, then calls the private method <code>send</code> with three parameters.</p>
<p>We already talked about the first parameter above. Let’s take a look at the second parameter <code>c.transport()</code> as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> transport() RoundTripper &#123;</span><br><span class="line">	<span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.Transport</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is extremely important for HTTP client workflow. Let’s examine how it works bit by bit.  First of all, it’s type of <code>RoundTripper</code> interface. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this interface is defined inside client.go file </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// RoundTrip executes a single HTTP transaction, returning</span></span><br><span class="line">	<span class="comment">// a Response for the provided Request.</span></span><br><span class="line">	RoundTrip(*Request) (*Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RoundTripper</code> interface only defines one method <code>RoundTrip</code>, all right. </p>
<p>If you don’t have any special settings, the <code>DefaultTransport</code> will be used for <code>c.Transport</code> above. </p>
<p>The <code>DefaultTransport</code> is going as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defined in transport.go</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">	Proxy: ProxyFromEnvironment,</span><br><span class="line">	DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">		Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">		KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">		DualStack: <span class="literal">true</span>,</span><br><span class="line">	&#125;).DialContext,</span><br><span class="line">	ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">	MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">	IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">	TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">	ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that its actual type  is <code>Transport</code> as below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">	idleMu       sync.Mutex</span><br><span class="line">	closeIdle    <span class="type">bool</span>                                <span class="comment">// user has requested to close all idle conns</span></span><br><span class="line">	idleConn     <span class="keyword">map</span>[connectMethodKey][]*persistConn <span class="comment">// most recently used at end</span></span><br><span class="line">	idleConnWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue  <span class="comment">// waiting getConns</span></span><br><span class="line">	idleLRU      connLRU</span><br><span class="line">	reqMu       sync.Mutex</span><br><span class="line">	reqCanceler <span class="keyword">map</span>[cancelKey]<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">error</span>)</span></span></span><br><span class="line">	altMu    sync.Mutex   <span class="comment">// guards changing altProto only</span></span><br><span class="line">	altProto atomic.Value <span class="comment">// of nil or map[string]RoundTripper, key is URI scheme</span></span><br><span class="line">	connsPerHostMu   sync.Mutex</span><br><span class="line">	connsPerHost     <span class="keyword">map</span>[connectMethodKey]<span class="type">int</span></span><br><span class="line">	connsPerHostWait <span class="keyword">map</span>[connectMethodKey]wantConnQueue <span class="comment">// waiting getConns</span></span><br><span class="line">	Proxy <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span></span> (*url.URL, <span class="type">error</span>)</span><br><span class="line">	DialContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">	Dial <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">	DialTLSContext <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">	DialTLS <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">	TLSClientConfig *tls.Config</span><br><span class="line">	TLSHandshakeTimeout time.Duration</span><br><span class="line">	DisableKeepAlives <span class="type">bool</span></span><br><span class="line">	DisableCompression <span class="type">bool</span></span><br><span class="line">	MaxIdleConns <span class="type">int</span></span><br><span class="line">	MaxIdleConnsPerHost <span class="type">int</span></span><br><span class="line">	MaxConnsPerHost <span class="type">int</span></span><br><span class="line">	IdleConnTimeout time.Duration</span><br><span class="line">	ResponseHeaderTimeout time.Duration</span><br><span class="line">	ExpectContinueTimeout time.Duration</span><br><span class="line">	TLSNextProto <span class="keyword">map</span>[<span class="type">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(authority <span class="type">string</span>, c *tls.Conn)</span></span> RoundTripper</span><br><span class="line">	ProxyConnectHeader Header</span><br><span class="line">	MaxResponseHeaderBytes <span class="type">int64</span></span><br><span class="line">	WriteBufferSize <span class="type">int</span></span><br><span class="line">	ReadBufferSize <span class="type">int</span></span><br><span class="line">	nextProtoOnce      sync.Once</span><br><span class="line">	h2transport        h2Transport <span class="comment">// non-nil if http2 wired up</span></span><br><span class="line">	tlsNextProtoWasNil <span class="type">bool</span>        <span class="comment">// whether TLSNextProto was nil when the Once fired</span></span><br><span class="line">	ForceAttemptHTTP2 <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I list the full content of <code>Transport</code> struct here, although it contains many fields, and many of them will not be discussed in this article.</p>
<p>As we just mentioned, <code>Transport</code> is type of <code>RoundTripper</code> interface, it must implement the method <code>RoundTrip</code>, right? </p>
<p>You can find the <code>RoundTrip</code> method implementation of <code>Transport</code> struct type in <strong>roundtrip.go</strong> file as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip method in roundtrip.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> RoundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the beginning, I thought this method should be included inside <code>transport.go</code> file, but it is defined inside another file.  </p>
<p>Let’s back to the <code>send</code> method which takes <code>c.Transport</code> as the second argument:  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send method in client.go </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> (resp *Response, didTimeout <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	req := ireq <span class="comment">// req is either the original request, or a modified fork</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rt == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">&quot;http: no Client.Transport or DefaultTransport&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">&quot;http: nil Request.URL&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.RequestURI != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, alwaysFalse, errors.New(<span class="string">&quot;http: Request.RequestURI can&#x27;t be set in client requests&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// forkReq forks req into a shallow clone of ireq the first</span></span><br><span class="line">	<span class="comment">// time it&#x27;s called.</span></span><br><span class="line">	forkReq := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ireq == req &#123;</span><br><span class="line">			req = <span class="built_in">new</span>(Request)</span><br><span class="line">			*req = *ireq <span class="comment">// shallow clone</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Most the callers of send (Get, Post, et al) don&#x27;t need</span></span><br><span class="line">	<span class="comment">// Headers, leaving it uninitialized. We guarantee to the</span></span><br><span class="line">	<span class="comment">// Transport that this has been initialized, though.</span></span><br><span class="line">	<span class="keyword">if</span> req.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		forkReq()</span><br><span class="line">		req.Header = <span class="built_in">make</span>(Header)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> u := req.URL.User; u != <span class="literal">nil</span> &amp;&amp; req.Header.Get(<span class="string">&quot;Authorization&quot;</span>) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		username := u.Username()</span><br><span class="line">		password, _ := u.Password()</span><br><span class="line">		forkReq()</span><br><span class="line">		req.Header = cloneOrMakeHeader(ireq.Header)</span><br><span class="line">		req.Header.Set(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Basic &quot;</span>+basicAuth(username, password))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !deadline.IsZero() &#123;</span><br><span class="line">		forkReq()</span><br><span class="line">	&#125;</span><br><span class="line">	stopTimer, didTimeout := setRequestCancel(req, rt, deadline)</span><br><span class="line"></span><br><span class="line">	resp, err = rt.RoundTrip(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		stopTimer()</span><br><span class="line">		<span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;RoundTripper returned a response &amp; error; ignoring response&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tlsErr, ok := err.(tls.RecordHeaderError); ok &#123;</span><br><span class="line">			<span class="comment">// If we get a bad TLS record header, check to see if the</span></span><br><span class="line">			<span class="comment">// response looks like HTTP and give a more helpful error.</span></span><br><span class="line">			<span class="comment">// See golang.org/issue/11111.</span></span><br><span class="line">			<span class="keyword">if</span> <span class="type">string</span>(tlsErr.RecordHeader[:]) == <span class="string">&quot;HTTP/&quot;</span> &#123;</span><br><span class="line">				err = errors.New(<span class="string">&quot;http: server gave HTTP response to HTTPS client&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">&quot;http: RoundTripper implementation (%T) returned a nil *Response with a nil error&quot;</span>, rt)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.Body == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// The documentation on the Body field says “The http Client and Transport</span></span><br><span class="line">		<span class="comment">// guarantee that Body is always non-nil, even on responses without a body</span></span><br><span class="line">		<span class="comment">// or responses with a zero-length body.” Unfortunately, we didn&#x27;t document</span></span><br><span class="line">		<span class="comment">// that same constraint for arbitrary RoundTripper implementations, and</span></span><br><span class="line">		<span class="comment">// RoundTripper implementations in the wild (mostly in tests) assume that</span></span><br><span class="line">		<span class="comment">// they can use a nil Body to mean an empty one (similar to Request.Body).</span></span><br><span class="line">		<span class="comment">// (See https://golang.org/issue/38095.)</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// If the ContentLength allows the Body to be empty, fill in an empty one</span></span><br><span class="line">		<span class="comment">// here to ensure that it is non-nil.</span></span><br><span class="line">		<span class="keyword">if</span> resp.ContentLength &gt; <span class="number">0</span> &amp;&amp; req.Method != <span class="string">&quot;HEAD&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, didTimeout, fmt.Errorf(<span class="string">&quot;http: RoundTripper implementation (%T) returned a *Response with content length %d but a nil Body&quot;</span>, rt, resp.ContentLength)</span><br><span class="line">		&#125;</span><br><span class="line">		resp.Body = ioutil.NopCloser(strings.NewReader(<span class="string">&quot;&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !deadline.IsZero() &#123;</span><br><span class="line">		resp.Body = &amp;cancelTimerBody&#123;</span><br><span class="line">			stop:          stopTimer,</span><br><span class="line">			rc:            resp.Body,</span><br><span class="line">			reqDidTimeout: didTimeout,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At <strong>line 50</strong> of <code>send</code> method above: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err = rt.RoundTrip(req)</span><br></pre></td></tr></table></figure>

<p><code>RoundTrip</code> method is called to send the request. Based on the comments in the source code, you can understand it in the following way:</p>
<ul>
<li>RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.</li>
</ul>
<p>Next, let’s go to <code>roundTrip</code> method of <code>Transport</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundTrip method in transport.go, which is called by RoundTrip method internally </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roundTrip implements a RoundTripper over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> roundTrip(req *Request) (*Response, <span class="type">error</span>) &#123;</span><br><span class="line">	t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">	ctx := req.Context()</span><br><span class="line">	trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> req.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;http: nil Request.URL&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;http: nil Request.Header&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	scheme := req.URL.Scheme</span><br><span class="line">	isHTTP := scheme == <span class="string">&quot;http&quot;</span> || scheme == <span class="string">&quot;https&quot;</span></span><br><span class="line">	<span class="keyword">if</span> isHTTP &#123;</span><br><span class="line">		<span class="keyword">for</span> k, vv := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">			<span class="keyword">if</span> !httpguts.ValidHeaderFieldName(k) &#123;</span><br><span class="line">				req.closeBody()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;net/http: invalid header field name %q&quot;</span>, k)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> vv &#123;</span><br><span class="line">				<span class="keyword">if</span> !httpguts.ValidHeaderFieldValue(v) &#123;</span><br><span class="line">					req.closeBody()</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;net/http: invalid header field value %q for key %v&quot;</span>, v, k)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	origReq := req</span><br><span class="line">	cancelKey := cancelKey&#123;origReq&#125;</span><br><span class="line">	req = setupRewindBody(req)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> altRT := t.alternateRoundTripper(req); altRT != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol &#123;</span><br><span class="line">			<span class="keyword">return</span> resp, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		req, err = rewindBody(req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isHTTP &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, badStringError(<span class="string">&quot;unsupported protocol scheme&quot;</span>, scheme)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.Method != <span class="string">&quot;&quot;</span> &amp;&amp; !validMethod(req.Method) &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;net/http: invalid method %q&quot;</span>, req.Method)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> req.URL.Host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		req.closeBody()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;http: no Host in request URL&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// treq gets modified by roundTrip, so we need to recreate for each retry.</span></span><br><span class="line">		treq := &amp;transportRequest&#123;Request: req, trace: trace, cancelKey: cancelKey&#125;</span><br><span class="line">		cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get the cached or newly-created connection to either the</span></span><br><span class="line">		<span class="comment">// host (for http or https), the http proxy, or the http proxy</span></span><br><span class="line">		<span class="comment">// pre-CONNECTed to https server. In any case, we&#x27;ll be ready</span></span><br><span class="line">		<span class="comment">// to send it requests.</span></span><br><span class="line">		pconn, err := t.getConn(treq, cm)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.setReqCanceler(cancelKey, <span class="literal">nil</span>)</span><br><span class="line">			req.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> resp *Response</span><br><span class="line">		<span class="keyword">if</span> pconn.alt != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// HTTP/2 path.</span></span><br><span class="line">			t.setReqCanceler(cancelKey, <span class="literal">nil</span>) <span class="comment">// not cancelable with CancelRequest</span></span><br><span class="line">			resp, err = pconn.alt.RoundTrip(req)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resp, err = pconn.roundTrip(treq)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			resp.Request = origReq</span><br><span class="line">			<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Failed. Clean up and determine whether to retry.</span></span><br><span class="line">		<span class="keyword">if</span> http2isNoCachedConnError(err) &#123;</span><br><span class="line">			<span class="keyword">if</span> t.removeIdleConn(pconn) &#123;</span><br><span class="line">				t.decConnsPerHost(pconn.cacheKey)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !pconn.shouldRetryRequest(req, err) &#123;</span><br><span class="line">			<span class="comment">// Issue 16465: return underlying net.Conn.Read error from peek,</span></span><br><span class="line">			<span class="comment">// as we&#x27;ve historically done.</span></span><br><span class="line">			<span class="keyword">if</span> e, ok := err.(transportReadFromServerError); ok &#123;</span><br><span class="line">				err = e.err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		testHookRoundTripRetried()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Rewind the body if we&#x27;re able to.</span></span><br><span class="line">		req, err = rewindBody(req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are three key points:</p>
<ul>
<li>at <strong>line 70</strong>, a new variable of type <code>transportRequest</code>, which embeds <code>Request</code>, is created.  </li>
<li>at <strong>line 81</strong>, <code>getConn</code> method is called, which implements the cached <code>connection pool</code> to support the <code>persistent connection</code> mode. Of course, if no cached connection is available, a new connection will be created and added to the connection pool. I will explain this behavior in detail next section. </li>
<li>from <strong>line 89</strong> to <strong>line 95</strong>, <code>pconn.roundTrip</code> is called. The name of variable <code>pconn</code> is self-explaining which means it is type of <code>persistConn</code>. </li>
</ul>
<p><code>transportRequest</code> is passed as parameter to <code>getConn</code> method, which returns <code>pconn</code>. <code>pconn.roundTrip</code> is called to execute the HTTP request. we have covered all the steps in the above workflow diagram. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this first article of this series, we talked about the workflow of sending an HTTP request step by step. And I’ll discuss how to send the HTTP message to the TCP stack in the second article.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/01/understand-http-1-1-client-golang/" data-id="clkgd339y003xvommflvp2rgz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http1-1-persitent-connection-golang-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/27/understand-http1-1-persitent-connection-golang-part2/" class="article-date">
  <time datetime="2021-10-27T09:51:29.000Z" itemprop="datePublished">2021-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/27/understand-http1-1-persitent-connection-golang-part2/">Understand how HTTP/1.1 persistent connection works based on Golang: part two - concurrent requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">last post</a>, I show you how HTTP/1.1 persistent connection works in a simple demo app, which sends sequential requests.</p>
<p>We observe the underlying TCP connection behavior based on the network analysis tool: <code>netstat</code> and <code>tcpdump</code>.</p>
<p>In this article, I will modify the demo app and make it send concurrent requests. In this way, we can have more understanding about HTTP/1.1’s persistent connection.  </p>
<h3 id="Concurrent-requests"><a href="#Concurrent-requests" class="headerlink" title="Concurrent requests"></a>Concurrent requests</h3><p>The <a target="_blank" rel="noopener" href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/concurrent/non-persistent-connection/non-persistent-connection-concurrent.go">demo code</a> goes as follows:  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := http.Get(<span class="string">&quot;http://localhost:8080/&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Error: %v&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// fully read the response body</span></span><br><span class="line">		resp.Body.Close()                  <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">&quot;HTTP request #%v in Goroutine #%v&quot;</span>, counter, index)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> startHTTPRequest(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We create 10 goroutines, and each goroutine sends 10 sequential requests concurrently. </p>
<p><strong>Note</strong>: In HTTP/1.1 protocol, concurrent requests will establish multiple TCP connections. That’s the restriction of HTTP/1.1, the way to enhance it is using <code>HTTP/2</code> which can multiplex one TCP connection for multiple parallel HTTP connections. <code>HTTP/2</code> is not in the scope of this post. I will talk about it in another article. </p>
<p>Note that in the above demo, we have fully read the response body and closed it, and based on the discussion in <a href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/">last article</a>, the HTTP requests should work in the persistent connection model. </p>
<p>Before we use the network tool to analyze the behavior, let’s imagine how many TCP connections will be established. As there are 10 concurrent goroutines, 10 TCP connections should be established, and all the HTTP requests should re-use these 10 TCP connections, right? That’s our expectation. </p>
<p>Next, let’s verify our expectation with <code>netstat</code> as follows: </p>
<img src="/images/netstat-concurrent-non-persistent.png" title="tcp termination" width="600px" height="400px">

<p>It shows that the number of TCP connections is much more than 10. The persistent connection does not work as we expect. </p>
<p>After reading the source code of <code>net/http</code> package, I find the following hints: </p>
<p>The <code>Client</code> is defined inside <a target="_blank" rel="noopener" href="https://golang.org/src/net/http/client.go">client.go</a> which is the type for HTTP client, and <code>Transport</code> is one of the properties.  </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transport RoundTripper</span><br><span class="line"></span><br><span class="line">	CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	Jar CookieJar</span><br><span class="line"></span><br><span class="line">	Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is defined in <a target="_blank" rel="noopener" href="https://golang.org/src/net/http/transport.go">transport.go</a> like this: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultTransport is the default implementation of Transport and is</span></span><br><span class="line"><span class="comment">// used by DefaultClient. It establishes network connections as needed</span></span><br><span class="line"><span class="comment">// and caches them for reuse by subsequent calls. It uses HTTP proxies</span></span><br><span class="line"><span class="comment">// as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and</span></span><br><span class="line"><span class="comment">// $no_proxy) environment variables.</span></span><br><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">	Proxy: ProxyFromEnvironment,</span><br><span class="line">	DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">		Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">		KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">	&#125;).DialContext,</span><br><span class="line">	ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">	MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">	IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">	TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">	ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultMaxIdleConnsPerHost is the default value of Transport&#x27;s</span></span><br><span class="line"><span class="comment">// MaxIdleConnsPerHost.</span></span><br><span class="line"><span class="keyword">const</span> DefaultMaxIdleConnsPerHost = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>Transport</code> is type of  <code>RoundTripper</code>, which is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request. <code>RoundTripper</code> is a very important structure in <code>net/http</code> package, we’ll review (and analyze) the source code in the next article. In this article, we’ll not discuss the details. </p>
<p>Note that there are two parameters of <code>Transport</code>: </p>
<ul>
<li><strong>MaxIdleConns</strong>: controls the maximum number of idle (keep-alive) connections across all hosts.</li>
<li><strong>MaxIdleConnsPerHost</strong>: controls the maximum idle (keep-alive) connections to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used.</li>
</ul>
<p>By default, MaxIdleConns is <strong>100</strong> and MaxIdleConnsPerHost is <strong>2</strong>.</p>
<p>In our demo case, ten goroutines send requests to the same host (which is localhost:8080). Although MaxIdleConns is 100, but <strong>only 2 idle connections can be cached</strong> for this host because MaxIdleConnsPerHost is 2. That’s why you saw much more TCP connections are established. </p>
<p>Based on this analysis, let’s refactor the code as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	httpClient *http.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	httpClient = &amp;http.Client&#123;</span><br><span class="line">		Transport: &amp;http.Transport&#123;</span><br><span class="line">			MaxIdleConnsPerHost: <span class="number">10</span>, <span class="comment">// set connection pool size for each host</span></span><br><span class="line">			MaxIdleConns:        <span class="number">100</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := httpClient.Get(<span class="string">&quot;http://localhost:8080/&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Error: %v&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// fully read the response body</span></span><br><span class="line">		resp.Body.Close()                  <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">&quot;HTTP request #%v in Goroutine #%v&quot;</span>, counter, index)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> startHTTPRequest(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This time we don’t use the default httpClient, instead we create a customized client which sets MaxIdleConnsPerHost to be <strong>10</strong>. This means the size of the connection pool is changed to 10, which can cache 10 idle TCP connections for each host.</p>
<p>Verify the behavior with <code>netstat</code> again: </p>
<img src="/images/netstat-concurrent-persistent.png" title="tcp termination" width="600px" height="400px">

<p>Now the result is what we expect. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we discussed how to make HTTP/1.1 persistent connection work in a concurrent case by tunning the parameters for the connection pool. In the next article, let’s review the source code to study how to implement HTTP client.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/27/understand-http1-1-persitent-connection-golang-part2/" data-id="clkgd339i002tvomm9wac3g19" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-understand-http1-1-persistent-connection-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/25/understand-http1-1-persistent-connection-golang/" class="article-date">
  <time datetime="2021-10-25T03:11:28.000Z" itemprop="datePublished">2021-10-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/25/understand-http1-1-persistent-connection-golang/">Understand how HTTP/1.1 persistent connection works based on Golang: part one - sequential requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>Initially, <code>HTTP</code> was a single request-and-response model. An <code>HTTP</code> client opens the <code>TCP</code> connection, requests a resource, gets the response, and the connection is closed. And establishing and terminating each <code>TCP</code> connection is a resource-consuming operation (in detail, you can refer to my previous <a href="https://baoqger.github.io/2019/07/14/why-tcp-four-way-handshake/">article</a>). As the web application becomes more and more complex, displaying a single page may require several HTTP requests, too many TCP connection operations will have a bad impact on the performance. </p>
<img src="/images/short-lived-connection.png" title="tcp termination" width="400px" height="300px">

<p>So <code>persistent-connection</code> (which is also called <code>keep-alive</code>) model is created in <code>HTTP/1.1</code> protocol. In this model, TCP connections keep open between several successive requests, and in this way, the time needed to open new connections will be reduced. </p>
<img src="/images/persistent-http.png" title="tcp termination" width="400px" height="300px">

<p>In this article, I will show you how <code>persistent connection</code> works based on a Golang application. We will do some experiments based on the demo app, and verify the TCP connection behavior with some popular network packet analysis tools. In short, After reading this article, you will learn:</p>
<ul>
<li>Golang <code>http.Client</code> usage (and a little bit source code analysis)</li>
<li>network analysis with <code>netstat</code> and <code>tcpdump</code></li>
</ul>
<p>You can find the demo Golang application in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/http-persistent-connection-golang">repo</a>.</p>
<h3 id="Sequential-requests"><a href="#Sequential-requests" class="headerlink" title="Sequential requests"></a>Sequential requests</h3><p>Let’s start from the simple case where the client keeps sending <code>sequential</code> requests to the server. The <a target="_blank" rel="noopener" href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/sequence/non-persistent-connection/non-persistent-connection.go">code</a> goes as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPserver</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		_, err := http.Get(<span class="string">&quot;http://localhost:8080/&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Error: %v&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;HTTP request #%v&quot;</span>, counter)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPserver()</span><br><span class="line"></span><br><span class="line">	startHTTPRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We start an HTTP server in a Goroutine, and keep sending ten sequential requests to it. Right? Let’s run the application and check the numbers and status of TCP connections.</p>
<p>After running the above code, you can see the following output: </p>
<img src="/images/sequential-request.png" title="tcp termination" width="800px" height="600px">

<p>When the application stops running, we can run the following <code>netstat</code> command: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n  | grep 8080</span><br></pre></td></tr></table></figure>

<p>The TCP connections are listed as follows:</p>
<img src="/images/sequential-request-netstat.png" title="tcp termination" width="800px" height="600px">

<p>Obviously, the 10 HTTP requests are not persistent since 10 TCP connections are opened. </p>
<p><strong>Note</strong>: the last column of <code>netstat</code> shows the state of TCP connection. The state of TCP connection termination process can be explained with the following image: </p>
<img src="/images/state-tcp-connection.png" title="state tcp termination" width="600px" height="400px">

<p>I will not cover the details in this article. But we need to understand the meaning of <code>TIME-WAIT</code>. </p>
<p>In the <code>four-way handshake</code> process, the client will send the <code>ACK</code> packet to terminate the connection, but the state of TCP can’t immediately go to <code>CLOSED</code>. The client has to wait for some time and the state in this waiting process is called <code>TIME-WAIT</code>. The TCP connection needs this <code>TIME-WAIT</code> state for two main reasons. </p>
<ul>
<li>The first is to provide enough time that the <code>ACK</code> is received by the other peer. </li>
<li>The second is to provide a buffer period between the end of current connection and any subsequent ones. If not for this period, it’s possible that packets from different connections could be mixed. In detail, you can refer to this <a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-3.htm">book</a>.</li>
</ul>
<p>In our demo application case, if you wait for a while after the program stops, and run the <code>netstat</code> command again then no TCP connection will be listed in the output since they’re all closed. </p>
<p>Another tool to verify the TCP connections is <code>tcpdump</code>, which can capture every network packet send to your machine. In our case, you can run the following <code>tcpdump</code> command: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i any -n host localhost</span><br></pre></td></tr></table></figure>

<p>It will capture all the network packets send from or to the localhost (we’re running the server in localhost, right?). <code>tcpdump</code> is a great tool to help you understand the network, you can refer to its <a target="_blank" rel="noopener" href="https://www.tcpdump.org/">document</a> for more help.</p>
<p><strong>Note</strong>: in our demo code above, we send 10 HTTP requests in sequence, which will make the capture result from <code>tcpdump</code> too long. So I modified the for loop to only send 2 sequential requests, which is enough to verify the behavior of <code>persistent connection</code>. The result goes as follows: </p>
<img src="/images/tcpdump-non-persistent.png" title="tcpdump" width="1200px" height="1000px">

<p>In <code>tcpdump</code> output, the <code>Flag [S]</code> represents <code>SYN</code> flag, which is used to establish the TCP connection. The above snapshot contains two <code>Flag [S]</code> packets. The first <code>Flag [S]</code> is triggered by the first HTTP call, and the following packets are HTTP request and response. Then you can see the second <code>Flag [S]</code> packet to open a new TCP connection, which means the second HTTP request is not <code>persistent connection</code> as we hope. </p>
<p>Next step, let’s see how to make HTTP work as a persistent connection in Golang. </p>
<p>In fact,this is a well known issue in Golang ecosystem, you can find the information in the <a target="_blank" rel="noopener" href="https://pkg.go.dev/net/http#Client">official document</a>:</p>
<ul>
<li>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client’s underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent “keep-alive” request.</li>
</ul>
<p>The fix will be straightforward by just adding two more lines of code as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Duration(<span class="number">50</span>) * time.Microsecond)</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startHTTPRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		resp, err := http.Get(<span class="string">&quot;http://localhost:8080/&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;Error: %v&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		io.Copy(ioutil.Discard, resp.Body) <span class="comment">// read the response body</span></span><br><span class="line">		resp.Body.Close() <span class="comment">// close the response body</span></span><br><span class="line">		log.Printf(<span class="string">&quot;HTTP request #%v&quot;</span>, counter)</span><br><span class="line">		counter += <span class="number">1</span></span><br><span class="line">		time.Sleep(time.Duration(<span class="number">1</span>) * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	startHTTPServer()</span><br><span class="line"></span><br><span class="line">	startHTTPRequest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let’s verify by running <code>netstat</code> command, the result goes as follows: </p>
<img src="/images/netstat-persistent.png" title="tcpdump" width="800px" height="600px">

<p>This time 10 sequential HTTP requests establish only one TCP connection. This behavior is just what we hope: <code>persistent connection</code>.  </p>
<p>We can double verify it by doing the same experiment as above: run two HTTP requests in sequence and capture packets with <code>tcpdump</code>: </p>
<img src="/images/tcpdump-persistent.png" title="tcpdump" width="1200px" height="1000px">

<p>This time, only one <code>Flag [S]</code> packet is there! The two sequential HTTP request re-use the same underlying TCP connection. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we showed how HTTP <code>persistent connection</code> works in the case of sequential requests. In the next article, we can show you the case of concurrent requests. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/" data-id="clkgd339h002svommcmi79dnr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-why-only-13-dns-root-server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/12/why-only-13-dns-root-server/" class="article-date">
  <time datetime="2021-10-12T05:48:41.000Z" itemprop="datePublished">2021-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/12/why-only-13-dns-root-server/">why-only-13-dns-root-server</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/12/why-only-13-dns-root-server/" data-id="clkgd339u003nvommck9a4y6j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-packet-sniffer-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/08/packet-sniffer-golang/" class="article-date">
  <time datetime="2021-10-08T03:37:36.000Z" itemprop="datePublished">2021-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/08/packet-sniffer-golang/">packet-sniffer-golang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/08/packet-sniffer-golang/" data-id="clkgd339f002ivommb4yqd0da" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-build-packet-sniffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/08/how-to-build-packet-sniffer/" class="article-date">
  <time datetime="2021-10-08T03:36:45.000Z" itemprop="datePublished">2021-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/08/how-to-build-packet-sniffer/">how-to-build-packet-sniffer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/10/08/how-to-build-packet-sniffer/" data-id="clkgd33900015vomm43rh244g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cgo-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/25/cgo-golang/" class="article-date">
  <time datetime="2021-08-25T08:14:36.000Z" itemprop="datePublished">2021-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/25/cgo-golang/">cgo-golang</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/08/25/cgo-golang/" data-id="clkgd338p000bvomma4jpegwc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-win-wsl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/06/win-wsl/" class="article-date">
  <time datetime="2021-08-06T01:19:41.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/06/win-wsl/">New way to set up Linux development environment in Windows with WSL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>I like system programming which can allow you to touch more software development skills in the bottom level.  </p>
<p>Linux is the perfect platform when you want to do system programming. But if you’re using a computer running Windows on it, then you have to spend some time to set up the Linux development environment. Generally speaking there are two traditional ways to do that: <code>virtual machine</code> and <code>dualboot</code>, both need some effort. Or you can try to do that with <code>container</code> technology, for example, I once shared one <a href="https://baoqger.github.io/2020/07/28/linux-cpp-docker/">article</a> about how to do it with <code>Docker</code>. </p>
<p>In this article, I will introduce a new and easier way to do this without too much overhead. </p>
<h3 id="Windows-Subsystem-for-Linux"><a href="#Windows-Subsystem-for-Linux" class="headerlink" title="Windows Subsystem for Linux"></a>Windows Subsystem for Linux</h3><p>The new way is <code>Windows Subsystem for Linux (WSL)</code>. I have to admit that the operating system is complex and difficult so for now I don’t know how Microsoft make <code>WSL</code> works. In details, you can refer to this <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/commandline/a-deep-dive-into-how-wsl-allows-windows-to-access-linux-files/">article</a> to learn how <code>WSL</code> allows Windows to access Linux files. In this article let’s focus on how to set it up and what kind of benefits it can provide to developers.</p>
<p>Based on the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/about">official document</a>, with <code>WSL</code> you can</p>
<ul>
<li>Run common command-line tools such as <code>grep</code>, <code>sed</code>, <code>awk</code>.</li>
<li>Run Bash shell scripts and GNU/Linux command-line applications including:<ul>
<li>Tools: vim, emacs, tmux.</li>
<li>Languages: NodeJS, Javascript, Python, Ruby, C/C++, C# &amp; F#, Rust, Go, etc.</li>
<li>Services: SSHD, MySQL, Apache, lighttpd, MongoDB, PostgreSQL.</li>
</ul>
</li>
<li>Install additional software using your own GNU/Linux distribution package manager.</li>
</ul>
<p>With these conditions, you can set up a completed Linux development environment. </p>
<h3 id="Install-WSL"><a href="#Install-WSL" class="headerlink" title="Install WSL"></a>Install WSL</h3><p>For detail steps to install <code>WSL</code>, you can find it on the official document. Based on my experience, I follow the document to download and install Linux Ubuntu distribution smoothly, which is much easier than settig the virtual machine.</p>
<h3 id="File-mount"><a href="#File-mount" class="headerlink" title="File mount"></a>File mount</h3><p>By default, you can also access your local machine’s file system from within the Linux Bash shell. Since your local drives are mounted under the <strong>/mnt</strong> folder of the subsystem. </p>
<p>In this way, you can develop the code with the productivity tools in Windows and build it in Linux environment.</p>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>This is another convenient point. <code>WSL</code> shares the IP address of Windows, as it is running on Windows.<br>As such you can access any ports on localhost e.g. if you had a web server running on port 8080, you could access it just by visiting <strong><a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a></strong> into your Windows browser.</p>
<h3 id="Set-up-the-development-environment"><a href="#Set-up-the-development-environment" class="headerlink" title="Set up the development environment"></a>Set up the development environment</h3><p>After install the Ubuntu system, I also install tools to prepare the development environment. For example, <code>GCC</code> to develop C language program as below. </p>
<img src="/images/linux-gcc.png" title="gcc in Linux" width="800px" height="600px">

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Based on my testing and experience, <code>WSL</code> can save developers’ time to set up Linux environment.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/08/06/win-wsl/" data-id="clkgd339u003ovomm54u5h8gc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binary-Search-Tree-delete-balanced-performance/" rel="tag">Binary Search Tree, delete, balanced, performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Foundation-Scholarship-LIFT/" rel="tag">Linux Foundation, Scholarship, LIFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scalability-AWS/" rel="tag">Scalability, AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" rel="tag">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Binary-Search-Tree-delete-balanced-performance/" style="font-size: 10px;">Binary Search Tree, delete, balanced, performance</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-Foundation-Scholarship-LIFT/" style="font-size: 10px;">Linux Foundation, Scholarship, LIFT</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/Scalability-AWS/" style="font-size: 10px;">Scalability, AWS</a> <a href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" style="font-size: 10px;">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/09/lift-scholarship-program/">Linux Foundation Scholarship</a>
          </li>
        
          <li>
            <a href="/2023/04/09/understand-more-aws-service-by-negative-cases/">Scalability Lessons Learned from Amazon Return to The Monolith</a>
          </li>
        
          <li>
            <a href="/2023/03/20/guide-to-service-fabric-architecture/">Build Microservices with Service Fabric: A Hands-on Approach</a>
          </li>
        
          <li>
            <a href="/2023/02/13/note-on-red-black-tree/">Understand Red Black Tree: part one - background</a>
          </li>
        
          <li>
            <a href="/2023/01/01/bst-deletion-issue/">Deletion operation in Binary Search Tree: successor or predecessor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
    <a href="/book-reviews" class="mobile-nav-link">Book Review</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>