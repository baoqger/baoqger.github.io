<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/page/4/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hystrix-circuit-breaker-part4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/29/hystrix-circuit-breaker-part4/" class="article-date">
  <time datetime="2021-06-29T09:19:53.000Z" itemprop="datePublished">2021-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/29/hystrix-circuit-breaker-part4/">Circuit breaker and Hystrix: part four - error rate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/06/29/hystrix-circuit-breaker-part4/" data-id="clghbduj2001zn4mmfwc9a794" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix-circuit-breaker-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/18/hystrix-circuit-breaker-part3/" class="article-date">
  <time datetime="2021-06-18T07:54:02.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/18/hystrix-circuit-breaker-part3/">Circuit breaker and Hystrix: part three - timeout</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In the <a href="https://baoqger.github.io/2021/05/30/hystrix-circuit-breaker-part2/">previous article</a>, we reviewed the <code>max concurrent request number</code> service degradation strategy. But some detailed techniques are not explained very clearly, which will be talked about in this article. And we will analyze <code>timeout</code> strategy as well.</p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><p>Compared with <code>max concurrent request number</code> strategy, <code>timeout</code> is very straightforward to understand. </p>
<p>As we mentioned in the previous article, the core logic of <code>hystrix</code> is inside the <code>GoC</code> function. <code>GoC</code> function internally runs two goroutines. You already see that the first goroutine contains the logic to send request to the target service and the strategy of <code>max concurrent request number</code>. How about the second goroutine? Letâ€™s review it as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(getSettings(name).Timeout)</span><br><span class="line">	<span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-cmd.finished:</span><br><span class="line">		<span class="comment">// returnOnce has been executed in another goroutine</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ctx.Err())</span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ErrTimeout)</span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>Note that A <strong>Timer</strong> is created with the timeout duration value from the settings. And a <code>select</code> statement lets this goroutine wait until one <code>case</code> condition receives value from the channel. The <strong>timeout</strong> case is just the 3nd one (when the first two cases are not triggered), which will run fallback logic with <strong>ErrTimeout</strong> error message. </p>
<p>So far you should be clear about the main structure and functionalities of these two goroutines. But in detail, there are two Golang techniques need your attention: <code>sync.Once</code> and <code>sync.Cond</code>.  </p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>You may already notice the following code block, which is repeated several times inside <code>GoC</code> function. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	returnTicket()</span><br><span class="line">	cmd.errorWithFallback(ctx, ErrTimeout) <span class="comment">// with various error types </span></span><br><span class="line">	reportAllEvent()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>returnOnce</strong> is type of <code>sync.Once</code>, which makes sure that the callback function of <code>Do</code> method only runs once among different goroutines. </p>
<p>In this specific case, it can guarantee that both <strong>returnTicket()</strong> and <strong>reportAllEvent()</strong> execute only once. This really makes sense, because if <strong>returnTicket()</strong> runs multiple times for one <code>GoC</code> call, then the current concurrent request number will not be correct, right? </p>
<p>I wrote another article about <code>sync.Once</code> in detail, you can refer to <a href="https://baoqger.github.io/2021/05/11/golang-sync-once/">that article</a> for more in-depth explanation. </p>
<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>The implementation of <strong>returnTicket</strong> function goes as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ticketCond := sync.NewCond(cmd)</span><br><span class="line">ticketChecked := <span class="literal">false</span></span><br><span class="line">returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Lock()</span><br><span class="line">	<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">		ticketCond.Wait() <span class="comment">// hang the current goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit.executorPool.Return(cmd.ticket)</span><br><span class="line">	cmd.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ticketCond</strong> is a condition variable, and in Golang it is type of <code>sync.Cond</code>. </p>
<p>Condition variable is useful in communication between different goroutines. Concretely, <code>Wait</code> method of <code>sync.Cond</code>will hung the current goroutine, and <code>Signal</code> method will wake up the blocking goroutine to continue executing. </p>
<p>In <code>hystrix</code> case , when <strong>ticketChecked</strong> is <strong>false</strong>, which means the current <code>GoC</code> call is not finished and the <strong>ticket</strong> should not be returned yet. So <strong>ticketCond.Wait()</strong> is called to block this goroutine and wait until the <code>GoC</code> call is completed which is notified by <code>Signal</code> method. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ticketChecked = <span class="literal">true</span></span><br><span class="line">ticketCond.Signal()</span><br></pre></td></tr></table></figure>

<p>Note that the above two lines of code are always called together. <strong>ticketChecked</strong> is set to <strong>true</strong> means that the current <code>GoC</code> call is finished and the <strong>ticket</strong> is ready to return. Moreover, the <code>Wait</code> method to hang the goroutine is placed inside a <strong>for</strong> loop, which is also a best practise technique. </p>
<p>For more explanation about <code>sync.Cond</code>, please refer to my <a href="https://baoqger.github.io/2021/05/14/golang-sync-cond/">another article</a>.</p>
<h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>Finally, letâ€™s see how <strong>fallback</strong> function is called when the target service is not responsive. </p>
<p>Letâ€™s recall that each <code>GoC</code> call will create a new <strong>command</strong> instance. And <strong>fallback</strong> function will be assigned to the field with the same name, which will be used later. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd := &amp;command&#123;</span><br><span class="line">	run:      run,</span><br><span class="line">	fallback: fallback, <span class="comment">// fallback logic here</span></span><br><span class="line">	start:    time.Now(),</span><br><span class="line">	errChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">	finished: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As we see in above sections, <strong>errorWithFallback</strong> method is triggered when <code>timeout</code> or <code>max concurrent request number</code> threshold is met.   </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *command)</span></span> errorWithFallback(ctx context.Context, err <span class="type">error</span>) &#123;</span><br><span class="line">	eventType := <span class="string">&quot;failure&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err == ErrCircuitOpen &#123;</span><br><span class="line">		eventType = <span class="string">&quot;short-circuit&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == ErrMaxConcurrency &#123;</span><br><span class="line">		eventType = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == ErrTimeout &#123;</span><br><span class="line">		eventType = <span class="string">&quot;timeout&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == context.Canceled &#123;</span><br><span class="line">		eventType = <span class="string">&quot;context_canceled&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == context.DeadlineExceeded &#123;</span><br><span class="line">		eventType = <span class="string">&quot;context_deadline_exceeded&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reportEvent(eventType)</span><br><span class="line">	fallbackErr := c.tryFallback(ctx, err)</span><br><span class="line">	<span class="keyword">if</span> fallbackErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.errChan &lt;- fallbackErr</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>errorWithFallback</strong> method will run the fallback by calling <strong>tryFallback</strong> and report the metric events such as <strong>fallback-failure</strong> and <strong>fallback-success</strong>(will discuss metric collection in next article).</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *command)</span></span> tryFallback(ctx context.Context, err <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.fallback == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fallbackErr := c.fallback(ctx, err) <span class="comment">// execute the fallback logic here</span></span><br><span class="line">	<span class="keyword">if</span> fallbackErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.reportEvent(<span class="string">&quot;fallback-failure&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;fallback failed with &#x27;%v&#x27;. run error was &#x27;%v&#x27;&quot;</span>, fallbackErr, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reportEvent(<span class="string">&quot;fallback-success&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we talked about the <code>timeout</code> strategy which is the simplest one among all the strategies provided by <code>hystrix</code>. Some detailed Golang techniques are reviewed as well to have a better understand the complex code logic. </p>
<p>In the next article letâ€™s see how to collect metrics in <code>hystrix</code> to realize the <code>error rate</code> strategy. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/06/18/hystrix-circuit-breaker-part3/" data-id="clghbduj1001wn4mma2jw27w7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix-circuit-breaker-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/30/hystrix-circuit-breaker-part2/" class="article-date">
  <time datetime="2021-05-30T08:41:20.000Z" itemprop="datePublished">2021-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/30/hystrix-circuit-breaker-part2/">Circuit breaker and Hystrix: part two - max concurrent requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the second article of this series, I will review the source code of <code>hystrix-go</code> project to understand how to design a <code>circuit breaker</code> and how to implement it with Golang. </p>
<p>If youâ€™re not familiar with <code>circuit breaker</code> pattern or <code>hystrix-go</code> project, please check my previous <a href="https://baoqger.github.io/2021/05/21/hystric-circuit-breaker-part1/">article</a> about it.  </p>
<h3 id="Three-service-degradation-strategies"><a href="#Three-service-degradation-strategies" class="headerlink" title="Three service degradation strategies"></a>Three service degradation strategies</h3><p><code>Hystrix</code> provides three different service degradation strategies to avoid the <code>cascading failure</code> happening in the entire system: <code>timeout</code>, <code>maximum concurrent request numbers</code> and <code>request error rate</code>. </p>
<ul>
<li><strong>timeout</strong>: if the service call doesnâ€™t return response successfully within a predefined time duration, then the fallback logic will run. This strategy is the simplest one. </li>
<li><strong>maximum concurrent request numbers</strong>: when the number of concurrent requests is beyond the threshold, then the fallback logic will handle the following request. </li>
<li><strong>request error rate</strong>: <code>hystrix</code> will record the response status of each service call, after the error rate reaches the threshold, the breaker will be open, and the fallback logic will execute before the breaker status changes back to closed. <code>error rate</code> strategy is the most complex one. </li>
</ul>
<p>This can be seen from the basic usage of <code>hystrix</code> as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(<span class="string">&quot;my_command&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">	Timeout:               <span class="type">int</span>(<span class="number">10</span> * time.Second),</span><br><span class="line">	MaxConcurrentRequests: <span class="number">100</span>,</span><br><span class="line">	ErrorPercentThreshold: <span class="number">25</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hystrix.Go(<span class="string">&quot;my_command&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// talk to dependency services</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// fallback logic when services are down</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>In the above usage case, you can see that <code>timeout</code> is set to 10 seconds, the maximum request number is 100, and the error rate threshold is 25 percentages.</p>
<p>In the consumer application level, thatâ€™s nearly all of the configuration you need to setup. <code>hystrix</code> will make the magin happen internally. </p>
<p>In this series of articles, I plan to show you the internals of <code>hystrix</code> by reviewing the source code. </p>
<p>Letâ€™s start from the easy ones: <code>max concurrent requests</code> and <code>timeout</code>. Then move on to explore the complex strategy <code>request error rate</code>. </p>
<h3 id="GoC"><a href="#GoC" class="headerlink" title="GoC"></a>GoC</h3><p>Based on the above example, you can see <code>Go</code> function is the door to the source code of <code>hystrix</code>, so letâ€™s start from it as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(name <span class="type">string</span>, run runFunc, fallback fallbackFunc)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	runC := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> run()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> fallbackC fallbackFuncC</span><br><span class="line">	<span class="keyword">if</span> fallback != <span class="literal">nil</span> &#123;</span><br><span class="line">		fallbackC = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fallback(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> GoC(context.Background(), name, runC, fallbackC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Go</code> function accept three parameters: </p>
<ul>
<li><strong>name</strong>: the command name, which is bound to the <code>circuit</code> created inside hystrix. </li>
<li><strong>run</strong>: a function contains the normal logic which send request to the dependency service.</li>
<li><strong>fallback</strong>: a function contains the fallback logic.</li>
</ul>
<p><code>Go</code> function just wraps <code>run</code> and <code>fallback</code> with <code>Context</code>, which is used to control and cancel goroutine, if youâ€™re not familiar with it then refer to my previous <a href="https://baoqger.github.io/2021/04/26/golang-context-source-code/">article</a>. Finally it will call <code>GoC</code> function.</p>
<p><code>GoC</code> function goes as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoC</span><span class="params">(ctx context.Context, name <span class="type">string</span>, run runFuncC, fallback fallbackFuncC)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// construct a new command instance</span></span><br><span class="line">	cmd := &amp;command&#123;</span><br><span class="line">		run:      run,</span><br><span class="line">		fallback: fallback,</span><br><span class="line">		start:    time.Now(),</span><br><span class="line">		errChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">		finished: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get circuit by command name</span></span><br><span class="line">	circuit, _, err := GetCircuit(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.errChan &lt;- err</span><br><span class="line">		<span class="keyword">return</span> cmd.errChan</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit = circuit</span><br><span class="line">	<span class="comment">//declare a condition variable sync.Cond: ticketCond, to synchronize among goroutines</span></span><br><span class="line">	<span class="comment">//declare a flag variable: ticketChecked, work together with ticketCond</span></span><br><span class="line">	ticketCond := sync.NewCond(cmd)</span><br><span class="line">	ticketChecked := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// declare a function: returnTicket, will execute when a concurrent request is done to return `ticket`</span></span><br><span class="line">	returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cmd.Lock()</span><br><span class="line">		<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">			ticketCond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		cmd.circuit.executorPool.Return(cmd.ticket)</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// declare a sync.Once instance: returnOnce, make sure the returnTicket function execute only once</span></span><br><span class="line">	returnOnce := &amp;sync.Once&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// declare another function: reportAllEvent, used to collect the metrics</span></span><br><span class="line">	reportAllEvent := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := cmd.circuit.ReportEvent(cmd.events, cmd.start, cmd.runDuration)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// launch a goroutine which executes the `run` logic</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cmd.finished &lt;- <span class="literal">true</span> &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !cmd.circuit.AllowRequest() &#123;</span><br><span class="line">			cmd.Lock()</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrCircuitOpen)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cmd.Lock()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> cmd.ticket = &lt;-circuit.executorPool.Tickets:</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrMaxConcurrency)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		runStart := time.Now()</span><br><span class="line">		runErr := run(ctx)</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> reportAllEvent()</span><br><span class="line">			cmd.runDuration = time.Since(runStart)</span><br><span class="line">			returnTicket()</span><br><span class="line">			<span class="keyword">if</span> runErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				cmd.errorWithFallback(ctx, runErr)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			cmd.reportEvent(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// launch the second goroutine for timeout strategy</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		timer := time.NewTimer(getSettings(name).Timeout)</span><br><span class="line">		<span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-cmd.finished:</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ctx.Err())</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrTimeout)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd.errChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I admit itâ€™s complex, but itâ€™s also the core of the entire <code>hystrix</code> project. Be patient, letâ€™s review it bit by bit carefully. </p>
<p>First of all, the code structure of <code>GoC</code> function is as follows:</p>
<p><img src="/images/GoC-hystrix.png" alt="GoC"></p>
<ol>
<li>Construct a new <code>Command</code> object, which contains all the information for each call to <code>GoC</code> function.</li>
<li>Get the <code>circuit breaker</code> by name (create it if it doesnâ€™t exist) by calling <code>GetCircuit(name)</code> function.</li>
<li>Declare condition variable <strong>ticketCond</strong> and <strong>ticketChecked</strong> with <code>sync.Cond</code> which is used to communicate between goroutines. </li>
<li>Declare function <strong>returnTicket</strong>. What is a <strong>ticket</strong>? What does it mean by <strong>returnTicket</strong>? Letâ€™s discuss it in detail later.</li>
<li>Declare another function <strong>reportAllEvent</strong>. This function is critical to <code>error rate</code> strategy, and we can leave it for detailed review in the following articles. </li>
<li>Declare an instance of <code>sync.Once</code>, which is another interesting <code>synchronization primitives</code> provided by golang.</li>
<li>Launch two goroutines, each of which contains many logics too. Simply speaking, the first one contains the logic of sending requests to the target service and the strategy of <code>max concurrent request number</code>, and the second one contains the <code>timeout</code> strategy. </li>
<li>Return a <code>channel</code> type value</li>
</ol>
<p>Letâ€™s review each of them one by one. </p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p><code>command</code> struct goes as follows, which embeds <strong>sync.Mutex</strong> and defines several fields: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> command <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line"></span><br><span class="line">	ticket      *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	start       time.Time</span><br><span class="line">	errChan     <span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line">	finished    <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">	circuit     *CircuitBreaker</span><br><span class="line">	run         runFuncC</span><br><span class="line">	fallback    fallbackFuncC</span><br><span class="line">	runDuration time.Duration</span><br><span class="line">	events      []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that <code>command</code> object iteself doesnâ€™t contain command name information, and its lifecycle is just inside the scope of one <code>GoC</code> call. It means that the statistic metrics about the service request like <code>error rate</code> and <code>concurrent request number</code> are not stored inside command object. Instead, such metrics are stored inside <strong>circuit</strong> field which is <code>CircuitBreaker</code> type. </p>
<h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>As we mentioned in the workflow of <code>GoC</code> function, <code>GetCircuit(name)</code> is called to get or create the <code>circuit breaker</code>. It is implemented inside <code>circuit.go</code> file as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	circuitBreakersMutex = &amp;sync.RWMutex&#123;&#125;</span><br><span class="line">	circuitBreakers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*CircuitBreaker)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCircuit</span><span class="params">(name <span class="type">string</span>)</span></span> (*CircuitBreaker, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	circuitBreakersMutex.RLock()</span><br><span class="line">	_, ok := circuitBreakers[name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		circuitBreakersMutex.RUnlock()</span><br><span class="line">		circuitBreakersMutex.Lock()</span><br><span class="line">		<span class="keyword">defer</span> circuitBreakersMutex.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> cb, ok := circuitBreakers[name]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> cb, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		circuitBreakers[name] = newCircuitBreaker(name)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> circuitBreakersMutex.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> circuitBreakers[name], !ok, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic is very straightforward. All the circuit breakers are stored in a map object <strong>circuitBreakers</strong> with the <strong>command name</strong> as the key. </p>
<p>The <code>newCircuitBreaker</code> constructor function and <code>CircuitBreaker</code> struct are as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name                   <span class="type">string</span></span><br><span class="line">	open                   <span class="type">bool</span></span><br><span class="line">	forceOpen              <span class="type">bool</span></span><br><span class="line">	mutex                  *sync.RWMutex</span><br><span class="line">	openedOrLastTestedTime <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	executorPool *executorPool   <span class="comment">// used in the strategy of max concurrent request number </span></span><br><span class="line">	metrics      *metricExchange <span class="comment">// used in the strategy of request error rate</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCircuitBreaker</span><span class="params">(name <span class="type">string</span>)</span></span> *CircuitBreaker &#123;</span><br><span class="line">	c := &amp;CircuitBreaker&#123;&#125;</span><br><span class="line">	c.Name = name</span><br><span class="line">	c.metrics = newMetricExchange(name)</span><br><span class="line">	c.executorPool = newExecutorPool(name)</span><br><span class="line">	c.mutex = &amp;sync.RWMutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All the fields of <code>CircuitBreaker</code> are important to understand how the breaker works.</p>
<img src="/images/circuitbreakstruct.png" title="circuitbreak" width="300px" height="400px">

<p>There are two fields that are not simple type need more analysis, include <code>executorPool</code> and <code>metrics</code>. </p>
<ul>
<li><strong>executorPool</strong>: used for <code>max concurrent request number</code> strategy, which is just this articleâ€™s topic.</li>
<li><strong>metrics</strong>: used for <code>request error rate</code> strategy, which will be discussed in the next article, all right? </li>
</ul>
<h3 id="executorPool"><a href="#executorPool" class="headerlink" title="executorPool"></a>executorPool</h3><p>We can find <code>executorPool</code> logics inside the <code>pool.go</code> file:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> executorPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Metrics *poolMetrics</span><br><span class="line">	Max     <span class="type">int</span></span><br><span class="line">	Tickets <span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125; <span class="comment">// Tickets channel </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newExecutorPool</span><span class="params">(name <span class="type">string</span>)</span></span> *executorPool &#123;</span><br><span class="line">	p := &amp;executorPool&#123;&#125;</span><br><span class="line">	p.Name = name</span><br><span class="line">	p.Metrics = newPoolMetrics(name)</span><br><span class="line">	p.Max = getSettings(name).MaxConcurrentRequests</span><br><span class="line"></span><br><span class="line">	p.Tickets = <span class="built_in">make</span>(<span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125;, p.Max)</span><br><span class="line">	<span class="comment">// send Max numbers of value into the Tickets channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.Max; i++ &#123;</span><br><span class="line">		p.Tickets &lt;- &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It makes use of golang <code>channel</code> to realize <code>max concurrent request number</code> strategy. Note that <code>Tickets</code> field, which is a buffered channel with capicity of <strong>MaxConcurrentRequests</strong> is created. And in the following <strong>for</strong> loop, make the buffered channel full by sending value into the channel until reaching the capacity. </p>
<p>As we have shown above, in the first goroutine of <code>GoC</code> function, the <code>Tickets</code> channel is used as follows:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cmd.ticket = &lt;-circuit.executorPool.Tickets: <span class="comment">// receive ticket from Tickets channel</span></span><br><span class="line">		ticketChecked = <span class="literal">true</span></span><br><span class="line">		ticketCond.Signal()</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ticketChecked = <span class="literal">true</span></span><br><span class="line">		ticketCond.Signal()</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ErrMaxConcurrency) <span class="comment">// run fallback logic when concurrent requests reach threshold</span></span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Each call to <code>GoC</code> function will get a <strong>ticket</strong> from <strong>circuit.executorPool.Tickets</strong> channel until no <strong>ticket</strong> is left, which means the number of concurrent requests reaches the threshold. In that case, the <code>default</code> case will execute , and the service will be gracefully degraded with fallback logic.</p>
<p>On the other side, after each call to <code>GoC</code> is done, the <strong>ticket</strong> need to be sent back to the <strong>circuit.executorPool.Tickets</strong>, right? Do you remember the <code>returnTicket</code> function mentioned in above section. Yes, it is just used for this purpose. The <code>returnTicket</code> function defined in <code>GoC</code> function goes as follows:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Lock()</span><br><span class="line">	<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">		ticketCond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit.executorPool.Return(cmd.ticket) <span class="comment">// return ticket to the executorPool</span></span><br><span class="line">	cmd.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It calls <code>executorPool.Return</code> function: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return function in pool.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *executorPool)</span></span> Return(ticket *<span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">if</span> ticket == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.Metrics.Updates &lt;- poolMetricsUpdate&#123;</span><br><span class="line">		activeCount: p.ActiveCount(),</span><br><span class="line">	&#125;</span><br><span class="line">	p.Tickets &lt;- ticket <span class="comment">// send ticket back to Tickets channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The design and implementation of <strong>Tickets</strong> is a great example of <code>golang channel</code> in the real-world application.  </p>
<p>In summary, the <code>max concurrent request number</code> strategy can be illustrated as follows:</p>
<img src="/images/hystrix-concurrent-architecture.png" title="circuitbreak" width="800px" height="400px">


<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, <code>max concurrent requests</code> strategy in <code>hystrix</code> is reviewed carefully, and I hope you can learn something interesting from it.</p>
<p>But I didnâ€™t cover the detailed logics inside <code>GoC</code> function, including <code>sync.Cond</code>, <code>sync.Once</code> and fallback logics. Letâ€™s review them and <code>timeout</code> strategy together in the next article. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/30/hystrix-circuit-breaker-part2/" data-id="clghbduj1001vn4mm3xc8h6y7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystric-circuit-breaker-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/hystric-circuit-breaker-part1/" class="article-date">
  <time datetime="2021-05-21T07:25:19.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/hystric-circuit-breaker-part1/">Circuit breaker and Hystrix: part one - introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this series of articles, I want to talk about <code>circuit breaker</code> pattern based on an popular open source project <code>hystrix</code> (in fact, I will take a look at the golang version <a target="_blank" rel="noopener" href="https://github.com/afex/hystrix-go">hystrix-go</a>, instead of the <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">original version</a> which is written in Java).</p>
<p>As the first article of this series, I will give a general introduction to <code>circuit breaker</code>, let you know what it is and why it is important. Moreover, letâ€™s review the background about the project <code>hystrix-go</code> and <code>hystrix</code>, and understand the basic usage with a small demo example. </p>
<h3 id="Circuit-breaker"><a href="#Circuit-breaker" class="headerlink" title="Circuit breaker"></a>Circuit breaker</h3><p>Software in distributed architectures generally have many dependencies, and the failure at some point for each dependency(even the most reliable service) is inevitable. </p>
<p>What happens if our failing service becomes unresponsive? All services that rely on it have risks to become unresponsive, too. This is called <code>catastrophic cascading failure.</code></p>
<p>The basic idea behind the circuit breaker is very simple. A circuit breaker works by wrapping calls to a target service and keeps monitoring the failure rates. Once the failures reach a certain threshold, the circuit breaker will trip ï¼Œand all the further calls to the circuit return with a fault or error. </p>
<p>The design philosophy behind the circuit breaker pattern is <code>fail fast</code>: when a service becomes unresponsive, other services relying on it should stop waiting for it and start dealing with the fact that the failing service may be unavailable. By preventing a single serviceâ€™s failure cascading through the entire system, the circuit breaker pattern contributes to the <code>stability</code> and <code>resilience</code> of the whole system.  </p>
<p>The circuit breaker pattern can be implemented as a finite-state machine shown below:</p>
<p><img src="/images/circuit-breaker.png" alt="circuit-breaker"></p>
<p>There are three statuses: <code>open</code>, <code>closed</code> and <code>half-open</code></p>
<ul>
<li><strong>closed</strong>: Requests are passed to the target service. Keep monitoring the metrics like error rate, request numbers and timeout. When these metrics exceed a specific threshold(which is set by the developer), the breaker is tripped and transitions into <code>open</code> status.   </li>
<li><strong>open</strong>: Requests are not passed to the target service, instead the <code>fallback</code> logic(which is defined by developer as well) will be called to handle the failure. The breaker will stay <code>open</code> status for a period of time called <code>sleeping window</code>, after which the breaker can transition from <code>open</code> to <code>half-open</code>.  </li>
<li><strong>half-open</strong>: In this status, a limited number of requests are passed to the target service, which is aims at resetting the status. If the target service can response successfully then the break is <code>reset</code> back to <code>closed</code> status. Or else the breaker transitions back to <code>open</code> status. </li>
</ul>
<p>Thatâ€™s basic background about circuit breaker, you can find much more <a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">information</a> about it on line. </p>
<p>Next, letâ€™s investigate the project <code>hystrix</code>. </p>
<h3 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h3><p><code>hystrix</code> is a very popular open source project. You can find everything about it in this <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">link</a>. </p>
<p>I want to quote several important points from the above link. Hystrix is designed to do the following:</p>
<ul>
<li>Give protection from and control over latency and failure from dependencies accessed (typically over the network) via third-party client libraries.</li>
<li>Stop cascading failures in a complex distributed system.</li>
<li>Fail fast and rapidly recover.</li>
<li>Fallback and gracefully degrade when possible.</li>
<li>Enable near real-time monitoring, alerting, and operational control.</li>
</ul>
<p>You can see <code>hystrix</code> perfectly implements the idea of circuit breaker pattern we talked about in the last section, right? </p>
<p>The <code>hystrix</code> project is developed with <code>Java</code>. In this sereis of articles I prefer to use a golang version <code>hystrix-go</code>, which is a simplified version but implements all the main designs and ideas about circuit breaker. </p>
<p>For the usage of <code>hystrix-go</code>, you can find it in this <a target="_blank" rel="noopener" href="https://github.com/afex/hystrix-go">link</a>, which is very straightforward to understand. And you can easily find many other articles online with demo examples to show more usage level stuff. Please go head to read.</p>
<p>In my articles, I want to go into the source code of <code>hystrix-go</code> and have an advanced investigation about how <code>circuit breaker</code> is implemented. Please follow up to read the next articles in this series. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, I talked about the background of circuit breaker pattern and the basic information of the popular open-source project in this field <code>hystrix-go</code>. Next step, we will take an in-depth look at the source code of this project. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/21/hystric-circuit-breaker-part1/" data-id="clghbduj0001tn4mm7kr245yv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-sync-cond" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/14/golang-sync-cond/" class="article-date">
  <time datetime="2021-05-14T02:14:18.000Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/14/golang-sync-cond/">golang-sync-cond</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/14/golang-sync-cond/" data-id="clghbduis0012n4mm18ev1u28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-sync-once" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/11/golang-sync-once/" class="article-date">
  <time datetime="2021-05-11T12:07:55.000Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/11/golang-sync-once/"> Golang synchronization primitives source code analysis: part one - sync.Once</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the following series of posts, I will take an in-depth look at the <code>synchronization primitives</code> provided by Golang. </p>
<p>Although the recommended synchronization mechanism in Golang is <code>channel</code>, there are several powerful <code>synchronization primitives</code> provided in Golang <code>sync</code> package. Based on the official document, <strong>Other than the Once and WaitGroup types, most are intended for use by low-level library routines</strong>. If you read the code of low-level open source projects or the standard packages, you will see synchronization primitives in <code>sync</code> package frequently. </p>
<p>As the first post in this series, letâ€™s check the source code of <code>sync.Once</code>, which is also the simplest one.</p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>If you have several logics running in various go-routines, and you want only one of the logics will execute finally. For this kind of scenario, <code>sync.Once</code> is a perfect option for you. </p>
<p>Letâ€™s review the source code of <code>sync.Once</code> defined inside the <code>once.go</code> file: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	done <span class="type">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">		o.doSlow(f)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Struct <code>Once</code> has a status flag <code>done</code> whose value is <code>0</code> when initialized. Wrap the logic you want to execute in a function <code>f</code>, and pass this function <code>f</code> to the <code>Do()</code> method. When <code>Do</code> is called for the first time, the logic in <code>f</code> executes after that <code>done</code> flag is set to <code>1</code>, other calls to <code>Do</code> donâ€™t execute <code>f</code>. </p>
<p>One misleading point is  <strong>If <code>once.Do(f)</code> is called multiple times, only the first call will invoke <code>f</code>, even if <code>f</code> has a different value in each invocation</strong>. Check the following example:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> TaskOne()</span><br><span class="line">	<span class="keyword">go</span> TaskTwo()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintTask</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Task %d, Run once\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TaskOne</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		PrintTask(<span class="number">1</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Run this every time&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TaskTwo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	doOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		PrintTask(<span class="number">2</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Run this every time&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Even <code>Do</code> is called twice with different <code>f</code> logic, but only the first call is invoked since they are bound to the same instance of <code>Once</code>. </p>
<h3 id="fast-path-and-slow-path"><a href="#fast-path-and-slow-path" class="headerlink" title="fast path and slow path"></a>fast path and slow path</h3><p>As you saw above, the implementation of <code>sync.Once</code> is not complex. But one question comes to my mind when I double check the code. Why do we need split the logics into two functions <code>Do</code> and <code>doSlow</code>? Why the second function name is <code>doSlow</code>, and what does <code>slow</code> mean here?</p>
<p>Do you have similar questions? </p>
<p>I found the answer in the comments of <code>once.go</code> file. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">	o.doSlow(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that it mentioned two words: <code>fast path</code> and <code>slow path</code>. </p>
<ul>
<li>Fast path is a term used in computer science to describe a path with shorter instruction path length through a program compared to the â€˜normalâ€™ path. For a fast path to be effective it must handle the most commonly occurring tasks more efficiently than the â€˜normalâ€™ path, leaving the latter to handle uncommon cases, corner cases, error handling, and other anomalies. <strong>Fast paths are a form of optimization</strong>. </li>
</ul>
<p>In the <code>Once</code> case, since the first call to <code>Do</code> function will set <code>done</code> to 1, so the most common case or status for <code>Once</code> is the <code>done</code> flag equals to 1. The <code>fast path</code> in <code>Do</code> function is just for this common case. While the <code>done</code> flag equals to initial status 0 can be regarded as uncommon case, which is specially handled in the <code>doSlow</code> function. The performance can be optimized in this way.</p>
<h3 id="hot-path"><a href="#hot-path" class="headerlink" title="hot path"></a>hot path</h3><p>Another very interesting concept worth mentioning is <code>hot path</code>, and it occurs in the <code>Once</code> struct design.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line">	<span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line">	<span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line">	<span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line">	<span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">	done <span class="type">uint32</span></span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At first glance, itâ€™s just plain and ordinary struct, but the comments emphasize that <code>done</code> <strong>is first in the struct because it is used in the hot path</strong>. It means that <code>done</code> is defined as the first field in <code>Once</code> struct on purpose. And the purpose is also described in the comment <strong>Placing done first allows more compact instructions on some architectures (amd64/x86), and fewer instructions (to calculate offset) on other architectures.</strong></p>
<p>What does that mean? I found a great answer in this <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59174176/what-does-hot-path-mean-in-the-context-of-sync-once">post</a>. The conclusion is:</p>
<ul>
<li><p>A <code>hot path</code> is a sequence of instructions executed very frequently.</p>
</li>
<li><p>When accessing the first field of a structure, we can directly dereference the pointer to the structure to access the first field. To access other fields, we need to provide an <code>offset</code> from the first value in addition to the struct pointer.</p>
</li>
<li><p>In machine code, this offset is an additional value to pass with the instruction which makes it longer. The performance impact is that the CPU must perform an addition of the offset to the struct pointer to get the address of the value to access.</p>
</li>
<li><p>Thus machine code to <code>access the first field of a struct is more compact and faster</code>.</p>
</li>
</ul>
<p>Simply speaking, accessing the first field of a struct is faster since the CPU doesnâ€™t need to compute the memory offset!</p>
<p>This is really a good lesson to show the high-level code you programmed can have such a big difference in the bottom level.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/11/golang-sync-once/" data-id="clghbduip000vn4mm2eah44w1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-context-source-code-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/28/golang-context-source-code-part2/" class="article-date">
  <time datetime="2021-04-28T05:38:51.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/28/golang-context-source-code-part2/">Golang Context package source code analysis: part 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/04/26/golang-context-source-code/">last post</a>, I shared the first part about the <code>context</code> package: <code>valueCtx</code> and <code>cancelCtx</code>. Let us continue the journey to discover more in this post. </p>
<h3 id="WithTimeout-and-WithDeadline"><a href="#WithTimeout-and-WithDeadline" class="headerlink" title="WithTimeout and WithDeadline"></a>WithTimeout and WithDeadline</h3><p>As usual, let us start with an example: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cancelCtx, cancel := context.WithTimeout(context.Background(), time.Second*<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">go</span> task(cancelCtx)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since we already know the behavior of <code>cancelCtx</code>, itâ€™s quite straightforward to understand how <code>WithTimeout</code> works. It accepts a timeout duration after which the <code>done</code> channel will be closed and context will be canceled. And a cancel function will be returned as well, which can be called in case the context needs to be canceled before timeout. </p>
<p><code>WithDeadline</code> usage is quite similar to <code>WithTimeout</code>, you can find related example easily. Let us review the source code:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer </span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since <code>WithTimeout</code> and <code>WithDeadline</code> have many common points between them, so they share the same type of context: <code>timerCtx</code>, which embeds <code>cancelCtx</code> and defines two more properties: <code>timer</code> and <code>deadline</code>. </p>
<p>Let us review what happens when we create a <code>timerCtx</code>:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Get deadline time of parent context. </span></span><br><span class="line">	<span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		<span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">		<span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c := &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur := time.Until(d)</span><br><span class="line">	<span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">		<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123; <span class="comment">// &#x27;err&#x27; field of the embedded cancelCtx is promoted </span></span><br><span class="line">		c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compared to <code>WithCancle</code> and <code>WithValue</code>, <code>WithDeadline</code> is more complex, let us go through bit by bit.</p>
<p>Firstly, <code>parent.Deadline</code> will get the deadline time for parent context. The <code>Deadline</code> method signature was defined in the <code>Context</code> interface as below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the context package, only <code>emptyCtx</code> and <code>timerCtx</code> type implement this method:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So when we call <code>parent.Deadline()</code>, if the parent context is also type of <code>timerCtx</code> which implements its own <code>Deadline()</code> method, then you can get the deadline time of the parent context. Otherwise if the parent context is type of <code>cancelCtx</code> or <code>valueCtx</code>, then finally the <code>Deadline()</code> method of <code>emptyCtx</code> will be called and you will get the zero value of type <code>time.Time</code> and <code>bool</code> (if you have interest, you can verify by yourself the zero value: <strong>0001-01-01 00:00:00 +0000 UTC</strong> and <strong>false</strong>).  </p>
<p>If parentâ€™s deadline is earlier than the passed in deadline parameter, then directly return a <code>cancelCtx</code> by calling <code>WithCancel(parent)</code>. Of course when the passed in deadline is reasonable, we need to create a <code>timerCtx</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inside WithDeadline() function</span></span><br><span class="line">...</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">	cancelCtx: newCancelCtx(parent),</span><br><span class="line">	deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>In the above code, you see <code>propagateCancel</code> method again, I have discussed about it in the last post, if you donâ€™t understand it, please refer <a href="https://baoqger.github.io/2021/04/26/golang-context-source-code/">here</a>.</p>
<p>Similar to <code>cancelCtx</code>, <code>timerCtx</code> sends the context cancel signal by closing the done channel by calling its own <code>cancel</code> method. There two scenarios when cancelling the context:</p>
<ul>
<li>timeout cancel: when the deadline exceeded, automatically close the done channel; </li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside WithDeadline function</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// timeout cancel</span></span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>manual cancel: call the returned cancel function to close the done channel before the deadline;<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside WithDeadline function</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// return the cancel function as the second return value</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Both scenarios call <code>cancel</code> method: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	c.cancelCtx.cancel(<span class="literal">false</span>, err) <span class="comment">// close the done channel and set err field</span></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		<span class="comment">// Remove this timerCtx from its parent cancelCtx&#x27;s children.</span></span><br><span class="line">		<span class="comment">// Note: timerCtx c&#x27;s parent is c.cancelCtx.Context</span></span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="comment">// stop and clean the timer</span></span><br><span class="line">	<span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timerCtx</code> implements <code>cancel</code> method to stop and reset the timer then delegate to <code>cancelCtx.cancel</code>. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In the second part of this post series, we discussed how <code>timeout</code> and <code>deadline</code> context are implemented in the source code level. In this part, Golang struct embedding technique is used a lot, you can compare it with traditional OOP solution to have a deep understanding.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/04/28/golang-context-source-code-part2/" data-id="clghbduio000pn4mm9z6xduvn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-context-source-code" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/26/golang-context-source-code/" class="article-date">
  <time datetime="2021-04-26T12:44:48.000Z" itemprop="datePublished">2021-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/26/golang-context-source-code/">Golang Context package source code analysis: part 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>As a Golang user and learner, I always think Golang standard package is a great learning resource, which can provide best practices for both the language itself and various software or programming concepts. </p>
<p>In this post, I will share what I learned about package <code>context</code>.</p>
<p><code>context</code> is widely used in the Golang ecosystem, and I bet you must often come across it. Many standard packages rely on it. </p>
<p>There are many good <a target="_blank" rel="noopener" href="https://golangbyexample.com/using-context-in-golang-complete-guide/">articles</a> online explaining the background and usage examples of <code>context</code>, I will not spend too much time on that, just add a brief introduction here. </p>
<p>The problems <code>context</code> plans to solve areï¼š</p>
<ul>
<li>Letâ€™s say that you started a function and you need to pass some common parameters to the downstream functions. You cannot pass these common parameters each as an argument to all the downstream functions.</li>
<li>You started a goroutine which in turn start more goroutines and so on. Suppose the task that you were doing is no longer needed. Then how to inform all child goroutines to gracefully exit so that resources can be freed up</li>
<li>A task should be finished within a specified timeout of say 2 seconds. If not it should gracefully exit or return.</li>
<li>A task should be finished within a deadline eg it should end before 5 pm . If not finished then it should gracefully exit and return</li>
</ul>
<p>You can refer to this <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/gotham-context.slide#1">slide</a> from the author of context package to understand more about the background. </p>
<p>In this post, I will show you the details of context package source code. You can find all the related source code inside the <code>context.go</code> file. You will notice that <code>context</code> package content is not long, and there are roughly 500 lines of code. Moreover, there are many comments, so the actual code is only half. These 200+ lines of code are a great piece of learning resource in my eyes. </p>
<h3 id="Source-code-analysis"><a href="#Source-code-analysis" class="headerlink" title="Source code analysis"></a>Source code analysis</h3><h4 id="Context-interface-and-emptyCtx"><a href="#Context-interface-and-emptyCtx" class="headerlink" title="Context interface and emptyCtx"></a>Context interface and emptyCtx</h4><p>The most basic data structure of context is the <code>Context</code> interface as below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Context</code> is just an interface, which is very hard to imagine how to use it. So let us continue reviewing some types implement such interface. </p>
<p>When context is used, generally speaking, the first step is creating the root context with <code>context.Background()</code> function(the contexts are chained together one by one and form a tree structure, and the root context is the first one in the chain). Letâ€™s check what it is: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Background</code> function return the <code>background</code> which is a global variable declared as <code>new(emptyCtx)</code>. So what is <code>emptyCtx</code>, let continue:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An emptyCtx is never canceled, has no values, and has no deadline. It is not</span></span><br><span class="line"><span class="comment">// struct&#123;&#125;, since vars of this type must have distinct addresses.</span></span><br><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> e &#123;</span><br><span class="line">	<span class="keyword">case</span> background:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">	<span class="keyword">case</span> todo:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can see that <code>emptyCtx</code> is declared as a new customized type based on <code>int</code>.  In fact, itâ€™s not important  that <code>emptyCtx</code> is based on <code>int</code>, <code>string</code> or whatever. The important thing is all the four methods defined in interface <code>Context</code> return <code>nil</code>. So the root context <strong>is never canceled, has no values, and has no deadline</strong>. </p>
<p>Letâ€™s continue to review other data types.</p>
<h4 id="valueCtx-and-WithValue"><a href="#valueCtx-and-WithValue" class="headerlink" title="valueCtx and WithValue"></a>valueCtx and WithValue</h4><p>As mentioned above, one typical usage of context is passing data. In this case, you need to create a <code>valueCtx</code> with <code>WithValue</code> function. For example, the following example:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootCtx := context.Background()</span><br><span class="line"></span><br><span class="line">childCtx := context.WithValue(rootCtx, <span class="string">&quot;msgId&quot;</span>, <span class="string">&quot;someMsgId&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>WithValue</code> is a function has only one return value:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please ignore the <code>reflectlite</code> part, I will give a in-depth discussion about it in another post. In this post, we only need to care the return value type is <code>&amp;valueCtx</code>:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is one interesting Golang language feature here: <code>embedding</code>, which realizes <code>composition</code>. In this case, <code>valueCtx</code> has all the four methods defined in <code>Context</code>.<br>In fact, <code>embedding</code> is worthy much more discussion. Simplying speaking, there are 3 types of embedding: <strong>struct in struct</strong>, <strong>interface in interface</strong> and <strong>interface in struct</strong>. <code>valueCtx</code> is the last type, you can refer to this great <a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2020/embedding-in-go-part-1-structs-in-structs/">post</a></p>
<p>When you want to get the value out, you can use the <code>Value</code> method: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If the provided <code>key</code> parameter does not match the current contextâ€™s key, then the parent contextâ€™s <code>Value</code> method will be called. If we still canâ€™t find the key, the parent contextâ€™s will call its parent as well. The search will pass along the chain until the root node which will return <code>nil</code> as we mentioned above:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, letâ€™s review another interesting type: <code>cancelCtx</code></p>
<h4 id="cancelCtx-and-WithCancel"><a href="#cancelCtx-and-WithCancel" class="headerlink" title="cancelCtx and WithCancel"></a>cancelCtx and WithCancel</h4><p>First, letâ€™s see how to use <code>cancelCtx</code> and <code>WithCanel</code> with a simple example:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cancelCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> task(cancelCtx)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	cancelFunc()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(ctx.Err())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When main goroutine wants to cancel <code>task</code> goroutine, it can just call <code>cancelFunc</code>. Then the task goroutine will exit and stop running. In this way, goroutine management will be easy task. Letâ€™s review the code:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cancelCtx</code> is complex, letâ€™s go through bit by bit. </p>
<p><code>WithCancel</code> returns two values, the first one <code>&amp;c</code> is type <code>cancelCtx</code> which is created with <code>newCancelCtx</code>, the second one <code>func() &#123; c.cancel(true, Canceled) &#125;</code> is type <code>CancenlFunc</code>(just a general function). </p>
<p>Letâ€™s review <code>cancelCtx</code> firstly:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">	<span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">	err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Context</code> is embedded inside <code>cancelCtx</code> as well. Also it defines several other fields. Letâ€™s see how it works by checking the receiver methods:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Done</code> method returns channel <code>done</code>. In the above demo, <strong>task</strong> goroutine listen for cancel signal from this done channel like this:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">	fmt.Println(ctx.Err())</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The signal is trigger by calling the cancle function, so letâ€™s review what happens inside it and how the signals are sent to the channel. All the logic is inside <code>cancel</code> method of <code>cancelCtx</code>:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// set the err property when cancel is called for the first time</span></span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> acquiring the child&#x27;s lock while holding parent&#x27;s lock.</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As shown above, <code>cancelCtx</code> has four properties, we can understand their purpose clearly in this <code>cancel</code>: </p>
<ul>
<li><code>mu</code>: a general lock to make sure goroutine safe and avoid race condition;</li>
<li><code>err</code>: a flag representing whether the cancelCtx is cancelled or not. When the cancelCtx is created, <code>err</code> value is <code>nil</code>. When <code>cancel</code> is called for the first time, it will be set by <code>c.err = err</code>;</li>
<li><code>done</code>: a channel which sends cancel signal. To realize this, context just <code>close</code> the done channel instead of send data into it. This is an <strong>interesting point</strong> which is different from my initial imagination before I review the source code. Yes, after a channel is closed, the receiver can still get <code>zero value</code> from the closed channel based on the channel type. Context just make use of this feature.</li>
<li><code>children</code>: a <code>Map</code> containing all its child contexts. When current context is cancelled, the cancel action will be propogated to the children by calling <code>child.cancel(false, err)</code> in the for loop. Then next question is when the parent-child relationship is established? The secret is inside the <code>propagateCancel()</code> function;</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// parent is already canceled</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// parent has already been canceled</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>propagateCancel</code> contains many logics, and some of them canâ€™t be understood easily, I will write another post for those parts. But in this post, we only need to understand how to establish the relationship between parent and child for genernal cases. </p>
<p>The key point is function <code>parentCancelCtx</code>, which is used to find the innermost cancellable ancestor context:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Value() will propagate to the root context</span></span><br><span class="line">	p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	ok = p.done == done</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can notice that <code>Value</code> method is called, since we analyzed in the above section, <code>Value</code> will pass the search until the root context. Great. </p>
<p>Back to the <code>propagateCancel</code> function, if cancellable ancestor context is found, then current context is added into the <code>children</code> hash map as below:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">	p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The relationship is established. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we review the source code of <code>Context</code> package and understand how <code>Context</code>,  <code>valueCtx</code> and <code>cancelCtx</code> works. </p>
<p><code>Context</code> contains the other two types of context: <code>timeOut</code> context and <code>deadLine</code> context, Letâ€™s work on that in the second part of this post series. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/04/26/golang-context-source-code/" data-id="clghbduio000rn4mm93re53u7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-bytes-buffer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/04/golang-bytes-buffer/" class="article-date">
  <time datetime="2021-04-04T09:50:14.000Z" itemprop="datePublished">2021-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/04/golang-bytes-buffer/">Golang bytes.Buffer and bufio</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In this post, I will show you the usage and implementation of two Golang standard packagesâ€™ : <code>bytes</code> (especially <code>bytes.Buffer</code>) and <code>bufio</code>.</p>
<p>These two packages are widely used in the Golang ecosystem especially works related to networking, files and other IO tasks. </p>
<h3 id="Demo-application"><a href="#Demo-application" class="headerlink" title="Demo application"></a>Demo application</h3><p>One good way to learn new programming knowledge is checking how to use it in real-world applications. The following great demo application is from the open source book <code>Network Programming with Go by Jan Newmarch</code>.</p>
<p>For your convenience, I paste the code here. This demo consists of two parts: client side and server side, which together form a simple directory browsing protocol. The client would be at the user end, talking to a server somewhere else. The client sends commands to the server side that allows you to list files in a directory and print the directory on the server. </p>
<p>First is the client side program: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// strings used by the user interface</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    uiDir  = <span class="string">&quot;dir&quot;</span></span><br><span class="line">    uiCd   = <span class="string">&quot;cd&quot;</span></span><br><span class="line">    uiPwd  = <span class="string">&quot;pwd&quot;</span></span><br><span class="line">    uiQuit = <span class="string">&quot;quit&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// strings used across the network</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    DIR = <span class="string">&quot;DIR&quot;</span></span><br><span class="line">    CD  = <span class="string">&quot;CD&quot;</span></span><br><span class="line">    PWD = <span class="string">&quot;PWD&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Usage: &quot;</span>, os.Args[<span class="number">0</span>], <span class="string">&quot;host&quot;</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, host+<span class="string">&quot;:1202&quot;</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="comment">// lose trailing whitespace</span></span><br><span class="line">        line = strings.TrimRight(line, <span class="string">&quot; \t\r\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// split into command + arg</span></span><br><span class="line">        strs := strings.SplitN(line, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// decode user request</span></span><br><span class="line">        <span class="keyword">switch</span> strs[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">case</span> uiDir:</span><br><span class="line">            dirRequest(conn)</span><br><span class="line">        <span class="keyword">case</span> uiCd:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(strs) != <span class="number">2</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;cd &lt;dir&gt;&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;CD \&quot;&quot;</span>, strs[<span class="number">1</span>], <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">            cdRequest(conn, strs[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">case</span> uiPwd:</span><br><span class="line">            pwdRequest(conn)</span><br><span class="line">        <span class="keyword">case</span> uiQuit:</span><br><span class="line">            conn.Close()</span><br><span class="line">            os.Exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;Unknown command&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirRequest</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(DIR + <span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    result := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// read till we hit a blank line</span></span><br><span class="line">        n, _ := conn.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result.Write(buf[<span class="number">0</span>:n])</span><br><span class="line">        length := result.Len()</span><br><span class="line">        contents := result.Bytes()</span><br><span class="line">        <span class="keyword">if</span> <span class="type">string</span>(contents[length<span class="number">-4</span>:]) == <span class="string">&quot;\r\n\r\n&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="type">string</span>(contents[<span class="number">0</span> : length<span class="number">-4</span>]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cdRequest</span><span class="params">(conn net.Conn, dir <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(CD + <span class="string">&quot; &quot;</span> + dir))</span><br><span class="line">    <span class="keyword">var</span> response [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    n, _ := conn.Read(response[<span class="number">0</span>:])</span><br><span class="line">    s := <span class="type">string</span>(response[<span class="number">0</span>:n])</span><br><span class="line">    <span class="keyword">if</span> s != <span class="string">&quot;OK&quot;</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Failed to change dir&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pwdRequest</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(PWD))</span><br><span class="line">    <span class="keyword">var</span> response [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    n, _ := conn.Read(response[<span class="number">0</span>:])</span><br><span class="line">    s := <span class="type">string</span>(response[<span class="number">0</span>:n])</span><br><span class="line">    fmt.Println(<span class="string">&quot;Current dir \&quot;&quot;</span> + s + <span class="string">&quot;\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Fatal error &quot;</span>, err.Error())</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="client-go"><a href="#client-go" class="headerlink" title="client.go"></a><strong><code>client.go</code></strong></h5><p>Then is server side code: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    DIR = <span class="string">&quot;DIR&quot;</span></span><br><span class="line">    CD  = <span class="string">&quot;CD&quot;</span></span><br><span class="line">    PWD = <span class="string">&quot;PWD&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    service := <span class="string">&quot;0.0.0.0:1202&quot;</span></span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(<span class="string">&quot;tcp&quot;</span>, service)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    listener, err := net.ListenTCP(<span class="string">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleClient(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := conn.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            conn.Close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s := <span class="type">string</span>(buf[<span class="number">0</span>:n])</span><br><span class="line">        <span class="comment">// decode request</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>:<span class="number">2</span>] == CD &#123;</span><br><span class="line">            chdir(conn, s[<span class="number">3</span>:])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[<span class="number">0</span>:<span class="number">3</span>] == DIR &#123;</span><br><span class="line">            dirList(conn)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[<span class="number">0</span>:<span class="number">3</span>] == PWD &#123;</span><br><span class="line">            pwd(conn)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chdir</span><span class="params">(conn net.Conn, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> os.Chdir(s) == <span class="literal">nil</span> &#123;</span><br><span class="line">        conn.Write([]<span class="type">byte</span>(<span class="string">&quot;OK&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        conn.Write([]<span class="type">byte</span>(<span class="string">&quot;ERROR&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pwd</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    s, err := os.Getwd()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        conn.Write([]<span class="type">byte</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirList</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Write([]<span class="type">byte</span>(<span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">    dir, err := os.Open(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    names, err := dir.Readdirnames(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, nm := <span class="keyword">range</span> names &#123;</span><br><span class="line">        conn.Write([]<span class="type">byte</span>(nm + <span class="string">&quot;\r\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Fatal error &quot;</span>, err.Error())</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="server-go"><a href="#server-go" class="headerlink" title="server.go"></a><strong><code>server.go</code></strong></h5><h3 id="Bytes-Buffer"><a href="#Bytes-Buffer" class="headerlink" title="Bytes.Buffer"></a>Bytes.Buffer</h3><p>Based on the above demo, letâ€™s review how <code>Bytes.Buffer</code> is used. </p>
<p>According to Go official document:  </p>
<blockquote>
<p>Package bytes implements functions for the manipulation of byte slices.<br>A Buffer is a variable-sized buffer of bytes with Read and Write methods.</p>
</blockquote>
<p>The <code>bytes</code> package itself is easy to understand, which provides functionalities to manipulate byte slice. The concern is <code>bytes.Buffer</code>, what benefits can we get by using it? Letâ€™s review the demo code where it is used.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dirRequest</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    conn.Write([]<span class="type">byte</span>(DIR + <span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">512</span>]<span class="type">byte</span></span><br><span class="line">    result := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// read till we hit a blank line</span></span><br><span class="line">        n, _ := conn.Read(buf[<span class="number">0</span>:])</span><br><span class="line">        result.Write(buf[<span class="number">0</span>:n])</span><br><span class="line">        length := result.Len()</span><br><span class="line">        contents := result.Bytes()</span><br><span class="line">        <span class="keyword">if</span> <span class="type">string</span>(contents[length<span class="number">-4</span>:]) == <span class="string">&quot;\r\n\r\n&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="type">string</span>(contents[<span class="number">0</span> : length<span class="number">-4</span>]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code block is from <code>client.go</code> part. And the scenario is: the client send <code>DIR</code> command to server side, server run this <code>DIR</code> command which will return contents of current directory. Client and server use <code>conn.Read</code> and <code>conn.Write</code> to communicate with each other. The client keeps reading data in a <code>for</code> loop until all the data is consumed which is marked by two continuous <code>\r\n</code> strings. </p>
<p>In this case, a new <code>bytes.Buffer</code> object is created by calling <code>NewBuffer</code> method and three other member methods are called: <code>Write</code>, <code>Len</code> and <code>Bytes</code>. Letâ€™s review their source code: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf      []<span class="type">byte</span> </span><br><span class="line">	off      <span class="type">int</span>    </span><br><span class="line">	lastRead readOp </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	b.lastRead = opInvalid</span><br><span class="line">	m, ok := b.tryGrowByReslice(<span class="built_in">len</span>(p))</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		m = b.grow(<span class="built_in">len</span>(p))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(b.buf[m:], p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> Len() <span class="type">int</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(b.buf) - b.off </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> Bytes() []<span class="type">byte</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> b.buf[b.off:] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The implementation is easy to understand and no need to add more explanation. One interesting point is inside the <code>Write</code> function. It will first check whether the buffer has enough room for new bytes, if no then it will call   internal <code>grow</code> method to add more space. </p>
<p>In fact, this is the biggest benefit you can get from <code>Buffer</code>. You donâ€™t need to manage the dynamic change of buffer length manually, <code>bytes.Buffer</code> will help you to do that. In this way you wonâ€™t waste memory by setting the possible maximum length just for providing enough space. To some extend, it is similar to the <strong>vector</strong> in C++ language.   </p>
<h3 id="Bufio"><a href="#Bufio" class="headerlink" title="Bufio"></a>Bufio</h3><p>Next, letâ€™s review how <code>Bufio</code> pacakge works. In our demo, it is used as following: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">// hide other code below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Before we dive into the details about the demo code, letâ€™s first understand what is the purpose of <code>bufio</code> package. </p>
<p>First we need to understand that when applications run IO operations like read or write data from or to files, network and database. It will trigger <code>system call</code> in the bottom level, which is heavy in the performance point of view.  </p>
<p>Buffer IO is a technique used to temporarily accumulate the results for an IO operation before transmitting it forward. This technique can increase the speed of a program by reducing the number of system calls. For example, in case you want to read data from disk byte by byte. Instead of directly reading each byte from the disk every time, with buffer IO technique, we can read a block of data into buffer once, then consumers can read data from the buffer in whatever way you want. Performance will be improved by reducing heavy system calls.</p>
<p>Concretely, letâ€™s review how <code>bufio</code> package do this. The Go official document goes like this:</p>
<blockquote>
<p>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.</p>
</blockquote>
<p>Letâ€™s understand the definition by reading the source code: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReader and NewReaderSize in bufio.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader &#123;</span><br><span class="line">	<span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader &#123;</span><br><span class="line">	b, ok := rd.(*Reader)</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">		size = minReadBufferSize</span><br><span class="line">	&#125;</span><br><span class="line">	r := <span class="built_in">new</span>(Reader)</span><br><span class="line">	r.reset(<span class="built_in">make</span>([]<span class="type">byte</span>, size), rd)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In our demo, we use <code>NewReader</code> which then calls <code>NewReaderSize</code> to create a new <code>Reader</code> instance. One thing need to notice is that the parameter is <code>io.Reader</code> type, which is an important interface implements only one method <code>Read</code>.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the Reader interface in io.go file</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In our case, we use <code>os.Stdin</code> as the function argument, which will read data from standard input. </p>
<p>Then letâ€™s reivew declaration of <code>bufio.Reader</code>  which wraps <code>io.Reader</code>:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf          []<span class="type">byte</span></span><br><span class="line">	rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">	r, w         <span class="type">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">	err          <span class="type">error</span></span><br><span class="line">	lastByte     <span class="type">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">	lastRuneSize <span class="type">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bufio.Reader</code> has many methods defined, in our case we use <code>ReadString</code>, which will call another low-level method <code>ReadSlice</code>. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadSlice(delim <span class="type">byte</span>) (line []<span class="type">byte</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	s := <span class="number">0</span> </span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Search buffer.</span></span><br><span class="line">		<span class="keyword">if</span> i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			i += s</span><br><span class="line">			line = b.buf[b.r : b.r+i+<span class="number">1</span>]</span><br><span class="line">			b.r += i + <span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			line = b.buf[b.r:b.w]</span><br><span class="line">			b.r = b.w</span><br><span class="line">			err = b.readErr()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> b.Buffered() &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">			b.r = b.w</span><br><span class="line">			line = b.buf</span><br><span class="line">			err = ErrBufferFull</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s = b.w - b.r </span><br><span class="line"></span><br><span class="line">		b.fill() <span class="comment">// buffer is not full</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i := <span class="built_in">len</span>(line) - <span class="number">1</span>; i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		b.lastByte = <span class="type">int</span>(line[i])</span><br><span class="line">		b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When <code>buf</code> byte slice contains data, it will search the target value inside it. But initially <code>buf</code> is empty, it need firstly load some data, right? That is the most interesting part. The <code>b.fill()</code> is just for that. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> fill() &#123;</span><br><span class="line">	<span class="keyword">if</span> b.r &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">copy</span>(b.buf, b.buf[b.r:b.w])</span><br><span class="line">		b.w -= b.r</span><br><span class="line">		b.r = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> b.w &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;bufio: tried to fill full buffer&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read new data: try a limited number of times.</span></span><br><span class="line">	<span class="keyword">for</span> i := maxConsecutiveEmptyReads; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		n, err := b.rd.Read(b.buf[b.w:]) <span class="comment">// call the underlying Reader</span></span><br><span class="line">		<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">		&#125;</span><br><span class="line">		b.w += n</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			b.err = err</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.err = io.ErrNoProgress</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The data is loaded into <code>buf</code> by calling the underlying Reader,</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, err := b.rd.Read(b.buf[b.w:])</span><br></pre></td></tr></table></figure>
<p>in our case is <code>os.Stdin</code>.</p>
<h3 id="Customized-Reader"><a href="#Customized-Reader" class="headerlink" title="Customized Reader"></a>Customized Reader</h3><p>To have a better understand about the buffering IO technique, we can define our own customized <code>Reader</code> and pass it <code>bufio.NewReader</code> as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// customized Reader struct</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	counter <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Read&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> r.counter &gt;= <span class="number">3</span> &#123; <span class="comment">// simulate EOF</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line">	s := <span class="string">&quot;a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p&quot;</span></span><br><span class="line">	<span class="built_in">copy</span>(p, s)</span><br><span class="line">	r.counter += <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := <span class="built_in">new</span>(Reader)</span><br><span class="line">	br := bufio.NewReader(r)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		token, err := br.ReadSlice(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Token: %q\n&quot;</span>, token)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Read done&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please run the demo code above, observe the output and think about why it generates such result. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this post, I only talked about <code>Reader</code> part of bufio, if you understand the behavior explained above clearly, itâ€™s easy to understand <code>Writer</code> quickly as well. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/04/04/golang-bytes-buffer/" data-id="clghbduin000nn4mm4arc9o32" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-go-module" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/31/go-module/" class="article-date">
  <time datetime="2021-03-31T06:42:49.000Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/31/go-module/">go-module</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/03/31/go-module/" data-id="clghbduim000jn4mm4mffau43" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/13/note-on-red-black-tree/">Note on Red Black Tree: part one</a>
          </li>
        
          <li>
            <a href="/2022/12/06/external-sorting-two/">External Mergesort: part two</a>
          </li>
        
          <li>
            <a href="/2022/11/02/external-sorting-one/">External Mergesort: part one</a>
          </li>
        
          <li>
            <a href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
          </li>
        
          <li>
            <a href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>