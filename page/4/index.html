<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Chris Bao&#39;s Blog">
<meta property="og:url" content="https://baoqger.github.io/page/4/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
          <a class="main-nav-link" href="/book-reviews">Book Review</a>
        
          <a class="main-nav-link" href="/solopreneur">Solopreneur</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-win-wsl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/06/win-wsl/" class="article-date">
  <time datetime="2021-08-06T01:19:41.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/06/win-wsl/">New way to set up Linux development environment in Windows with WSL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>I like system programming which can allow you to touch more software development skills in the bottom level.  </p>
<p>Linux is the perfect platform when you want to do system programming. But if you’re using a computer running Windows on it, then you have to spend some time to set up the Linux development environment. Generally speaking there are two traditional ways to do that: <code>virtual machine</code> and <code>dualboot</code>, both need some effort. Or you can try to do that with <code>container</code> technology, for example, I once shared one <a href="https://baoqger.github.io/2020/07/28/linux-cpp-docker/">article</a> about how to do it with <code>Docker</code>. </p>
<p>In this article, I will introduce a new and easier way to do this without too much overhead. </p>
<h3 id="Windows-Subsystem-for-Linux"><a href="#Windows-Subsystem-for-Linux" class="headerlink" title="Windows Subsystem for Linux"></a>Windows Subsystem for Linux</h3><p>The new way is <code>Windows Subsystem for Linux (WSL)</code>. I have to admit that the operating system is complex and difficult so for now I don’t know how Microsoft make <code>WSL</code> works. In details, you can refer to this <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/commandline/a-deep-dive-into-how-wsl-allows-windows-to-access-linux-files/">article</a> to learn how <code>WSL</code> allows Windows to access Linux files. In this article let’s focus on how to set it up and what kind of benefits it can provide to developers.</p>
<p>Based on the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/about">official document</a>, with <code>WSL</code> you can</p>
<ul>
<li>Run common command-line tools such as <code>grep</code>, <code>sed</code>, <code>awk</code>.</li>
<li>Run Bash shell scripts and GNU/Linux command-line applications including:<ul>
<li>Tools: vim, emacs, tmux.</li>
<li>Languages: NodeJS, Javascript, Python, Ruby, C/C++, C# &amp; F#, Rust, Go, etc.</li>
<li>Services: SSHD, MySQL, Apache, lighttpd, MongoDB, PostgreSQL.</li>
</ul>
</li>
<li>Install additional software using your own GNU/Linux distribution package manager.</li>
</ul>
<p>With these conditions, you can set up a completed Linux development environment. </p>
<h3 id="Install-WSL"><a href="#Install-WSL" class="headerlink" title="Install WSL"></a>Install WSL</h3><p>For detail steps to install <code>WSL</code>, you can find it on the official document. Based on my experience, I follow the document to download and install Linux Ubuntu distribution smoothly, which is much easier than settig the virtual machine.</p>
<h3 id="File-mount"><a href="#File-mount" class="headerlink" title="File mount"></a>File mount</h3><p>By default, you can also access your local machine’s file system from within the Linux Bash shell. Since your local drives are mounted under the <strong>/mnt</strong> folder of the subsystem. </p>
<p>In this way, you can develop the code with the productivity tools in Windows and build it in Linux environment.</p>
<h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>This is another convenient point. <code>WSL</code> shares the IP address of Windows, as it is running on Windows.<br>As such you can access any ports on localhost e.g. if you had a web server running on port 8080, you could access it just by visiting <strong><a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a></strong> into your Windows browser.</p>
<h3 id="Set-up-the-development-environment"><a href="#Set-up-the-development-environment" class="headerlink" title="Set up the development environment"></a>Set up the development environment</h3><p>After install the Ubuntu system, I also install tools to prepare the development environment. For example, <code>GCC</code> to develop C language program as below. </p>
<img src="/images/linux-gcc.png" title="gcc in Linux" width="800px" height="600px">

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Based on my testing and experience, <code>WSL</code> can save developers’ time to set up Linux environment.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/08/06/win-wsl/" data-id="clvv1t4j5003rc8mmf88gggei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-simple-http-server-golang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/31/how-to-implement-simple-http-server-golang/" class="article-date">
  <time datetime="2021-07-31T02:15:25.000Z" itemprop="datePublished">2021-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/31/how-to-implement-simple-http-server-golang/">How to write a Golang HTTP server with Linux system calls</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><code>HTTP</code> is everywhere. As a software engineer, you’re using the <code>HTTP</code> protocol every day. Starting an <code>HTTP</code> server will be an easy task if you’re using any modern language or framework. For example, in Golang you can do that with the following lines of code:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hi&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;Hi&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can finish the job easily because <code>net/http</code> package implements the <code>HTTP</code> protocol completely. How can you do that without <code>net/http</code> package ? That’s the target of this article. </p>
<p><strong>Note</strong>: This article is inspired by <a target="_blank" rel="noopener" href="https://joe.schafer.dev/go-server-with-syscalls/">Joe Schafer’s post</a> a lot. My implementation has something different which totally removes dependency on Golang’s <code>net</code> package, but the idea of using <code>system call</code> in Golang to setup the TCP/IP connetion is the same. Thanks very much for Joe Schafer’s interesting post.</p>
<p>Another thing I need to mention is this article will cover many concepts, but it’s very difficult to discuss all of them in detail. To understand this article smoothly, you need some prerequisite knowledge such as <code>OSI model</code>, <code>TCP/IP stack</code>, <code>socket programming</code>, <code>HTTP protocol</code> and <code>system call</code>. I will add some explanations on these topics to help you understand this article and give some references and links to let you continue exploring more in advanced level. </p>
<h3 id="OSI-network-model"><a href="#OSI-network-model" class="headerlink" title="OSI network model"></a>OSI network model</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OSI_model"><code>OSI model</code></a> partitions the data flow in a communication system into <strong>seven abstraction layers</strong>. These layers form a protocol stack, with each layer communicating with the layer above and the layer below as follows: </p>
<img src="/images/osi_model.png" title="network" width="400px" height="300px">

<p>For example, <code>HTTP</code> is in <strong>layer 7</strong>, <code>TCP</code> is in <strong>layer 4</strong> and <code>IP</code> is in <strong>layer 3</strong>. </p>
<p>OSI is a general model, which was first specified in the early 1980s. <strong>But neither traditional nor modern networking protocols fit into this model neatly</strong>. For example, <code>TCP/IP</code> stack does not define the three upper layers: session, presentation, and application. In fact, it does not define anything above the transport layer. From the viewpoint of <code>TCP/IP</code>, everything above the transport layer is part of<br>the application. So the layered network model more  consistent with Linux (TCP/IP stack is implemented in Linux kernel) is as follows: </p>
<ul>
<li>Application Layer (telnet, ftp, http)</li>
<li>Host-to-Host Transport Layer (TCP, UDP)</li>
<li>Internet Layer (IP and routing)</li>
<li>Network Access Layer (Ethernet, wi-fi)</li>
</ul>
<p>Once again, <strong>it is important to point out that the upper layers—Layers 5, 6, and 7—are not part of the TCP/IP stack</strong>. </p>
<p>Another critical point to understand is <code>data encapsulation</code>.  The data flow goes from the bottom physical level to the highest-level representation of data in an application.</p>
<p>Each layer has administrative information that it has to keep about its own layer. It does this by adding header information to the packet it receives from the layer above, as the packet passes down. Each header contains information regarding the message contents. For example, one <code>HTTP</code> server sends data from one host to another. It uses the <code>TCP</code> protocol on top of the <code>IP</code> protocol, which may be sent over <code>Ethernet</code>. This looks like: </p>
<img src="/images/data_encapsulation.png" title="network" width="400px" height="300px">



<p>The packet transmitted over ethernet, is the bottom one. On the receiving side, these headers are removed as the packet moves up.</p>
<p>Next let’s see how <code>TCP/IP</code> stack encapsulates <code>HTTP</code> message and send it over the network through <code>socket</code>. The idea can be illustrated with the following image: </p>
<img src="/images/socket_network.png" title="network" width="600px" height="400px">

<p>I will explain how it works by writing a HTTP server from scratch, you can refer to this <a target="_blank" rel="noopener" href="https://github.com/baoqger/http-server-scratch">Github repo</a> to get all the code. </p>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p><code>TCP/IP</code> stack is originated from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ARPANET"><code>ARPANET</code></a> project, which is integrated into Unix BSD OS as the first implementation of <code>TCP/IP</code> protocols.</p>
<p>Nowadays, <code>TCP/IP</code> is still implemented in the operating system level. For Linux system, you can find the source code inside the kernel. The detailed implementation is outside the scope of this article. You can study it in this Github <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/tree/master/net/ipv4">link</a>. </p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>As I mentioned in the above sections, HTTP server is running in the application level. How it can work with <code>TCP/IP</code> stack which lives in the kernel? The answer is <code>socket</code>. </p>
<p>The <code>socket</code> interface was originally developed as part of the BSD operating system. Sockets provide an interface between the application level programs and the TCP/IP stack. Linux (or other OS) provides an API and sockets, and applications use this API to access the networking facilities in the kernel. </p>
<p>The socket interface is really TCP/IP’s window on the world. In most modern systems incorporating TCP/IP, the socket interface is the only way that applications make use of the TCP/IP suite of protocols. </p>
<p>One main advantage of sockets in Unix or Linux system is that the socket is treated as a <code>file descriptor</code>, and all the standard I/O functions work on sockets in the same way they work on a local file. File descriptor is simply an integer associated with an open file. </p>
<p>You may heard <strong>everything in Unix is a file</strong>. The file can be a network connection, a pipe, a real file in the disk, a device or anything else. So when you want to send data to another program over the Interent you will do it through a file descriptor.   </p>
<p>In our HTTP server case, <strong>it will get the request by reading data from the socket and send the response by writing data to the socket</strong>.  </p>
<p>Next, let’s review the source code to see how the HTTP server is implemented.</p>
<p>First, we need setup the TCP connection through socket, the process can be described in the following image: </p>
<img src="/images/socket_tcp.png" title="network" width="600px" height="400px">

<p>In Golang, <code>net</code> package provides all the socket related functionalities. Since this article’s purpose is writing a HTTP server from scratch, so I create a package named <strong>simplenet</strong> to provide the very basic implementation. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplenet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> netSocket <span class="keyword">struct</span> &#123;</span><br><span class="line">	fd <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNetSocket</span><span class="params">(ip IP, port <span class="type">int</span>)</span></span> (*netSocket, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// ForkLock docs state that socket syscall requires the lock.</span></span><br><span class="line">	syscall.ForkLock.Lock()</span><br><span class="line">	<span class="comment">// AF_INET = Address Family for IPv4</span></span><br><span class="line">	<span class="comment">// SOCK_STREAM = virtual circuit service</span></span><br><span class="line">	<span class="comment">// 0: the protocol for SOCK_STREAM, there&#x27;s only 1.</span></span><br><span class="line">	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">&quot;socket&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	syscall.ForkLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow reuse of recently-used addresses.</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, <span class="number">1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		syscall.Close(fd)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">&quot;setsockopt&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bind the socket to a port</span></span><br><span class="line">	sa := &amp;syscall.SockaddrInet4&#123;Port: port&#125;</span><br><span class="line">	<span class="built_in">copy</span>(sa.Addr[:], ip)</span><br><span class="line">	<span class="keyword">if</span> err = syscall.Bind(fd, sa); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">&quot;bind&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Listen for incoming connections.</span></span><br><span class="line">	<span class="keyword">if</span> err = syscall.Listen(fd, syscall.SOMAXCONN); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, os.NewSyscallError(<span class="string">&quot;listen&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;netSocket&#123;fd: fd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns netSocket)</span></span> Read(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n, err := syscall.Read(ns.fd, p) <span class="comment">// read from socket file descriptor</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns netSocket)</span></span> Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	n, err := syscall.Write(ns.fd, p) <span class="comment">// write to socket file descriptor</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a new netSocket for the next pending connection request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns *netSocket)</span></span> Accept() (*netSocket, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// syscall.ForkLock doc states lock not needed for blocking accept.</span></span><br><span class="line">	nfd, _, err := syscall.Accept(ns.fd)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		syscall.CloseOnExec(nfd)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;netSocket&#123;nfd&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ns *netSocket)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> syscall.Close(ns.fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>netSocket</strong> data model is created to represent the socket, which contains only one field <strong>fd</strong> means file descriptor. And all the socket related APIs: <strong>Read</strong>, <strong>Write</strong>,  <strong>Accept</strong> and <strong>Close</strong>, are defined. The usage of socket API is not in this article’s scope, you can easily find a lot of great documents about it online. </p>
<p>The logic of <strong>netSocket</strong> is not complicated, because it delegates the job to the kernel by <code>system call</code>. A system call is a programmatic way a program requests a service from the kernel, in detail you can refer to this <a target="_blank" rel="noopener" href="https://opensource.com/article/19/10/strace">article</a>. In Golang, all the system calls are wrapped inside the <code>syscall</code> standard package.  </p>
<p>One thing need to mention is different platform have different <code>syscall</code> usages, so the demo code shown in this article can only be compiled and build on Linux system. </p>
<p>Now we setup the TCP server and wait for connection request from client side. Next, let’s see how to read or write HTTP request and response through socket. </p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>The main workflow is as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;http-server-scratch/simplenet&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ipFlag := flag.String(<span class="string">&quot;ip_addr&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;The IP address to use&quot;</span>)</span><br><span class="line">	portFlag := flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;The port to use.&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	ip := simplenet.ParseIP(*ipFlag)</span><br><span class="line">	port := *portFlag</span><br><span class="line">	socket, err := simplenet.NewNetSocket(ip, port)</span><br><span class="line">	<span class="keyword">defer</span> socket.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Print(<span class="string">&quot;===============&quot;</span>)</span><br><span class="line">	log.Print(<span class="string">&quot;Server Started!&quot;</span>)</span><br><span class="line">	log.Print(<span class="string">&quot;===============&quot;</span>)</span><br><span class="line">	log.Print()</span><br><span class="line">	log.Printf(<span class="string">&quot;addr: http://%s:%d&quot;</span>, ip, port)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Block until incoming connection</span></span><br><span class="line">		rw, e := socket.Accept()</span><br><span class="line">		log.Print()</span><br><span class="line">		log.Print()</span><br><span class="line">		log.Printf(<span class="string">&quot;Incoming connection&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(e)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read request</span></span><br><span class="line">		log.Print(<span class="string">&quot;Reading request&quot;</span>)</span><br><span class="line">		req, err := simplenet.ParseRequest(rw)</span><br><span class="line">		log.Print(<span class="string">&quot;request: &quot;</span>, req)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Write response</span></span><br><span class="line">		log.Print(<span class="string">&quot;Writing response&quot;</span>)</span><br><span class="line">		simplenet.WriteString(rw, <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>+</span><br><span class="line">			<span class="string">&quot;Content-Type: text/html; charset=utf-8\r\n&quot;</span>+</span><br><span class="line">			<span class="string">&quot;Content-Length: 20\r\n&quot;</span>+</span><br><span class="line">			<span class="string">&quot;\r\n&quot;</span>+</span><br><span class="line">			<span class="string">&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Print(err.Error())</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, the HTTP request parsing logic is defined in the <strong>ParseRequest</strong> method in <strong>simplenet</strong> package. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> simplenet</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;http-server-scratch/simplenet/simpleTextProto&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">	method <span class="type">string</span> <span class="comment">// GET, POST, etc.</span></span><br><span class="line">	header simpleTextProto.MIMEHeader</span><br><span class="line">	body   []<span class="type">byte</span></span><br><span class="line">	uri    <span class="type">string</span> <span class="comment">// The raw URI from the request</span></span><br><span class="line">	proto  <span class="type">string</span> <span class="comment">// &quot;HTTP/1.1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseRequest</span><span class="params">(c *netSocket)</span></span> (*request, <span class="type">error</span>) &#123;</span><br><span class="line">	b := bufio.NewReader(*c)</span><br><span class="line">	tp := simpleTextProto.NewReader(b) <span class="comment">// need replace</span></span><br><span class="line">	req := <span class="built_in">new</span>(request)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request line: parse &quot;GET /index.html HTTP/1.0&quot;</span></span><br><span class="line">	<span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">	s, _ = tp.ReadLine() <span class="comment">// need replace</span></span><br><span class="line">	sp := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	req.method, req.uri, req.proto = sp[<span class="number">0</span>], sp[<span class="number">1</span>], sp[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request headers</span></span><br><span class="line">	mimeHeader, _ := tp.ReadMIMEHeader() <span class="comment">// need replace</span></span><br><span class="line">	req.header = mimeHeader</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse request body</span></span><br><span class="line">	<span class="keyword">if</span> req.method == <span class="string">&quot;GET&quot;</span> || req.method == <span class="string">&quot;HEAD&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(req.header[<span class="string">&quot;Content-Length&quot;</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;no content length&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	length, err := strconv.Atoi(req.header[<span class="string">&quot;Content-Length&quot;</span>][<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	body := <span class="built_in">make</span>([]<span class="type">byte</span>, length)</span><br><span class="line">	<span class="keyword">if</span> _, err = io.ReadFull(b, body); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req.body = body</span><br><span class="line">	<span class="keyword">return</span> req, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The HTTP request message can be divided into three parts <code>request line</code>, <code>request headers</code> and <code>request body</code> as follows: </p>
<img src="/images/http_message_format.png" title="network" width="600px" height="400px">


<p>The logic inside <strong>ParseRequest</strong> handles these 3 parts step by step. You can refer to the comments in the demo code. </p>
<p>One thing need to emphasis is that <strong>ParseRequest</strong> method doesn’t depends on <code>net</code> package. Because I want to show how HTTP server works in the bottom level, so I copy the request parsing logics from <code>net</code> package into my <code>simplenet</code> package. The parsing for request header part is kind of complex, but it doesn’t influence your understanding about the main concept of HTTP server. If you want to know the details, you can refer to the <code>simplenet/simpleTextProto</code> package. The important thing to understand is HTTP server reads the request message with <strong>Read</strong> method of <strong>netSocket</strong> . And the <strong>Read</strong> method makes socket read system call to get network data from TCP stack: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Read(ns.fd, p)</span><br></pre></td></tr></table></figure>

<p>On the other side,  HTTP response is sent back by calling <code>WriteString</code> method of <code>simplenet</code> package</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(c *netSocket, s <span class="type">string</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> c.Write([]<span class="type">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WriteString</code> simply calls <strong>Write</strong> method of <strong>netsocket</strong>, which makes socket write system call to send data over Interent with TCP stack:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Write(ns.fd, p)</span><br></pre></td></tr></table></figure>
<p>That’s all for the code part. Next let’s try to run this simple HTTP server we build from scratch.</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>Build (need Linux platform) and run this HTTP server with default options setting and send request to it with <code>curl</code>. The result goes as follows: </p>
<img src="/images/golang_http_server_demo.png" title="network" width="600px" height="400px">

<p>the server works as expected. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/31/how-to-implement-simple-http-server-golang/" data-id="clvv1t4ih001jc8mmc982b19e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-collect-metrics-k8s" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/14/how-to-collect-metrics-k8s/" class="article-date">
  <time datetime="2021-07-14T02:37:52.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/14/how-to-collect-metrics-k8s/">how-to-collect-metrics-k8s</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/14/how-to-collect-metrics-k8s/" data-id="clvv1t4ie0018c8mmbsxsaufn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-implement-graphql-spec" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/14/how-to-implement-graphql-spec/" class="article-date">
  <time datetime="2021-07-14T02:37:13.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/14/how-to-implement-graphql-spec/">how-to-implement-graphql-spec</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/14/how-to-implement-graphql-spec/" data-id="clvv1t4ig001gc8mm5wez4qbi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-deisgn-a-load-test-tool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/04/how-to-deisgn-a-load-test-tool/" class="article-date">
  <time datetime="2021-07-04T02:18:43.000Z" itemprop="datePublished">2021-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/04/how-to-deisgn-a-load-test-tool/">How to write a load performance test CLI tool</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>When you want to do the load performance test to your HTTP backend service, a handy and powerful tool can make your job much easier. For example, <code>ApacheBench</code> (short for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ApacheBench">ab</a>) is widely used in this field. But it is not today’s topic. Instead, I want to introduce <a target="_blank" rel="noopener" href="https://github.com/rakyll/hey">Hey</a> written in <code>Golang</code> and supports the same functionality as <code>ab</code>.  </p>
<p><code>Hey</code> usage goes as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: hey [options...] &lt;url&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -n  Number of requests to run. Default is <span class="number">200.</span></span><br><span class="line">  -c  Number of workers to run concurrently. Total number of requests cannot</span><br><span class="line">      be smaller than the concurrency level. Default is <span class="number">50.</span></span><br><span class="line">  -q  Rate limit, in queries per second (QPS) per worker. Default is no rate limit.</span><br><span class="line">  -z  Duration of application to send requests. When duration is reached,</span><br><span class="line">      application stops and exits. If duration is specified, n is ignored.</span><br><span class="line">      Examples: -z <span class="number">10</span>s -z <span class="number">3</span>m.</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// other options are hidden</span></span><br></pre></td></tr></table></figure>

<p>I didn’t list all of the options but only show several related to this article’s content. As you can see in the above list, <code>Hey</code> can support different practical features, such as <strong>multiple workers</strong> to run in the <strong>concurrent</strong> style and <strong>rate limit</strong> by <strong>queries per second (QPS)</strong>. It can also support <strong>run by duration</strong> and <strong>run by request number</strong> two modes.</p>
<p>In this article, we can review the design and implementation of <code>Hey</code> to see how to make a load performance testing tool.</p>
<h3 id="Architecture-Design"><a href="#Architecture-Design" class="headerlink" title="Architecture Design"></a>Architecture Design</h3><p>The design of <code>Hey</code> is not complex, and the architecture can be divided into the following three parts:</p>
<ul>
<li>Control logic: the main workflow like how to set up multiple concurrent workers, how to control QPS rate limiter, and how to exit the process when duration is reached; </li>
<li>HTTP request configuration: the headers or parameters needed to send  request;   </li>
<li>Test report: print or save the result after the load testing finish. </li>
</ul>
<p>The architecture diagram goes as follows, after reading this article you’ll understand every element in this diagram: </p>
<img src="/images/hey.png" title="hey architecture" width="800px" height="400px">

<p>This article will focus on the first item (since it is the real interesting part) to show how to use <code>Golang</code>‘s concurrent programming techniques to realize these features.</p>
<h3 id="Exit-the-process"><a href="#Exit-the-process" class="headerlink" title="Exit the process"></a>Exit the process</h3><p>In the <code>hey.go</code> file, you can find the entry point <strong>main</strong> function. Let’s hide the boilerplate code and review  the core logic in the <strong>main</strong> function as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   w := &amp;requester.Work&#123;</span><br><span class="line">	N:  num,  <span class="comment">// number of request</span></span><br><span class="line">	C:  conc, <span class="comment">// number of concurrent works</span></span><br><span class="line">	QPS: q,   <span class="comment">// QPS setting </span></span><br><span class="line">	results  <span class="keyword">chan</span> *result, <span class="comment">// channel for request response</span></span><br><span class="line">	stopCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="comment">// channle for stop the worker 		    </span></span><br><span class="line">       <span class="comment">//  hide the other fields</span></span><br><span class="line">   &#125;</span><br><span class="line">w.Init()</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-c</span><br><span class="line">	w.Stop()</span><br><span class="line">&#125;()</span><br><span class="line">   <span class="comment">// if the duration is set, then launch another goroutine</span></span><br><span class="line"><span class="keyword">if</span> dur &gt; <span class="number">0</span> &#123; </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(dur)</span><br><span class="line">		w.Stop()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line">w.Run()</span><br></pre></td></tr></table></figure>

<p><strong>requester.Work</strong> struct contains all the option settings, including request numbers, concurrent workers, and QPS (it also contains the test result report). </p>
<p>After creating an instance of <strong>requester.Work</strong>, then call the <strong>Init()</strong> method. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> Init() &#123;</span><br><span class="line">	b.initOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		b.results = <span class="built_in">make</span>(<span class="keyword">chan</span> *result, min(b.C*<span class="number">1000</span>, maxResult))</span><br><span class="line">		b.stopCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, b.C)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Init()</strong> method will initialize two <code>channel</code>: <strong>results</strong> and <strong>stopCh</strong>. <strong>results</strong> channel is used for request response communication. And <strong>stopCh</strong> channel is used for signal to stop the concurrent workers.</p>
<p>Note that there are two ways to exit from the program. The first one is the user manually stops the program, for example, by pressing <strong>ctrl + c</strong>. In this case, the <code>signal.Notify()</code> method from the std library can catch the signal to terminate the process. The second one is by the time <strong>duration</strong> option. Both of the process exiting logics are running in a <code>Goroutine</code>. </p>
<p>To stop the worker, <strong>Stop()</strong> method will be called:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> Stop() &#123;</span><br><span class="line">	<span class="comment">// Send stop signal so that workers can stop gracefully.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.C; i++ &#123;</span><br><span class="line">		b.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What it does is sending several values to the <strong>stopCh</strong> channel. Note that it sends <strong>b.C</strong> values to the channel, which is the same as the number of concurrent workers. </p>
<p>You can imagine that each worker should wait for the value from the <strong>stopCh</strong> channel. When the worker receives one value, it should stop sending requests. Right? Then in this way, I can stop all the concurrent workers.  Let’s check our guess in the following sections.</p>
<h3 id="Concurrent-Workers"><a href="#Concurrent-Workers" class="headerlink" title="Concurrent Workers"></a>Concurrent Workers</h3><p>In the above <strong>main</strong> function, you can see that <strong>Run()</strong> is called:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> Run() &#123;</span><br><span class="line">	b.Init()</span><br><span class="line">	b.start = now()</span><br><span class="line">	b.report = newReport(b.writer(), b.results, b.Output, b.N)</span><br><span class="line">	<span class="comment">// Run the reporter first, it polls the result channel until it is closed.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		runReporter(b.report)</span><br><span class="line">	&#125;()</span><br><span class="line">	b.runWorkers()</span><br><span class="line">	b.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are several points worthy of discussion. In this section, let’s review <strong>runWorkers()</strong>. And <strong>runReporter()</strong> and <strong>Finish()</strong> are related to test result reports, and we will revisit them later in this article. </p>
<p><strong>runWorkers()</strong> goes as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> runWorkers() &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(b.C)</span><br><span class="line"></span><br><span class="line">	client := &amp;http.Client&#123;</span><br><span class="line">		<span class="comment">// hide details</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.C; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			b.runWorker(client, b.N/b.C)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">// block here before all workers stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a very typical pattern to launch multiple <code>goroutine</code> via <code>sync.WaitGroup</code>. Each worker is created by calling <strong>b.runWorker</strong> in a goroutine. In this way, multiple concurrent workers can run together. </p>
<p>Note that before all workers finish their tasks, <strong>wg.Wait()</strong> will block <strong>Finish()</strong> to run, which is used to report test results. And we will talk about it in the following sections.</p>
<p>Next step, the logic goes into <strong>runWorker</strong> method, and let’s review how <strong>QPS</strong> rate limit works? </p>
<h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>The core code of <strong>runWorker</strong> goes as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> runWorker(client *http.Client, n <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> throttle &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	<span class="keyword">if</span> b.QPS &gt; <span class="number">0</span> &#123;</span><br><span class="line">		throttle = time.Tick(time.Duration(<span class="number">1e6</span>/(b.QPS)) * time.Microsecond)</span><br><span class="line">	&#125;</span><br><span class="line">	... <span class="comment">// hide some detail codes</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-b.stopCh: <span class="comment">// receive worker stop signal from stopCh channel</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">if</span> b.QPS &gt; <span class="number">0</span> &#123;</span><br><span class="line">				&lt;-throttle <span class="comment">// receive timer signal from QPS rate limite channel</span></span><br><span class="line">			&#125;</span><br><span class="line">			b.makeRequest(client)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first parameter of method <strong>runWorker</strong> is <strong>client</strong> for sending requests. We need more analysis about the second parameter <strong>n</strong> denoting the number of requests this worker needs to send out. When <strong>runWorker</strong> is called, <strong>b.N/b.C</strong> is passed to it. <strong>b.N</strong> is the total number of request need to be sent out, and <strong>b.C</strong> is the number of concurrent workers. <strong>b.N</strong> divided by <strong>b.C</strong> is just the number of requests for each worker. Right? </p>
<p>But if the user sets the <strong>duration</strong> option, what is the number of requests? You can find the following logic in the <strong>main</strong> entry function:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dur &gt; <span class="number">0</span> &#123;</span><br><span class="line">	num = math.MaxInt32 <span class="comment">// use MaxInt32</span></span><br><span class="line">	<span class="keyword">if</span> conc &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		usageAndExit(<span class="string">&quot;-c cannot be smaller than 1.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When the user sets <strong>duration</strong> option, the request number will be <code>math.MaxInt32</code>. In this method, <strong>Hey</strong> can combine <strong>run by duration</strong> and <strong>run by request number</strong> two modes together. </p>
<p>As we mentioned in the introduction part, <code>Hey</code> can support <strong>QPS</strong> rate limit, and this strategy is written inside the <strong>runWorker</strong> method. Note that a <code>receive-only channel</code> <strong>throttle</strong> is created with <code>time.Tick</code>, which sends out a value in each time period. And the time period is defined by </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.Duration(<span class="number">1e6</span>/(b.QPS)) * time.Microsecond</span><br></pre></td></tr></table></figure>

<p>For example, <strong>QPS = 1000</strong>, then the time period is 100ms, every 100ms <strong>throttle</strong> channel will receive a value.  </p>
<p><strong>throttle</strong> is placed before <strong>makeRequest()</strong> call, and in this way, we can realize the rate limit effect. </p>
<h3 id="Stop-Worker"><a href="#Stop-Worker" class="headerlink" title="Stop Worker"></a>Stop Worker</h3><p>In the <strong>runWorker</strong> method, you can also see the <code>select and case</code> usage. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-b.stopCh: <span class="comment">// receive worker stop signal from stopCh channel</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"><span class="comment">// hide other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As we mentioned in the above section, <strong>stopCh</strong> channel is used to stop the worker. Right? Now you can see how it is implemented. It maps to the <strong>Stop</strong> method we reviewed above as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send stop signal so that workers can stop gracefully.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.C; i++ &#123;</span><br><span class="line">	b.stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>b.C</code> numbers of value are sent to <strong>stopCh</strong> channel, and there are <code>b.C</code> numbers of concurrent workers as well. Each worker can receive one value from the channel and stop running. </p>
<h3 id="Result-Report"><a href="#Result-Report" class="headerlink" title="Result Report"></a>Result Report</h3><p>Let’s also have a quick review of how the result report work. Firstly in the <strong>makeRequest</strong> method, each request’s result is sent to the <strong>results</strong> channel as follows: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> makeRequest(c *http.Client) &#123;</span><br><span class="line">	<span class="comment">// hide details</span></span><br><span class="line">	b.results &lt;- &amp;result&#123;</span><br><span class="line">		<span class="comment">// hide details</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And in the <code>runReporter</code> method, you can see the logic like this:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runReporter</span><span class="params">(r *report)</span></span> &#123;</span><br><span class="line">	<span class="comment">// b.results is assign to r.results in newReport() constructor</span></span><br><span class="line">	<span class="keyword">for</span> res := <span class="keyword">range</span> r.results &#123; <span class="comment">// receive result from results channel</span></span><br><span class="line">		<span class="comment">// append result to report struct</span></span><br><span class="line">		<span class="comment">// hide details</span></span><br><span class="line">  	&#125;</span><br><span class="line">  	r.done &lt;- <span class="literal">true</span> <span class="comment">// send value done channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, a <code>for</code> is used to receive all the values from the channel. Note that <strong>the loop will continue until the channel is closed</strong>. It is another very typical concurrent programming pattern in <code>Golang</code>. We can realize the same functionality by using <code>select case</code> pattern, as long as we can add one more channel to send the exit signal. But on the syntax level, <code>for</code> loop pattern is much more cleaner.  </p>
<p>So there must be one place where the channel is closed, or else the <code>deadlock</code> issue will occur. In detail, you can refer to my previous <a href="https://baoqger.github.io/2020/10/26/golang-concurrent-twoways/">article</a> for more advanced explanations.  </p>
<p>The channel is closed in the <strong>Finish</strong> method like this: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Work)</span></span> Finish() &#123;</span><br><span class="line">	<span class="built_in">close</span>(b.results)</span><br><span class="line">	total := now() - b.start</span><br><span class="line">	<span class="comment">// Wait until the reporter is done.</span></span><br><span class="line">	&lt;-b.report.done</span><br><span class="line">	b.report.finalize(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Please also note that how the <strong>done</strong> channel works. <strong>Finish</strong> method firstly <code>close</code> the <strong>results</strong> channel, then the <strong>for</strong> loop will break and <code>r.done &lt;- true</code> can have chance to run. Finally <strong>b.report.finalize()</strong> can print the result since <strong>&lt;-b.report.done</strong> is not blocked.  t</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, I show you how to write a load performance testing CLI tool by reviewing <strong>Hey</strong> as an example. In the code level we discussed several concurrent programming patterns provided by Golang. Concurrent(or parallel) programming is difficult, and Golang is build just for that. Keep practice. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/07/04/how-to-deisgn-a-load-test-tool/" data-id="clvv1t4if001cc8mma4nucrqg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix-circuit-breaker-part4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/29/hystrix-circuit-breaker-part4/" class="article-date">
  <time datetime="2021-06-29T09:19:53.000Z" itemprop="datePublished">2021-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/29/hystrix-circuit-breaker-part4/">Circuit breaker and Hystrix: part four - error rate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/06/29/hystrix-circuit-breaker-part4/" data-id="clvv1t4io0026c8mmc2cvcm47" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix-circuit-breaker-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/18/hystrix-circuit-breaker-part3/" class="article-date">
  <time datetime="2021-06-18T07:54:02.000Z" itemprop="datePublished">2021-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/18/hystrix-circuit-breaker-part3/">Circuit breaker and Hystrix: part three - timeout</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In the <a href="https://baoqger.github.io/2021/05/30/hystrix-circuit-breaker-part2/">previous article</a>, we reviewed the <code>max concurrent request number</code> service degradation strategy. But some detailed techniques are not explained very clearly, which will be talked about in this article. And we will analyze <code>timeout</code> strategy as well.</p>
<h3 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h3><p>Compared with <code>max concurrent request number</code> strategy, <code>timeout</code> is very straightforward to understand. </p>
<p>As we mentioned in the previous article, the core logic of <code>hystrix</code> is inside the <code>GoC</code> function. <code>GoC</code> function internally runs two goroutines. You already see that the first goroutine contains the logic to send request to the target service and the strategy of <code>max concurrent request number</code>. How about the second goroutine? Let’s review it as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(getSettings(name).Timeout)</span><br><span class="line">	<span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-cmd.finished:</span><br><span class="line">		<span class="comment">// returnOnce has been executed in another goroutine</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ctx.Err())</span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ErrTimeout)</span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>Note that A <strong>Timer</strong> is created with the timeout duration value from the settings. And a <code>select</code> statement lets this goroutine wait until one <code>case</code> condition receives value from the channel. The <strong>timeout</strong> case is just the 3nd one (when the first two cases are not triggered), which will run fallback logic with <strong>ErrTimeout</strong> error message. </p>
<p>So far you should be clear about the main structure and functionalities of these two goroutines. But in detail, there are two Golang techniques need your attention: <code>sync.Once</code> and <code>sync.Cond</code>.  </p>
<h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>You may already notice the following code block, which is repeated several times inside <code>GoC</code> function. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	returnTicket()</span><br><span class="line">	cmd.errorWithFallback(ctx, ErrTimeout) <span class="comment">// with various error types </span></span><br><span class="line">	reportAllEvent()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>returnOnce</strong> is type of <code>sync.Once</code>, which makes sure that the callback function of <code>Do</code> method only runs once among different goroutines. </p>
<p>In this specific case, it can guarantee that both <strong>returnTicket()</strong> and <strong>reportAllEvent()</strong> execute only once. This really makes sense, because if <strong>returnTicket()</strong> runs multiple times for one <code>GoC</code> call, then the current concurrent request number will not be correct, right? </p>
<p>I wrote another article about <code>sync.Once</code> in detail, you can refer to <a href="https://baoqger.github.io/2021/05/11/golang-sync-once/">that article</a> for more in-depth explanation. </p>
<h3 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h3><p>The implementation of <strong>returnTicket</strong> function goes as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ticketCond := sync.NewCond(cmd)</span><br><span class="line">ticketChecked := <span class="literal">false</span></span><br><span class="line">returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Lock()</span><br><span class="line">	<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">		ticketCond.Wait() <span class="comment">// hang the current goroutine</span></span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit.executorPool.Return(cmd.ticket)</span><br><span class="line">	cmd.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ticketCond</strong> is a condition variable, and in Golang it is type of <code>sync.Cond</code>. </p>
<p>Condition variable is useful in communication between different goroutines. Concretely, <code>Wait</code> method of <code>sync.Cond</code>will hung the current goroutine, and <code>Signal</code> method will wake up the blocking goroutine to continue executing. </p>
<p>In <code>hystrix</code> case , when <strong>ticketChecked</strong> is <strong>false</strong>, which means the current <code>GoC</code> call is not finished and the <strong>ticket</strong> should not be returned yet. So <strong>ticketCond.Wait()</strong> is called to block this goroutine and wait until the <code>GoC</code> call is completed which is notified by <code>Signal</code> method. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ticketChecked = <span class="literal">true</span></span><br><span class="line">ticketCond.Signal()</span><br></pre></td></tr></table></figure>

<p>Note that the above two lines of code are always called together. <strong>ticketChecked</strong> is set to <strong>true</strong> means that the current <code>GoC</code> call is finished and the <strong>ticket</strong> is ready to return. Moreover, the <code>Wait</code> method to hang the goroutine is placed inside a <strong>for</strong> loop, which is also a best practise technique. </p>
<p>For more explanation about <code>sync.Cond</code>, please refer to my <a href="https://baoqger.github.io/2021/05/14/golang-sync-cond/">another article</a>.</p>
<h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>Finally, let’s see how <strong>fallback</strong> function is called when the target service is not responsive. </p>
<p>Let’s recall that each <code>GoC</code> call will create a new <strong>command</strong> instance. And <strong>fallback</strong> function will be assigned to the field with the same name, which will be used later. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd := &amp;command&#123;</span><br><span class="line">	run:      run,</span><br><span class="line">	fallback: fallback, <span class="comment">// fallback logic here</span></span><br><span class="line">	start:    time.Now(),</span><br><span class="line">	errChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">	finished: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As we see in above sections, <strong>errorWithFallback</strong> method is triggered when <code>timeout</code> or <code>max concurrent request number</code> threshold is met.   </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *command)</span></span> errorWithFallback(ctx context.Context, err <span class="type">error</span>) &#123;</span><br><span class="line">	eventType := <span class="string">&quot;failure&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err == ErrCircuitOpen &#123;</span><br><span class="line">		eventType = <span class="string">&quot;short-circuit&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == ErrMaxConcurrency &#123;</span><br><span class="line">		eventType = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == ErrTimeout &#123;</span><br><span class="line">		eventType = <span class="string">&quot;timeout&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == context.Canceled &#123;</span><br><span class="line">		eventType = <span class="string">&quot;context_canceled&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == context.DeadlineExceeded &#123;</span><br><span class="line">		eventType = <span class="string">&quot;context_deadline_exceeded&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reportEvent(eventType)</span><br><span class="line">	fallbackErr := c.tryFallback(ctx, err)</span><br><span class="line">	<span class="keyword">if</span> fallbackErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.errChan &lt;- fallbackErr</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>errorWithFallback</strong> method will run the fallback by calling <strong>tryFallback</strong> and report the metric events such as <strong>fallback-failure</strong> and <strong>fallback-success</strong>(will discuss metric collection in next article).</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *command)</span></span> tryFallback(ctx context.Context, err <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.fallback == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fallbackErr := c.fallback(ctx, err) <span class="comment">// execute the fallback logic here</span></span><br><span class="line">	<span class="keyword">if</span> fallbackErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.reportEvent(<span class="string">&quot;fallback-failure&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;fallback failed with &#x27;%v&#x27;. run error was &#x27;%v&#x27;&quot;</span>, fallbackErr, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.reportEvent(<span class="string">&quot;fallback-success&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we talked about the <code>timeout</code> strategy which is the simplest one among all the strategies provided by <code>hystrix</code>. Some detailed Golang techniques are reviewed as well to have a better understand the complex code logic. </p>
<p>In the next article let’s see how to collect metrics in <code>hystrix</code> to realize the <code>error rate</code> strategy. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/06/18/hystrix-circuit-breaker-part3/" data-id="clvv1t4io0028c8mmhrj4fhrq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystrix-circuit-breaker-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/30/hystrix-circuit-breaker-part2/" class="article-date">
  <time datetime="2021-05-30T08:41:20.000Z" itemprop="datePublished">2021-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/30/hystrix-circuit-breaker-part2/">Circuit breaker and Hystrix: part two - max concurrent requests</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the second article of this series, I will review the source code of <code>hystrix-go</code> project to understand how to design a <code>circuit breaker</code> and how to implement it with Golang. </p>
<p>If you’re not familiar with <code>circuit breaker</code> pattern or <code>hystrix-go</code> project, please check my previous <a href="https://baoqger.github.io/2021/05/21/hystric-circuit-breaker-part1/">article</a> about it.  </p>
<h3 id="Three-service-degradation-strategies"><a href="#Three-service-degradation-strategies" class="headerlink" title="Three service degradation strategies"></a>Three service degradation strategies</h3><p><code>Hystrix</code> provides three different service degradation strategies to avoid the <code>cascading failure</code> happening in the entire system: <code>timeout</code>, <code>maximum concurrent request numbers</code> and <code>request error rate</code>. </p>
<ul>
<li><strong>timeout</strong>: if the service call doesn’t return response successfully within a predefined time duration, then the fallback logic will run. This strategy is the simplest one. </li>
<li><strong>maximum concurrent request numbers</strong>: when the number of concurrent requests is beyond the threshold, then the fallback logic will handle the following request. </li>
<li><strong>request error rate</strong>: <code>hystrix</code> will record the response status of each service call, after the error rate reaches the threshold, the breaker will be open, and the fallback logic will execute before the breaker status changes back to closed. <code>error rate</code> strategy is the most complex one. </li>
</ul>
<p>This can be seen from the basic usage of <code>hystrix</code> as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/afex/hystrix-go/hystrix&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">hystrix.ConfigureCommand(<span class="string">&quot;my_command&quot;</span>, hystrix.CommandConfig&#123;</span><br><span class="line">	Timeout:               <span class="type">int</span>(<span class="number">10</span> * time.Second),</span><br><span class="line">	MaxConcurrentRequests: <span class="number">100</span>,</span><br><span class="line">	ErrorPercentThreshold: <span class="number">25</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">hystrix.Go(<span class="string">&quot;my_command&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// talk to dependency services</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// fallback logic when services are down</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>In the above usage case, you can see that <code>timeout</code> is set to 10 seconds, the maximum request number is 100, and the error rate threshold is 25 percentages.</p>
<p>In the consumer application level, that’s nearly all of the configuration you need to setup. <code>hystrix</code> will make the magin happen internally. </p>
<p>In this series of articles, I plan to show you the internals of <code>hystrix</code> by reviewing the source code. </p>
<p>Let’s start from the easy ones: <code>max concurrent requests</code> and <code>timeout</code>. Then move on to explore the complex strategy <code>request error rate</code>. </p>
<h3 id="GoC"><a href="#GoC" class="headerlink" title="GoC"></a>GoC</h3><p>Based on the above example, you can see <code>Go</code> function is the door to the source code of <code>hystrix</code>, so let’s start from it as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(name <span class="type">string</span>, run runFunc, fallback fallbackFunc)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	runC := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> run()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> fallbackC fallbackFuncC</span><br><span class="line">	<span class="keyword">if</span> fallback != <span class="literal">nil</span> &#123;</span><br><span class="line">		fallbackC = <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fallback(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> GoC(context.Background(), name, runC, fallbackC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Go</code> function accept three parameters: </p>
<ul>
<li><strong>name</strong>: the command name, which is bound to the <code>circuit</code> created inside hystrix. </li>
<li><strong>run</strong>: a function contains the normal logic which send request to the dependency service.</li>
<li><strong>fallback</strong>: a function contains the fallback logic.</li>
</ul>
<p><code>Go</code> function just wraps <code>run</code> and <code>fallback</code> with <code>Context</code>, which is used to control and cancel goroutine, if you’re not familiar with it then refer to my previous <a href="https://baoqger.github.io/2021/04/26/golang-context-source-code/">article</a>. Finally it will call <code>GoC</code> function.</p>
<p><code>GoC</code> function goes as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoC</span><span class="params">(ctx context.Context, name <span class="type">string</span>, run runFuncC, fallback fallbackFuncC)</span></span> <span class="keyword">chan</span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// construct a new command instance</span></span><br><span class="line">	cmd := &amp;command&#123;</span><br><span class="line">		run:      run,</span><br><span class="line">		fallback: fallback,</span><br><span class="line">		start:    time.Now(),</span><br><span class="line">		errChan:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">		finished: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// get circuit by command name</span></span><br><span class="line">	circuit, _, err := GetCircuit(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		cmd.errChan &lt;- err</span><br><span class="line">		<span class="keyword">return</span> cmd.errChan</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit = circuit</span><br><span class="line">	<span class="comment">//declare a condition variable sync.Cond: ticketCond, to synchronize among goroutines</span></span><br><span class="line">	<span class="comment">//declare a flag variable: ticketChecked, work together with ticketCond</span></span><br><span class="line">	ticketCond := sync.NewCond(cmd)</span><br><span class="line">	ticketChecked := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// declare a function: returnTicket, will execute when a concurrent request is done to return `ticket`</span></span><br><span class="line">	returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		cmd.Lock()</span><br><span class="line">		<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">			ticketCond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		cmd.circuit.executorPool.Return(cmd.ticket)</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// declare a sync.Once instance: returnOnce, make sure the returnTicket function execute only once</span></span><br><span class="line">	returnOnce := &amp;sync.Once&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// declare another function: reportAllEvent, used to collect the metrics</span></span><br><span class="line">	reportAllEvent := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := cmd.circuit.ReportEvent(cmd.events, cmd.start, cmd.runDuration)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// launch a goroutine which executes the `run` logic</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; cmd.finished &lt;- <span class="literal">true</span> &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !cmd.circuit.AllowRequest() &#123;</span><br><span class="line">			cmd.Lock()</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrCircuitOpen)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cmd.Lock()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> cmd.ticket = &lt;-circuit.executorPool.Tickets:</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ticketChecked = <span class="literal">true</span></span><br><span class="line">			ticketCond.Signal()</span><br><span class="line">			cmd.Unlock()</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrMaxConcurrency)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		runStart := time.Now()</span><br><span class="line">		runErr := run(ctx)</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> reportAllEvent()</span><br><span class="line">			cmd.runDuration = time.Since(runStart)</span><br><span class="line">			returnTicket()</span><br><span class="line">			<span class="keyword">if</span> runErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				cmd.errorWithFallback(ctx, runErr)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			cmd.reportEvent(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// launch the second goroutine for timeout strategy</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		timer := time.NewTimer(getSettings(name).Timeout)</span><br><span class="line">		<span class="keyword">defer</span> timer.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-cmd.finished:</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ctx.Err())</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">			returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				returnTicket()</span><br><span class="line">				cmd.errorWithFallback(ctx, ErrTimeout)</span><br><span class="line">				reportAllEvent()</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd.errChan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I admit it’s complex, but it’s also the core of the entire <code>hystrix</code> project. Be patient, let’s review it bit by bit carefully. </p>
<p>First of all, the code structure of <code>GoC</code> function is as follows:</p>
<p><img src="/images/GoC-hystrix.png" alt="GoC"></p>
<ol>
<li>Construct a new <code>Command</code> object, which contains all the information for each call to <code>GoC</code> function.</li>
<li>Get the <code>circuit breaker</code> by name (create it if it doesn’t exist) by calling <code>GetCircuit(name)</code> function.</li>
<li>Declare condition variable <strong>ticketCond</strong> and <strong>ticketChecked</strong> with <code>sync.Cond</code> which is used to communicate between goroutines. </li>
<li>Declare function <strong>returnTicket</strong>. What is a <strong>ticket</strong>? What does it mean by <strong>returnTicket</strong>? Let’s discuss it in detail later.</li>
<li>Declare another function <strong>reportAllEvent</strong>. This function is critical to <code>error rate</code> strategy, and we can leave it for detailed review in the following articles. </li>
<li>Declare an instance of <code>sync.Once</code>, which is another interesting <code>synchronization primitives</code> provided by golang.</li>
<li>Launch two goroutines, each of which contains many logics too. Simply speaking, the first one contains the logic of sending requests to the target service and the strategy of <code>max concurrent request number</code>, and the second one contains the <code>timeout</code> strategy. </li>
<li>Return a <code>channel</code> type value</li>
</ol>
<p>Let’s review each of them one by one. </p>
<h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p><code>command</code> struct goes as follows, which embeds <strong>sync.Mutex</strong> and defines several fields: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> command <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line"></span><br><span class="line">	ticket      *<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	start       time.Time</span><br><span class="line">	errChan     <span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line">	finished    <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">	circuit     *CircuitBreaker</span><br><span class="line">	run         runFuncC</span><br><span class="line">	fallback    fallbackFuncC</span><br><span class="line">	runDuration time.Duration</span><br><span class="line">	events      []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that <code>command</code> object iteself doesn’t contain command name information, and its lifecycle is just inside the scope of one <code>GoC</code> call. It means that the statistic metrics about the service request like <code>error rate</code> and <code>concurrent request number</code> are not stored inside command object. Instead, such metrics are stored inside <strong>circuit</strong> field which is <code>CircuitBreaker</code> type. </p>
<h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>As we mentioned in the workflow of <code>GoC</code> function, <code>GetCircuit(name)</code> is called to get or create the <code>circuit breaker</code>. It is implemented inside <code>circuit.go</code> file as follows:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	circuitBreakersMutex = &amp;sync.RWMutex&#123;&#125;</span><br><span class="line">	circuitBreakers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*CircuitBreaker)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCircuit</span><span class="params">(name <span class="type">string</span>)</span></span> (*CircuitBreaker, <span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	circuitBreakersMutex.RLock()</span><br><span class="line">	_, ok := circuitBreakers[name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		circuitBreakersMutex.RUnlock()</span><br><span class="line">		circuitBreakersMutex.Lock()</span><br><span class="line">		<span class="keyword">defer</span> circuitBreakersMutex.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> cb, ok := circuitBreakers[name]; ok &#123;</span><br><span class="line">			<span class="keyword">return</span> cb, <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		circuitBreakers[name] = newCircuitBreaker(name)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> circuitBreakersMutex.RUnlock()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> circuitBreakers[name], !ok, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic is very straightforward. All the circuit breakers are stored in a map object <strong>circuitBreakers</strong> with the <strong>command name</strong> as the key. </p>
<p>The <code>newCircuitBreaker</code> constructor function and <code>CircuitBreaker</code> struct are as follows: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreaker <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name                   <span class="type">string</span></span><br><span class="line">	open                   <span class="type">bool</span></span><br><span class="line">	forceOpen              <span class="type">bool</span></span><br><span class="line">	mutex                  *sync.RWMutex</span><br><span class="line">	openedOrLastTestedTime <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	executorPool *executorPool   <span class="comment">// used in the strategy of max concurrent request number </span></span><br><span class="line">	metrics      *metricExchange <span class="comment">// used in the strategy of request error rate</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCircuitBreaker</span><span class="params">(name <span class="type">string</span>)</span></span> *CircuitBreaker &#123;</span><br><span class="line">	c := &amp;CircuitBreaker&#123;&#125;</span><br><span class="line">	c.Name = name</span><br><span class="line">	c.metrics = newMetricExchange(name)</span><br><span class="line">	c.executorPool = newExecutorPool(name)</span><br><span class="line">	c.mutex = &amp;sync.RWMutex&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>All the fields of <code>CircuitBreaker</code> are important to understand how the breaker works.</p>
<img src="/images/circuitbreakstruct.png" title="circuitbreak" width="300px" height="400px">

<p>There are two fields that are not simple type need more analysis, include <code>executorPool</code> and <code>metrics</code>. </p>
<ul>
<li><strong>executorPool</strong>: used for <code>max concurrent request number</code> strategy, which is just this article’s topic.</li>
<li><strong>metrics</strong>: used for <code>request error rate</code> strategy, which will be discussed in the next article, all right? </li>
</ul>
<h3 id="executorPool"><a href="#executorPool" class="headerlink" title="executorPool"></a>executorPool</h3><p>We can find <code>executorPool</code> logics inside the <code>pool.go</code> file:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> executorPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Metrics *poolMetrics</span><br><span class="line">	Max     <span class="type">int</span></span><br><span class="line">	Tickets <span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125; <span class="comment">// Tickets channel </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newExecutorPool</span><span class="params">(name <span class="type">string</span>)</span></span> *executorPool &#123;</span><br><span class="line">	p := &amp;executorPool&#123;&#125;</span><br><span class="line">	p.Name = name</span><br><span class="line">	p.Metrics = newPoolMetrics(name)</span><br><span class="line">	p.Max = getSettings(name).MaxConcurrentRequests</span><br><span class="line"></span><br><span class="line">	p.Tickets = <span class="built_in">make</span>(<span class="keyword">chan</span> *<span class="keyword">struct</span>&#123;&#125;, p.Max)</span><br><span class="line">	<span class="comment">// send Max numbers of value into the Tickets channel</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.Max; i++ &#123;</span><br><span class="line">		p.Tickets &lt;- &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It makes use of golang <code>channel</code> to realize <code>max concurrent request number</code> strategy. Note that <code>Tickets</code> field, which is a buffered channel with capicity of <strong>MaxConcurrentRequests</strong> is created. And in the following <strong>for</strong> loop, make the buffered channel full by sending value into the channel until reaching the capacity. </p>
<p>As we have shown above, in the first goroutine of <code>GoC</code> function, the <code>Tickets</code> channel is used as follows:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cmd.ticket = &lt;-circuit.executorPool.Tickets: <span class="comment">// receive ticket from Tickets channel</span></span><br><span class="line">		ticketChecked = <span class="literal">true</span></span><br><span class="line">		ticketCond.Signal()</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ticketChecked = <span class="literal">true</span></span><br><span class="line">		ticketCond.Signal()</span><br><span class="line">		cmd.Unlock()</span><br><span class="line">		returnOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			returnTicket()</span><br><span class="line">			cmd.errorWithFallback(ctx, ErrMaxConcurrency) <span class="comment">// run fallback logic when concurrent requests reach threshold</span></span><br><span class="line">			reportAllEvent()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Each call to <code>GoC</code> function will get a <strong>ticket</strong> from <strong>circuit.executorPool.Tickets</strong> channel until no <strong>ticket</strong> is left, which means the number of concurrent requests reaches the threshold. In that case, the <code>default</code> case will execute , and the service will be gracefully degraded with fallback logic.</p>
<p>On the other side, after each call to <code>GoC</code> is done, the <strong>ticket</strong> need to be sent back to the <strong>circuit.executorPool.Tickets</strong>, right? Do you remember the <code>returnTicket</code> function mentioned in above section. Yes, it is just used for this purpose. The <code>returnTicket</code> function defined in <code>GoC</code> function goes as follows:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">returnTicket := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd.Lock()</span><br><span class="line">	<span class="keyword">for</span> !ticketChecked &#123;</span><br><span class="line">		ticketCond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.circuit.executorPool.Return(cmd.ticket) <span class="comment">// return ticket to the executorPool</span></span><br><span class="line">	cmd.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It calls <code>executorPool.Return</code> function: </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return function in pool.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *executorPool)</span></span> Return(ticket *<span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">if</span> ticket == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p.Metrics.Updates &lt;- poolMetricsUpdate&#123;</span><br><span class="line">		activeCount: p.ActiveCount(),</span><br><span class="line">	&#125;</span><br><span class="line">	p.Tickets &lt;- ticket <span class="comment">// send ticket back to Tickets channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The design and implementation of <strong>Tickets</strong> is a great example of <code>golang channel</code> in the real-world application.  </p>
<p>In summary, the <code>max concurrent request number</code> strategy can be illustrated as follows:</p>
<img src="/images/hystrix-concurrent-architecture.png" title="circuitbreak" width="800px" height="400px">


<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, <code>max concurrent requests</code> strategy in <code>hystrix</code> is reviewed carefully, and I hope you can learn something interesting from it.</p>
<p>But I didn’t cover the detailed logics inside <code>GoC</code> function, including <code>sync.Cond</code>, <code>sync.Once</code> and fallback logics. Let’s review them and <code>timeout</code> strategy together in the next article. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/30/hystrix-circuit-breaker-part2/" data-id="clvv1t4im0022c8mmckqf3shc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hystric-circuit-breaker-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/hystric-circuit-breaker-part1/" class="article-date">
  <time datetime="2021-05-21T07:25:19.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/hystric-circuit-breaker-part1/">Circuit breaker and Hystrix: part one - introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this series of articles, I want to talk about <code>circuit breaker</code> pattern based on an popular open source project <code>hystrix</code> (in fact, I will take a look at the golang version <a target="_blank" rel="noopener" href="https://github.com/afex/hystrix-go">hystrix-go</a>, instead of the <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">original version</a> which is written in Java).</p>
<p>As the first article of this series, I will give a general introduction to <code>circuit breaker</code>, let you know what it is and why it is important. Moreover, let’s review the background about the project <code>hystrix-go</code> and <code>hystrix</code>, and understand the basic usage with a small demo example. </p>
<h3 id="Circuit-breaker"><a href="#Circuit-breaker" class="headerlink" title="Circuit breaker"></a>Circuit breaker</h3><p>Software in distributed architectures generally have many dependencies, and the failure at some point for each dependency(even the most reliable service) is inevitable. </p>
<p>What happens if our failing service becomes unresponsive? All services that rely on it have risks to become unresponsive, too. This is called <code>catastrophic cascading failure.</code></p>
<p>The basic idea behind the circuit breaker is very simple. A circuit breaker works by wrapping calls to a target service and keeps monitoring the failure rates. Once the failures reach a certain threshold, the circuit breaker will trip ，and all the further calls to the circuit return with a fault or error. </p>
<p>The design philosophy behind the circuit breaker pattern is <code>fail fast</code>: when a service becomes unresponsive, other services relying on it should stop waiting for it and start dealing with the fact that the failing service may be unavailable. By preventing a single service’s failure cascading through the entire system, the circuit breaker pattern contributes to the <code>stability</code> and <code>resilience</code> of the whole system.  </p>
<p>The circuit breaker pattern can be implemented as a finite-state machine shown below:</p>
<p><img src="/images/circuit-breaker.png" alt="circuit-breaker"></p>
<p>There are three statuses: <code>open</code>, <code>closed</code> and <code>half-open</code></p>
<ul>
<li><strong>closed</strong>: Requests are passed to the target service. Keep monitoring the metrics like error rate, request numbers and timeout. When these metrics exceed a specific threshold(which is set by the developer), the breaker is tripped and transitions into <code>open</code> status.   </li>
<li><strong>open</strong>: Requests are not passed to the target service, instead the <code>fallback</code> logic(which is defined by developer as well) will be called to handle the failure. The breaker will stay <code>open</code> status for a period of time called <code>sleeping window</code>, after which the breaker can transition from <code>open</code> to <code>half-open</code>.  </li>
<li><strong>half-open</strong>: In this status, a limited number of requests are passed to the target service, which is aims at resetting the status. If the target service can response successfully then the break is <code>reset</code> back to <code>closed</code> status. Or else the breaker transitions back to <code>open</code> status. </li>
</ul>
<p>That’s basic background about circuit breaker, you can find much more <a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">information</a> about it on line. </p>
<p>Next, let’s investigate the project <code>hystrix</code>. </p>
<h3 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h3><p><code>hystrix</code> is a very popular open source project. You can find everything about it in this <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">link</a>. </p>
<p>I want to quote several important points from the above link. Hystrix is designed to do the following:</p>
<ul>
<li>Give protection from and control over latency and failure from dependencies accessed (typically over the network) via third-party client libraries.</li>
<li>Stop cascading failures in a complex distributed system.</li>
<li>Fail fast and rapidly recover.</li>
<li>Fallback and gracefully degrade when possible.</li>
<li>Enable near real-time monitoring, alerting, and operational control.</li>
</ul>
<p>You can see <code>hystrix</code> perfectly implements the idea of circuit breaker pattern we talked about in the last section, right? </p>
<p>The <code>hystrix</code> project is developed with <code>Java</code>. In this sereis of articles I prefer to use a golang version <code>hystrix-go</code>, which is a simplified version but implements all the main designs and ideas about circuit breaker. </p>
<p>For the usage of <code>hystrix-go</code>, you can find it in this <a target="_blank" rel="noopener" href="https://github.com/afex/hystrix-go">link</a>, which is very straightforward to understand. And you can easily find many other articles online with demo examples to show more usage level stuff. Please go head to read.</p>
<p>In my articles, I want to go into the source code of <code>hystrix-go</code> and have an advanced investigation about how <code>circuit breaker</code> is implemented. Please follow up to read the next articles in this series. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, I talked about the background of circuit breaker pattern and the basic information of the popular open-source project in this field <code>hystrix-go</code>. Next step, we will take an in-depth look at the source code of this project. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/21/hystric-circuit-breaker-part1/" data-id="clvv1t4in0024c8mm0nh52q9z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-sync-cond" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/14/golang-sync-cond/" class="article-date">
  <time datetime="2021-05-14T02:14:18.000Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/14/golang-sync-cond/">golang-sync-cond</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/05/14/golang-sync-cond/" data-id="clvv1t4id0012c8mm9k6de61o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binary-Search-Tree-delete-balanced-performance/" rel="tag">Binary Search Tree, delete, balanced, performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-Foundation-Scholarship-LIFT/" rel="tag">Linux Foundation, Scholarship, LIFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scalability-AWS/" rel="tag">Scalability, AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" rel="tag">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dotnet-GC-memory-leak-WinDbg/" rel="tag">dotnet, GC, memory leak, WinDbg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Binary-Search-Tree-delete-balanced-performance/" style="font-size: 10px;">Binary Search Tree, delete, balanced, performance</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-Foundation-Scholarship-LIFT/" style="font-size: 10px;">Linux Foundation, Scholarship, LIFT</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/Scalability-AWS/" style="font-size: 10px;">Scalability, AWS</a> <a href="/tags/Service-Fabric-stateless-stateful-actor-model-scalability-reliability-partition/" style="font-size: 10px;">Service Fabric, stateless, stateful, actor model, scalability, reliability,  partition</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/dotnet-GC-memory-leak-WinDbg/" style="font-size: 10px;">dotnet, GC, memory leak, WinDbg</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/01/dotnet-gc-memory-leak-windbg/">Diagnose Memory Leaks in .NET Applications with WinDbg: A Hands-on Approach</a>
          </li>
        
          <li>
            <a href="/2023/06/09/lift-scholarship-program/">Linux Foundation Scholarship</a>
          </li>
        
          <li>
            <a href="/2023/04/09/understand-more-aws-service-by-negative-cases/">Scalability Lessons Learned from Amazon Return to The Monolith</a>
          </li>
        
          <li>
            <a href="/2023/03/20/guide-to-service-fabric-architecture/">Build Microservices with Service Fabric: A Hands-on Approach</a>
          </li>
        
          <li>
            <a href="/2023/02/13/note-on-red-black-tree/">Understand Red Black Tree: part one - background</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
    <a href="/book-reviews" class="mobile-nav-link">Book Review</a>
  
    <a href="/solopreneur" class="mobile-nav-link">Solopreneur</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>