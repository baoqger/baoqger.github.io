<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Write a Linux packet sniffer from scratch: part two- BPF | Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IntroductionIn the previous article, we examined how to develop a network sniffer with PF_SOCKET socket in Linux platform. The sniffer developed in the last article captures all the network packets. B">
<meta property="og:type" content="article">
<meta property="og:title" content="Write a Linux packet sniffer from scratch: part two- BPF">
<meta property="og:url" content="https://baoqger.github.io/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:description" content="IntroductionIn the previous article, we examined how to develop a network sniffer with PF_SOCKET socket in Linux platform. The sniffer developed in the last article captures all the network packets. B">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baoqger.github.io/images/pf-packet-socket.png">
<meta property="og:image" content="https://baoqger.github.io/images/bpf-instructions.png">
<meta property="og:image" content="https://baoqger.github.io/images/address-mode.png">
<meta property="og:image" content="https://baoqger.github.io/images/ethernet-frame-format.png">
<meta property="og:image" content="https://baoqger.github.io/images/bpf-run-instructions.png">
<meta property="article:published_time" content="2022-03-28T06:15:15.000Z">
<meta property="article:modified_time" content="2022-04-23T00:30:12.713Z">
<meta property="article:author" content="Chris Bao">
<meta property="article:tag" content="BPF, JIT, virtual machine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baoqger.github.io/images/pf-packet-socket.png">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-how-to-implement-libpcap-on-linux-with-raw-socket-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" class="article-date">
  <time datetime="2022-03-28T06:15:15.000Z" itemprop="datePublished">2022-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Write a Linux packet sniffer from scratch: part two- BPF
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>In the <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">previous article</a>, we examined how to develop a network sniffer with <code>PF_SOCKET</code> socket in Linux platform. The sniffer developed in the last article captures all the network packets. But a powerful network sniffer like <code>tcpdump</code> should provide the packet filtering functionality. For instance, the sniffer can only capture the <code>TCP</code> segment(and skip the UPD), or it can only capture the packets from a specific source IP address. In this article, let’s continue to explore how to do that. </p>
<h3 id="Background-of-BPF"><a href="#Background-of-BPF" class="headerlink" title="Background of BPF"></a>Background of BPF</h3><p><code>Berkeley Packet Filter(BPF)</code> is the essential underlying technology for packet capture in Unix-like operating systems.<br>Search BPF as the keyword online, and the result is very confusing. It turns out that <code>BPF</code> keeps evolving, and there are several associated concepts such as <code>BPF</code> <code>cBPF</code> <code>eBPF</code> and <code>LSF</code>. So let us examine those concepts along the timeline:</p>
<ul>
<li><p>In <strong>1992</strong>, <code>BPF</code> was first introduced to the BSD Unix system for filtering unwanted network packets. The proposal of BPF was from researchers in Lawrence Berkeley Laboratory, who also developed the <code>libpcap</code> and <code>tcpdump</code>. </p>
</li>
<li><p>In <strong>1997</strong>, Linux Socket Filter(LSF) was developed based on BPF and introduced in Linux kernel version 2.1.75. Note that <code>LSF</code> and <code>BPF</code> have some distinct differences, but in the Linux context, when we speak of BPF or LSF, we mean the same packet filtering mechanism in the Linux kernel. We’ll examine the detailed theory and design of BPF in the following sections. </p>
</li>
<li><p>Originally, BPF was designed as a network packet filter. But in <strong>2013</strong>, BPF was widely extended, and it can be used for non-networking purposes such as performance analysis and troubleshooting. Nowadays, the extended BPF is called <code>eBPF</code>, and the original and obsolete version is renamed to classic BPF (<code>cBPF</code>). <strong>Note that what we examine in this article is cBPF, and eBPF is not inside the scope of this article</strong>. <code>eBPF</code> is the hottest technology in today’s software world, and I’ll talk about it in the future. </p>
</li>
</ul>
<h3 id="Where-to-place-BPF"><a href="#Where-to-place-BPF" class="headerlink" title="Where to place BPF"></a>Where to place BPF</h3><p>The first question to answer is where should we place the filter. The last article examines the path of a received packet  as follows: </p>
<img src="/images/pf-packet-socket.png" title="PF_PACKET socket" width="400px" height="300px">

<p>The best solution to this question is to put the filter as early as possible in the path. Since copying a large amount of data from kernel space to the user space produces a huge overhead, which can influence the system performance a lot. So BPF is a kernel feature. The filter should be triggered immediately when a packet is received at the network interface.As the original BPF <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> said <strong>To minimize memory traffic, the major bottleneck in most modern system, the packet should be filtered ‘in place’ (e.g., where the network interface DMA engine put it) rather than copied to some other kernel buffer before filtering.</strong><br>Let’s verify this behavior by examining the kernel source code as follows (<strong>Note</strong> the kernel code shown in this article is based on version 2.6, which contains the <code>cBPF</code> implementation.): </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* source code file of net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* packet_create: create socket */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_create</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> socket *sock, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">	po = pkt_sk(sk);</span><br><span class="line">	sk-&gt;sk_family = PF_PACKET;</span><br><span class="line">	po-&gt;num = proto;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;po-&gt;bind_lock);</span><br><span class="line">	po-&gt;prot_hook.func = packet_rcv; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;type == SOCK_PACKET)</span><br><span class="line">		po-&gt;prot_hook.func = packet_rcv_spkt; <span class="comment">// attach hook function to socket</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proto) &#123;</span><br><span class="line">		po-&gt;prot_hook.type = proto;</span><br><span class="line">		dev_add_pack(&amp;po-&gt;prot_hook);</span><br><span class="line">		sock_hold(sk);</span><br><span class="line">		po-&gt;running = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_create</code> function handles the socket creation when the application calls the <code>socket</code> system call. In lines 11 and 14, it attaches the hook function to the socket. The hook function executes when the packet is received.</p>
<p>The following code block shows the hook function <code>packet_rcv</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hook function packet_rcv is triggered, when the packet is received */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* some code omitted ... */</span></span><br><span class="line">    sk = pt-&gt;af_packet_priv;</span><br><span class="line">    snaplen = skb-&gt;len;</span><br><span class="line">    res = run_filter(skb, sk, snaplen); <span class="comment">// filter logic</span></span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">	    <span class="keyword">goto</span> drop_n_restore; <span class="comment">// drop the packet</span></span><br><span class="line"></span><br><span class="line">    __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb); <span class="comment">// put the packet into the queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packet_rcv</code> function calls <code>run_filter</code>, which is just the BPF logic part(Currently, you can regard it as a black box. In the next section, we’ll examine the details). Based on the return value of <code>run_filter</code> the packet can be filtered out or put into the queue. </p>
<p>So far, you can understand BPF(or the packet filtering) is working inside kernel space. But the packet sniffer is a user-space application. The next question is how to link the filtering rules in user space to the filtering handler in kernel space. </p>
<p>To answer this question, we have to understand BPF itself. It’s right time to understand this great piece of work. </p>
<h3 id="BPF-machine"><a href="#BPF-machine" class="headerlink" title="BPF machine"></a>BPF machine</h3><p>As I mentioned above, <code>BPF</code> was introduced in this original <a target="_blank" rel="noopener" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf">paper</a> written by researchers from Berkeley. I strongly recommend you read this great paper based on my own experience. In the beginning, I felt crazy to read it, so I read other related documents and tried to understand BPF. But most documents only cover one portion of the entire system, so it is difficult to piece all the information together. Finally, I read the original paper and connected all parts together. <strong>As the saying goes, sometimes taking time is actually a shortcut.</strong></p>
<h5 id="Virtual-CPU"><a href="#Virtual-CPU" class="headerlink" title="Virtual CPU"></a>Virtual CPU</h5><p>A packet filter is simply a boolean-valued function on a packet. If the value of the function is true the kernel copies the packet for the application; if it is false the packet is ignored. </p>
<p>In order to be as flexible as possible and not to limit the application to a set of predefined conditions, the <code>BPF</code> is actually implemented as a <code>register-based virtual machine</code> (for the difference between stack-based and register-based virtual machine, you can refer to <a target="_blank" rel="noopener" href="http://troubles.md/wasm-is-not-a-stack-machine/">this article</a>) running a user-defined program.  </p>
<p>You can regard the <code>BPF</code> as a <code>virtual CPU</code>. And it consists of an <code>accumulator</code>, an <code>index register(x)</code>, a scratch memory store, and an implicit <code>program counter</code>. If you’re not familiar with these concepts, I add some simple illustrations as follows:</p>
<ul>
<li>An <code>accumulator</code> is a type of register included in a CPU. It acts as a temporary storage location holding an intermediate value in mathematical and logical calculations. For example, in the operation of “1+2+3”, the accumulator would hold the value 1, then the value 3, then the value 6. The benefit of an accumulator is that it does not need to be explicitly referenced.</li>
<li>An <code>index register</code> in a computer’s CPU is a processor register or assigned memory location used for modifying operand addresses during the run of a program. </li>
<li>A <code>program counter</code> is a CPU register in the computer processor which has the address of the next instruction to be executed from memory. </li>
</ul>
<p>In the BPF machine, the accumulator is used for arithmetic operations, while the index register provides offsets into the packet or the scratch memory areas.  </p>
<h5 id="Instructions-set-and-addressing-mode"><a href="#Instructions-set-and-addressing-mode" class="headerlink" title="Instructions set and addressing mode"></a>Instructions set and addressing mode</h5><p>Same as the physical CPU, the <code>BPF</code> provides a small set of arithmetic, logical and jump instructions as follows, these instructions run on the BPF virtual machine(or CPU): </p>
<img src="/images/bpf-instructions.png" title="BPF instructions" width="400px" height="300px">

<p>The first column <em>opcodes</em> lists the BPF instructions written in an assembly language style. For example, <strong>ld</strong>, <strong>ldh</strong> and <strong>ldb</strong> means to copy the indicated value into the <code>accumulator</code>. <strong>ldx</strong> means to copy the indicated value into the <code>index register</code>. <strong>jeq</strong> means jump to the target instruction if the <code>accumulator</code> equals the indicated value. <strong>ret</strong> means return the indicated value. You can check the functionality of the instructions set in detail in the paper. </p>
<p>This kind of assembly-like style is more readable to humans. But when we develop an application (like the sniffer written in this article), we use binary code directly as the BPF instruction. This kind of binary format is called <code>BPF Bytecode</code>. I’ll examine the way to convert this assembly language to bytecode later. </p>
<p>The second column <em>addr modes</em> lists the addressing modes allowed for each instruction. The semantics of the addressing modes are listed in the following table: </p>
<img src="/images/address-mode.png" title="BPF instructions address mode" width="400px" height="300px">

<p>For instance, <strong>[k]</strong> means the data at byte offset k in the packet. <strong>#k</strong> means the literal value stored in k. You can read the paper in detail to check the meaning of other address modes.  </p>
<h5 id="Example-BPF-program"><a href="#Example-BPF-program" class="headerlink" title="Example BPF program"></a>Example BPF program</h5><p>Now let’s try to understand the following small BPF program based on the knowledge above: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2    jf 3</span><br><span class="line">(002) ret      #262144</span><br><span class="line">(003) ret      #0</span><br></pre></td></tr></table></figure>
<p>The BPF program consists of an array of BPF instructions. For example, the above BPF program contains four instructions. </p>
<p>The first instruction <strong>ldh</strong> loads a half-word(16-bit) value into the accumulator from offset 12 in the Ethernet packet. According to the Ethernet frame format shown below, the value is just the <code>Ethernet type</code> field. The Ethernet type is used to indicate which protocol is encapsulated in the frame’s payload (for example,  0x0806 for ARP, <strong>0x0800</strong> for IPv4, and 0x86DD for IPv6).</p>
<img src="/images/ethernet-frame-format.png" title="Ethernet frame fromat" width="600px" height="400px">

<p>The second instruction <strong>jeq</strong> compares the accumulator (currently stores <code>Ethernet type</code> field) to <code>0x800</code>(stands for IPv4). If the comparison fails, zero is returned, and the packet is rejected. If it is successful, a non-zero value is returned, and the packet is accepted. <strong>So the small BPF program filters and accepts all IP packets</strong>. You can find other BPF programs in the original paper. Go to read it, and you can feel the flexibility of BPF as well as the beauty of the design. </p>
<h5 id="Kernel-implementation-of-BPF"><a href="#Kernel-implementation-of-BPF" class="headerlink" title="Kernel implementation of BPF"></a>Kernel implementation of BPF</h5><p>Next, let’s examine how kernel implements BPF. As mentioned above, the hook function <code>packet_rcv</code> calls <code>run_filter</code> to handle the filtering logic. <code>run_filter</code> is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copied from net/packet/af_packet.c */</span></span><br><span class="line"><span class="comment">/* function run_filter is called in packet_rcv*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock *sk,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">int</span> res)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_filter</span> *<span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_bh();</span><br><span class="line">	filter = rcu_dereference(sk-&gt;sk_filter); <span class="comment">// get the filter bound to the socket</span></span><br><span class="line">	<span class="keyword">if</span> (filter != <span class="literal">NULL</span>)</span><br><span class="line">		res = sk_run_filter(skb, filter-&gt;insns, filter-&gt;len); <span class="comment">// the filtering is inside sk_run_filter function</span></span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find that the real filtering logic is inside <code>sk_run_filter</code>:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sk_run_filter</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> sock_filter *filter, <span class="type">int</span> flen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> *<span class="title">fentry</span>;</span>	<span class="comment">/* We walk down these */</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line">	u32 A = <span class="number">0</span>;			<span class="comment">/* Accumulator */</span></span><br><span class="line">	u32 X = <span class="number">0</span>;			<span class="comment">/* Index Register */</span></span><br><span class="line">	u32 mem[BPF_MEMWORDS];		<span class="comment">/* Scratch Memory Store */</span></span><br><span class="line">	u32 tmp;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">int</span> pc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Process array of filter instructions.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (pc = <span class="number">0</span>; pc &lt; flen; pc++) &#123;</span><br><span class="line">		fentry = &amp;filter[pc];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (fentry-&gt;code) &#123;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_X:</span><br><span class="line">			A += X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_ADD|BPF_K:</span><br><span class="line">			A += fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_X:</span><br><span class="line">			A -= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_SUB|BPF_K:</span><br><span class="line">			A -= fentry-&gt;k;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_ALU|BPF_MUL|BPF_X:</span><br><span class="line">			A *= X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/* some code omitted ... */</span></span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_K:</span><br><span class="line">			<span class="keyword">return</span> fentry-&gt;k;</span><br><span class="line">		<span class="keyword">case</span> BPF_RET|BPF_A:</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		<span class="keyword">case</span> BPF_ST:</span><br><span class="line">			mem[fentry-&gt;k] = A;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> BPF_STX:</span><br><span class="line">			mem[fentry-&gt;k] = X;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Same as we mentioned, <code>sk_run_filter</code> is simply a boolean-valued function on a packet. It maintains the accumulator, the index register, etc. as local variables. And process the array of BPF filter instructions in a <code>for</code> loop. Each instruction will update the value of local variables. In this way, it simulates a virtual CPU. Interesting, right? </p>
<h5 id="BPF-JIT"><a href="#BPF-JIT" class="headerlink" title="BPF JIT"></a>BPF JIT</h5><p>Since each network packet must go through the filtering function, it becomes the performance bottleneck of the entire system. </p>
<p>A <code>just-in-time (JIT)</code> compiler was introduced into the kernel in <strong>2011</strong> to speed up BPF bytecode execution. </p>
<ul>
<li>What is a <code>JIT</code> compiler? A <code>JIT</code> compiler runs <strong>after</strong> the program has started and compiles the code(usually bytecode or some type of VM instructions) on the fly(or just in time) into a form that’s usually faster, typically the host CPU’s native instruction set. This is in contrast to a <code>traditional compiler</code> that compiles all the code to machine language <strong>before</strong> the program is first run. </li>
</ul>
<p>In the <code>BPF</code> case, the <code>JIT</code> compiler translates BPF bytecode into a host system’s assembly code directly, which can optimize the performance a lot. I’ll not show details about JIT in this article. You can refer to the <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.19.8/source/arch/arm/net/bpf_jit_32.c#L868">kernel code</a>.  </p>
<h3 id="Set-BPF-in-sniffer"><a href="#Set-BPF-in-sniffer" class="headerlink" title="Set BPF in sniffer"></a>Set BPF in sniffer</h3><p>Next, let’s add BPF into our packet sniffer. As we mentioned above in the application level, the BPF instructions should use bytecode format with the following data structure:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>    <span class="comment">/* Filter block */</span></span><br><span class="line">        __u16   code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">        __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">        __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">        __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How can we convert the BPF assembly language into bytecode? There are two solutions. First, there is a small helper tool called <code>bpf_asm</code>(which is provided along with the Linux kernel), and you can regard it as the BPF assembly language interpreter. But it is not recommended to application developers. </p>
<p>Second, we can use <code>tcpdump</code>, which provides the converting functionality. You can find the following information from the tcpdump man page: </p>
<ul>
<li><p>-d:   Dump the compiled packet-matching code in a human-readable form to standard output and stop.</p>
</li>
<li><p>-dd:  Dump packet-matching code as a C program fragment.</p>
</li>
<li><p>-ddd: Dump packet-matching code as decimal numbers (preceded with a count).</p>
</li>
</ul>
<p><code>tcpdump ip</code> means we want to capture all the IP packets. With options <strong>-d</strong>, <strong>-dd</strong> and <strong>-ddd</strong>, the output goes as follows: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">baoqger@ubuntu:~$ sudo tcpdump -d ip</span><br><span class="line">[sudo] password <span class="keyword">for</span> baoqger:</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      <span class="comment">#0x800           jt 2    jf 3</span></span><br><span class="line">(002) ret      <span class="comment">#262144</span></span><br><span class="line">(003) ret      <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -<span class="built_in">dd</span> ip</span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br><span class="line"></span><br><span class="line">baoqger@SLB-C8JWZH3:~$ sudo tcpdump -ddd ip</span><br><span class="line">4</span><br><span class="line">40 0 0 12</span><br><span class="line">21 0 1 2048</span><br><span class="line">6 0 0 262144</span><br><span class="line">6 0 0 0</span><br></pre></td></tr></table></figure>
<p>Option <strong>-d</strong> prints the BPF instructions in assembly language (same as the example BPF program shown above). Options <strong>-dd</strong> prints the bytecode as a C program fragment. <strong>So tcpdump is the most convenient tool when you want to get the BPF bytecode</strong>.</p>
<p>The BPF filter bytecode (wrapped in the structure <code>sock_fprog</code>) can be passed to the kernel through <code>setsockopt</code> system call as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attach the filter to the socket</span></span><br><span class="line"><span class="comment">// the filter code is generated by running: tcpdump tcp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">BPF_code</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00000800</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00040000</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">Filter</span>;</span></span><br><span class="line"><span class="comment">// error prone code, .len field should be consistent with the real length of the filter code array</span></span><br><span class="line">Filter.len = <span class="keyword">sizeof</span>(BPF_code)/<span class="keyword">sizeof</span>(BPF_code[<span class="number">0</span>]); </span><br><span class="line">Filter.filter = BPF_code;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;setsockopt attach filter&quot;</span>);</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>setsockopt</code> system call triggers two kernel functions: <code>sock_setsockopt</code> and <code>sk_attach_filter</code> (I’ll not show the details for these two functions), which <strong>binds the filters to the socket</strong>. And in <code>run_filter</code> kernel function (mentioned above), it can <strong>get the filters from the socket</strong> and <strong>execute the filters on the packet</strong>. </p>
<p>So far, every piece is connected. The puzzle of BPF is solved. The <code>BPF</code> machine allows the user-space applications to inject customized BPF programs straight into a kernel. Once loaded and verified, BPF programs execute in kernel context. These BPF programs operate inside kernel memory space with access to all the internal kernel states available to it. For example, the <code>cBPF</code> machine which uses the network packet data. But this power can be extended as <code>eBPF</code>, which can be used in many other varied applications. As someone <a target="_blank" rel="noopener" href="https://www.brendangregg.com/bpf-performance-tools-book.html">said</a> <strong>In some way, eBPF does to the kernel what Javascript does to the websites: it allows all sorts of new application to be created.</strong>  In the future, I plan to examine eBPF in depth. </p>
<img src="/images/bpf-run-instructions.png" title="BPF Run Instructions" width="600px" height="400px">

<h3 id="Process-the-packet"><a href="#Process-the-packet" class="headerlink" title="Process the packet"></a>Process the packet</h3><p>We examined the <code>BPF</code> filtering theory on the kernel level a lot in the above section. But for our tiny sniffer, the last step we need to do is process the network packet. </p>
<ul>
<li><p>First, the <code>recvfrom</code> system call reads the packet from the socket. And we put the system call in a <code>while</code> loop to keep reading the incoming packets. </p>
</li>
<li><p>Then, we print the source and destination <code>MAC</code> address in the packet(the packet we got is a raw Ethernet frame in Layer 2, right?). And if what this Ethernet frame contains is an <code>IP4</code> packet, then we print out the source and destination <code>IP</code> address. To understand more about it, you can study the header format of various network protocols. I will not cover in details here.</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------\n&quot;</span>);</span><br><span class="line">	n = recvfrom(sock, buffer, <span class="number">2048</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d bytes read\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check to see if the packet contains at least</span></span><br><span class="line"><span class="comment">	* complete Ethernet (14), IP (20) and TCP/UDP</span></span><br><span class="line"><span class="comment">	* (8) headers.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">42</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;recvfrom():&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Incomplete packet (errno is %d)\n&quot;</span>, errno);</span><br><span class="line">		close(sock);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ethhead = buffer;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Source MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">0</span>], ethhead[<span class="number">1</span>], ethhead[<span class="number">2</span>], ethhead[<span class="number">3</span>], ethhead[<span class="number">4</span>], ethhead[<span class="number">5</span>]</span><br><span class="line">	);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Destination MAC address: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n&quot;</span>,</span><br><span class="line">		ethhead[<span class="number">6</span>], ethhead[<span class="number">7</span>], ethhead[<span class="number">8</span>], ethhead[<span class="number">9</span>], ethhead[<span class="number">10</span>], ethhead[<span class="number">11</span>]</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	iphead = buffer + <span class="number">14</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*iphead==<span class="number">0x45</span>) &#123; <span class="comment">/* Double check for IPv4</span></span><br><span class="line"><span class="comment">						* and no options present */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">12</span>],iphead[<span class="number">13</span>],</span><br><span class="line">				iphead[<span class="number">14</span>],iphead[<span class="number">15</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Dest host %d.%d.%d.%d\n&quot;</span>,</span><br><span class="line">				iphead[<span class="number">16</span>],iphead[<span class="number">17</span>],</span><br><span class="line">				iphead[<span class="number">18</span>],iphead[<span class="number">19</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Source,Dest ports %d,%d\n&quot;</span>,</span><br><span class="line">				(iphead[<span class="number">20</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">21</span>],</span><br><span class="line">				(iphead[<span class="number">22</span>]&lt;&lt;<span class="number">8</span>)+iphead[<span class="number">23</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Layer-4 protocol %s\n&quot;</span>, transport_protocol(iphead[<span class="number">9</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can find the complete source code of the sniffer in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c">repo</a>.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we examine how to add filters to our sniffer. First, we analyze why the filter should be running inside kernel space instead of the application space. Then, this article examines the <code>BPF</code> machine design and implementation in detail based on the paper. We reviewed the kernel source code to understand how to implement the <code>BPF</code> virtual machine. As I mentioned above, the original <code>BPF</code>(<code>cBPF</code>) was extended to <code>eBPF</code> now. But the understanding of the BPF virtual machine is very helpful to <code>eBPF</code> as well.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" data-id="clbbn1wkg0039xcmmbvjm3b3r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules
        
      </div>
    </a>
  
  
    <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 10px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/02/external-sorting-one/">External Mergesort: part one</a>
          </li>
        
          <li>
            <a href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
          </li>
        
          <li>
            <a href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
          </li>
        
          <li>
            <a href="/2022/08/05/userland-memory-allocation-one/">Understand userland heap memory allocation: part one - overview</a>
          </li>
        
          <li>
            <a href="/2022/07/22/CPacketSniffer/">cPacketSniffer</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>