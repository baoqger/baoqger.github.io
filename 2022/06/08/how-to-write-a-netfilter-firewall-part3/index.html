<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module | Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="BackgroundIn the previous article, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a Netf">
<meta property="og:type" content="article">
<meta property="og:title" content="Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module">
<meta property="og:url" content="https://baoqger.github.io/2022/06/08/how-to-write-a-netfilter-firewall-part3/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:description" content="BackgroundIn the previous article, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a Netf">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baoqger.github.io/images/netfilter-in-kernel.png">
<meta property="article:published_time" content="2022-06-08T06:59:19.000Z">
<meta property="article:modified_time" content="2022-06-25T04:01:11.982Z">
<meta property="article:author" content="Chris Bao">
<meta property="article:tag" content="Linux module, Netfilter, firewall">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baoqger.github.io/images/netfilter-in-kernel.png">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-how-to-write-a-netfilter-firewall-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/" class="article-date">
  <time datetime="2022-06-08T06:59:19.000Z" itemprop="datePublished">2022-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/05/05/how-to-write-a-netfilter-firewall-part2/">article</a>, we examined how to write a Kernel module and load it dynamically into a running Linux system. Based on this understanding, let’s continue our journey to write a <code>Netfilter</code> module as our mini-firewall.  </p>
<h3 id="Netfilter-architecture"><a href="#Netfilter-architecture" class="headerlink" title="Netfilter architecture."></a>Netfilter architecture.</h3><h5 id="Basics-of-Netfilter-hooks"><a href="#Basics-of-Netfilter-hooks" class="headerlink" title="Basics of Netfilter hooks"></a>Basics of Netfilter hooks</h5><p><strong>The <code>Netfilter</code> framework provides a bunch of <code>hooks</code> in the Linux kernel. As network packets pass through the protocol stack in the kernel, they will traverse these hooks as well</strong>. And Netfilter allows you to write modules and register callback functions with these hooks. When the hooks are triggered, the callback functions will be called. This is the basic idea behind Netfilter architecture. Not difficult to understand, right? </p>
<img src="/images/netfilter-in-kernel.png" title="Netfilter architecture" width="800px" height="600px">

<p>Currently, Netfilter provides the following 5 hooks for <code>IPv4</code>:</p>
<ul>
<li><em>NF_INET_PRE_ROUTING</em>: is triggered right after the packet has been received on a network card. This hook is triggered before the <code>routing decision</code> was made. Then the kernel determines whether this packet is destined for the current host or not. Based on the condition, the following two hooks will be triggered. </li>
<li><em>NF_INET_LOCAL_IN</em>: is triggered for network packets that are destined for the current host. </li>
<li><em>NF_INET_FORWARD</em>: is triggered for network packets that should be forwarded. </li>
<li><em>NF_INET_POST_ROUTING</em>: is triggered for network packets that have been routed and before being sent out to the network card. </li>
<li><em>NF_INET_LOCAL_OUT</em>: is triggered for network packets generated by the processes on the current host.</li>
</ul>
<p>The hook function you defined in the module can mangle or filter the packets, but it eventually must return a status code to Netfilter. There are several possible values for the code, but for now, you only need to understand two of them: </p>
<ul>
<li><em>NF_ACCEPT</em>: this means the hook function accepts the packet and it can go on the network stack trip. </li>
<li><em>NF_DROP</em>: this means the packet is dropped and no further parts of the network stack will be traversed.</li>
</ul>
<p>Netfilter allows you to register multiple callback functions to the same hook with different priorities. If the first hook function accepts the packet, then the packet will be passed to the next functions with low priority. If the packet is dropped by one callback function, then the next functions(if existing) will not be traversed. </p>
<p>As you see, <code>Netfilter</code> has a big scope and I can’t cover every detail in the articles. So the mini-firewall developed here will work on the hook <code>NF_INET_PRE_ROUTING</code>, which means it works by controlling the inbound network traffic. But the way of registering the hook and handling the packet can be applied to all other hooks. </p>
<p><em>Note</em>: there is another remarkable question: what’s the difference between <code>Netfilter</code> and <code>eBPF</code>? If you don’t know eBPF, please refer to my previous <a target="_blank" rel="noopener" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">article</a>. Both of them are important network features in the Linux kernel. The important thing is <code>Netfilter</code> and <code>eBPF</code> hooks are located in different layers of the Kernel. As I drew in the above diagram, <code>eBPF</code> is located in a lower layer. </p>
<h5 id="Kernel-code-of-Netfilter-hooks"><a href="#Kernel-code-of-Netfilter-hooks" class="headerlink" title="Kernel code of Netfilter hooks"></a>Kernel code of Netfilter hooks</h5><p>To have a clear understanding of how the <code>Netfilter</code> framework is implemented inside the protocol stack, let’s dig a little bit deeper and take a look at the kernel source code (Don’t worry, only shows several simple functions). Let’s use the hook <code>NF_INET_PRE_ROUTING</code> as an example; since the mini-firewall will be written based on it. </p>
<p>When an IPv4 packet is received, its handler function <code>ip_rcv</code> will be called as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/net/ipv4/ip_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">        skb = ip_rcv_core(skb, net);</span><br><span class="line">        <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">        <span class="comment">// run Netfilter NF_INET_PRE_ROUTING hook&#x27;s callback function</span></span><br><span class="line">        <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, </span><br><span class="line">                       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">                       ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this handler function, you can see the hook is passed to the function <code>NF_HOOK</code>. Based on the name <code>NF_HOOK</code>, you can guess that it is for triggering the Netfilter hooks. Right? Let’s continue to examine how <code>NF_HOOK</code> is implemented as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">                ret = okfn(net, sk, skb); <span class="comment">// in our case: okfn is ip_rcv_finish</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *      nf_hook - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *      okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *      value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                          <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code omit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>NF_HOOK</code> contains two steps:</p>
<ul>
<li>First, runs the hook’s callback functions by calling the underlying function <code>nf_hook</code>. </li>
<li>Second, invokes the function <code>okfn</code> (passed to <em>NF_HOOK</em> as the argument), if the packet passes through the hook functions and doesn’t drop.</li>
</ul>
<p>For the hook <em>NF_INET_LOCAL_IN</em>, the function <code>ip_rcv_finish</code> will be invoked after the hook functions pass. Its job is to pass the packet on to the next protocol handler(TCP or UDP) in the protocol stack to continue its journey! </p>
<p>The other 4 hooks all use the same function <code>NF_HOOK</code> to trigger the callback functions. The following table shows where the hooks are embedded in the kernel, I leave them to the readers. </p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>File</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>NF_INET_PRE_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_rcv()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_IN</td>
<td>/kernel-src/net/ipv4/ip_input.c</td>
<td>ip_local_deliver()</td>
</tr>
<tr>
<td>NF_INET_FORWARD</td>
<td>/kernel-src/net/ipv4/ip_forward.c</td>
<td>ip_forward()</td>
</tr>
<tr>
<td>NF_INET_POST_ROUTING</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_build_and_send_pkt()</td>
</tr>
<tr>
<td>NF_INET_LOCAL_OUT</td>
<td>/kernel-src/net/ipv4/ip_output.c</td>
<td>ip_output()</td>
</tr>
</tbody></table>
<p>Next, Let’s review the Netfilter’s APIs to create and register the hook function. </p>
<h3 id="Netfilter-API"><a href="#Netfilter-API" class="headerlink" title="Netfilter API"></a>Netfilter API</h3><p>It’s straightforward to create a Netfilter module, which involves three steps: </p>
<ul>
<li>Define the hook function.</li>
<li>Register the hook function in the kernel module initialization process.</li>
<li>Unregister the hook function in the kernel module clean-up process. </li>
</ul>
<p>Let’s go through them quickly one by one. </p>
<h5 id="Define-a-hook-function"><a href="#Define-a-hook-function" class="headerlink" title="Define a hook function"></a>Define a hook function</h5><p>The hook function name can be whatever you want, but it must follow the signature below: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_hookfn</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span>;</span><br></pre></td></tr></table></figure>

<p>The hook function can mangle or filter the packet whose data is stored in the <code>sk_buff</code> structure (we can ignore the other two parameters; since we don’t use them in our mini-firewall). As we mentioned above, the callback function must return a Netfilter status code which is an integer. For instance, the <code>accepted</code> and <code>dropped</code> status is defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Responses from hook functions. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_DROP 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NF_ACCEPT 1</span></span><br></pre></td></tr></table></figure>
<h5 id="Register-and-unregister-a-hook-function"><a href="#Register-and-unregister-a-hook-function" class="headerlink" title="Register and unregister a hook function"></a>Register and unregister a hook function</h5><p>To register a hook function, we should wrap the defined hook function with related information, such as which hook you want to bind to, the protocol family and the priority of the hook function,  into a structure <code>struct nf_hook_ops</code> and pass it to the function <code>nf_register_net_hook</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">        <span class="comment">/* User fills in from here down. */</span></span><br><span class="line">        nf_hookfn               *hook;    <span class="comment">// callback function</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">dev</span>;</span>     <span class="comment">// network device interface</span></span><br><span class="line">        <span class="type">void</span>                    *priv; </span><br><span class="line">        <span class="type">u_int8_t</span>                pf;       <span class="comment">// protocol</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            hooknum;  <span class="comment">// Netfilter hook enum</span></span><br><span class="line">        <span class="comment">/* Hooks are ordered in ascending priority. */</span></span><br><span class="line">        <span class="type">int</span>                     priority; <span class="comment">// priority of callback function</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Most of the fields are very straightforward to understand. The one need to emphasize is the field <code>hooknum</code>, which is just the Netfilter hooks discussed above. They are defined as enumerators as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In source code file /kernel-src/include/uapi/linux/netfilter.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">nf_inet_hooks</span> &#123;</span></span><br><span class="line">	NF_INET_PRE_ROUTING,</span><br><span class="line">	NF_INET_LOCAL_IN,</span><br><span class="line">	NF_INET_FORWARD,</span><br><span class="line">	NF_INET_LOCAL_OUT,</span><br><span class="line">	NF_INET_POST_ROUTING,</span><br><span class="line">	NF_INET_NUMHOOKS,</span><br><span class="line">	NF_INET_INGRESS = NF_INET_NUMHOOKS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Next, let’s take a look at the functions to register and unregister hook functions goes as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/netfilter.h</span></span><br><span class="line"><span class="comment">/* Function to register/unregister hook points. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_unregister_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *ops)</span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter <code>struct net</code> is related to the network namespace, we can ignore it for now and use a default value. </p>
<p>Next, let’s implement our mini-firewall based on these APIs. All right? </p>
<h3 id="Implement-mini-firewall"><a href="#Implement-mini-firewall" class="headerlink" title="Implement mini-firewall"></a>Implement mini-firewall</h3><p>First, we need to clarify the requirements for our mini-firewall. We’ll implement two network traffic control rules in the mini-firewall as follows:</p>
<ul>
<li><em>Network protocol rule</em>: drops the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a> protocol packets.</li>
<li><em>IP address rule</em>: drops the packets from one specific IP address.</li>
</ul>
<p>The completed code implementation is in this Github <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">repo</a>.</p>
<h5 id="Drop-ICMP-protocol-packets"><a href="#Drop-ICMP-protocol-packets" class="headerlink" title="Drop ICMP protocol packets"></a>Drop ICMP protocol packets</h5><p><code>ICMP</code> is a network protocol widely used in the real world. The popular diagnostic tools like <code>ping</code> and <code>traceroute</code> run the ICMP protocol. We can filter out the ICMP packets based on the protocol type in the IP headers with the following hook function: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockicmppkt_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span>   <span class="comment">// IP header</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span> *<span class="title">udph</span>;</span> <span class="comment">// UDP header</span></span><br><span class="line">	<span class="keyword">if</span>(!skb)</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	iph = ip_hdr(skb); <span class="comment">// retrieve the IP headers from the packet</span></span><br><span class="line">	<span class="keyword">if</span>(iph-&gt;protocol == IPPROTO_UDP) &#123; </span><br><span class="line">		udph = udp_hdr(skb);</span><br><span class="line">		<span class="keyword">if</span>(ntohs(udph-&gt;dest) == <span class="number">53</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept UDP packet</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT; <span class="comment">// accept TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (iph-&gt;protocol == IPPROTO_ICMP) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;Drop ICMP packet \n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> NF_DROP;   <span class="comment">// drop TCP packet</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic in the above hook function is easy to understand. First, we retrieve the IP headers from the network packet. And then according to the <code>protocol</code> type field in the headers, we decided to accept TCP and UDP packets but drop the ICMP packets. The only technique we need to pay attention to is the function <code>ip_hdr</code>, which is the kernel function defined as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In source code file /kernel-src/include/linux/ip.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">ip_hdr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)skb_network_header(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// In source code file /kernel-src/include/linux/skbuff.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>ip_hdr</code> delegates the task to the function <code>skb_network_header</code>. It gets IP headers based on the following two data: </p>
<ul>
<li>head: is the pointer to the packet;</li>
<li>network_header: is the offset between the pointer to the packet and the pointer to the network layer protocol header. In detail, you can refer to this <a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/networking.html">document</a>.</li>
</ul>
<p>Next, we can register the above hook function as follows: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">nf_blockicmppkt_ops</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	nf_blockicmppkt_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>,  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hook = (nf_hookfn*)nf_blockicmppkt_handler;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;hooknum = NF_INET_PRE_ROUTING;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockicmppkt_ops-&gt;priority = NF_IP_PRI_FIRST; <span class="comment">// set the priority</span></span><br><span class="line">		</span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">nf_minifirewall_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(nf_blockicmppkt_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_unregister_net_hook(&amp;init_net, nf_blockicmppkt_ops);</span><br><span class="line">		kfree(nf_blockicmppkt_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(nf_minifirewall_init);</span><br><span class="line">module_exit(nf_minifirewall_exit);</span><br></pre></td></tr></table></figure>

<p>The above logic is self-explaining. I will not spend too much time here. </p>
<p>Next, it’s time to demo how our mini-firewall works. </p>
<h5 id="Demo-time"><a href="#Demo-time" class="headerlink" title="Demo time"></a>Demo time</h5><p>Before we load the mini-firewall module, the <code>ping</code> command can work as expected: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">3</span> ttl=<span class="number">104</span> time=<span class="number">71.9</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> sm-<span class="keyword">in</span>-f103<span class="number">.1e100</span>.net (<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>): icmp_seq=<span class="number">4</span> ttl=<span class="number">104</span> time=<span class="number">71.8</span> ms</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> received, <span class="number">0</span>% packet loss, time 3005ms</span><br><span class="line">rtt <span class="built_in">min</span>/avg/<span class="built_in">max</span>/mdev = <span class="number">71.857</span>/<span class="number">71.902</span>/<span class="number">71.961</span>/<span class="number">0.193</span> ms</span><br></pre></td></tr></table></figure>

<p>In contrast, after the mini-firewall module is built and loaded (based on the commands we discussed previously): </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ lsmod | grep mini_firewall</span><br><span class="line">mini_firewall          <span class="number">16384</span>  <span class="number">0</span></span><br><span class="line">chrisbao@CN0005DOU18129:~$ ping www.google.com</span><br><span class="line">PING www.google.com (<span class="number">142.250</span><span class="number">.4</span><span class="number">.105</span>) <span class="number">56</span>(<span class="number">84</span>) <span class="built_in">bytes</span> of data.</span><br><span class="line">^C</span><br><span class="line">--- www.google.com ping statistics ---</span><br><span class="line"><span class="number">6</span> packets transmitted, <span class="number">0</span> received, <span class="number">100</span>% packet loss, time 5097ms</span><br></pre></td></tr></table></figure>

<p>You can see all the packets are lost; because it is dropped by our mini-firewall. We can verify this by running the command <code>dmesg</code>: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">1260.184712</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1261.208637</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1262.232669</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1263.256757</span>] Drop ICMP packet</span><br><span class="line">[ <span class="number">1264.280733</span>] Drop ICMP packet</span><br></pre></td></tr></table></figure>

<p>But other protocol packets can still run through the firewall. For instance, the command <code>wget 142.250.4.103</code> can return normally as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">302</span> Moved Temporarily</span><br><span class="line">Location: http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f [following]</span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span>--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080</span>/php/urlblock.php?args=AAAAfQAAABAjFEC0HSM7xhfO~a53FMMaAAAAEILI_eaKvZQ2xBfgKEgDtwsAAABNAAAATRPNhqoqFgHJ0ggbKLKcdinR4UvnlhgAR4~YyrY4tAnroOFkE_IsHsOg9~RFPc7nEoj6YdiDgqZImAmb_xw9ZuFLvF91P2HzP5tlu1WX&amp;url=http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>%2f</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">6080.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">3248</span> (<span class="number">3.2</span>K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html                                           <span class="number">100</span>%[===================================================================================================================&gt;]   <span class="number">3.17</span>K  --.-KB/s    <span class="keyword">in</span> 0s</span><br><span class="line"></span><br><span class="line"><span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">39</span> (<span class="number">332</span> MB/s) - ‘index.html’ saved [<span class="number">3248</span>/<span class="number">3248</span>]</span><br></pre></td></tr></table></figure>

<p>Next, let’s try to ban the traffic from this IP address. </p>
<h5 id="Drop-packets-source-from-one-specific-IP-address"><a href="#Drop-packets-source-from-one-specific-IP-address" class="headerlink" title="Drop packets source from one specific IP address"></a>Drop packets source from one specific IP address</h5><p>As we mentioned above, multiple callback functions are allowed to be registered on the same Netfilter hook. So we will define the second hook function with a different priority. The logic of this hook function goes like this: we can get the source IP address from the IP headers and make the drop or accept decision according to it. The code goes as follows</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In mini-firewall.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS(addr) \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[3], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[2], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[1], \</span></span><br><span class="line"><span class="meta">	((unsigned char *)&amp;addr)[0]</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *ip_addr_rule = <span class="string">&quot;142.250.4.103&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nf_blockipaddr_handler</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">char</span> *str = (<span class="type">char</span> *)kmalloc(<span class="number">16</span>, GFP_KERNEL);</span><br><span class="line">		u32 sip;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">sb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line"></span><br><span class="line">		sb = skb;</span><br><span class="line">		iph = ip_hdr(sb);</span><br><span class="line">		sip = ntohl(iph-&gt;saddr); <span class="comment">// get source ip address; </span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sprintf</span>(str, <span class="string">&quot;%u.%u.%u.%u&quot;</span>, IPADDRESS(sip)); <span class="comment">// convert to standard IP address format</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(str, ip_addr_rule)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This hook function uses two interesting techniques:</p>
<ul>
<li><p><code>ntohl</code>: is a kernel function, which is used to convert the value from <code>network byte order</code> to <code>host byte order</code>. <code>Byte order</code> is related to the computer science concept of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness"><code>Endianness</code></a>. Endianness defines the order or sequence of bytes of a word of digital data in computer memory. A <code>big-endian</code> system stores the most significant byte of a word at the smallest memory address.  A <code>little-endian</code> system, in contrast, stores the least-significant byte at the smallest address. Network protocol uses the <code>big-endian</code> system. But different OS and platforms run various Endianness system. So it may need such conversion based on the host machine.</p>
</li>
<li><p><code>IPADDRESS</code>: is a macro, which generates the standard IP address format(four 8-bit fields separated by periods) from a 32-bit integer. It uses the technique of <a target="_blank" rel="noopener" href="https://www.eskimo.com/~scs/cclass/notes/sx10e.html"><code>the equivalence of arrays and pointers in C</code></a>. I will write another article to examine what it is and how it works. Please keep watching my updates!</p>
</li>
</ul>
<p>Next, we can register this hook function in the same way discussed above. The only remarkable point is this callback function should have a different priority as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">nf_minifirewall_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">	nf_blockipaddr_ops = (<span class="keyword">struct</span> nf_hook_ops*)kcalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nf_hook_ops), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (nf_blockipaddr_ops != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hook = (nf_hookfn*)nf_blockipaddr_handler;</span><br><span class="line">		nf_blockipaddr_ops-&gt;hooknum = NF_INET_PRE_ROUTING;  <span class="comment">// register to the same hook</span></span><br><span class="line">		nf_blockipaddr_ops-&gt;pf = NFPROTO_IPV4;</span><br><span class="line">		nf_blockipaddr_ops-&gt;priority = NF_IP_PRI_FIRST + <span class="number">1</span>; <span class="comment">// set a higher priority</span></span><br><span class="line"></span><br><span class="line">		nf_register_net_hook(&amp;init_net, nf_blockipaddr_ops);</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-omit code-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s see how it works with a demo. </p>
<h5 id="Demo-time-1"><a href="#Demo-time-1" class="headerlink" title="Demo time"></a>Demo time</h5><p>After re-build and re-load the module, we can get: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ wget <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">--<span class="number">2022</span>-06-<span class="number">25</span> <span class="number">10</span>:<span class="number">20</span>:07--  http://<span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>/</span><br><span class="line">Connecting to <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span>:<span class="number">80.</span>.. failed: Connection timed out.</span><br><span class="line">Retrying.</span><br></pre></td></tr></table></figure>

<p>The <code>wget 142.250.4.103</code> can’t return response. Because it is dropped by our mini-firewall. Great!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrisbao@CN0005DOU18129:~$ dmesg | tail -n <span class="number">5</span></span><br><span class="line">[ <span class="number">3162.064284</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.089466</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3166.288603</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.345463</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br><span class="line">[ <span class="number">3174.480123</span>] Drop packet <span class="keyword">from</span> <span class="number">142.250</span><span class="number">.4</span><span class="number">.103</span></span><br></pre></td></tr></table></figure>

<h3 id="More-space-to-expand"><a href="#More-space-to-expand" class="headerlink" title="More space to expand"></a>More space to expand</h3><p>You can find the full code implementation <a target="_blank" rel="noopener" href="https://github.com/baoqger/linux-mini-firewall-netfilter/blob/main/mini_firewall.c">here</a>. But I have to say, our mini-firewall only touches the surface of what Netfilter can provide. You can keep expanding the functionalities. For example, currently, the rules are hardcoded, why not make it possible to config the rules dynamically. There are many cool ideas worth trying. I leave it for the readers.  </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article, we implement the mini-firewall step by step and examined many detailed techniques. Not only code; but we also verify the behavior of the mini-firewall by running real demos.   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2022/06/08/how-to-write-a-netfilter-firewall-part3/" data-id="cl7s9rtpl002z68mmb63v33ug" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Write a Linux firewall from scratch based on Netfilter: part two - hello world module</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/08/how-to-write-a-netfilter-firewall-part3/">Write a Linux firewall from scratch based on Netfilter: part three - Netfilter module</a>
          </li>
        
          <li>
            <a href="/2022/05/05/how-to-write-a-netfilter-firewall-part2/">Write a Linux firewall from scratch based on Netfilter: part two - hello world module</a>
          </li>
        
          <li>
            <a href="/2022/05/04/how-to-write-a-netfilter-firewall-part1/">Write a Linux firewall from scratch based on Netfilter: part one- Netfilter and Kernel Modules</a>
          </li>
        
          <li>
            <a href="/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/">Write a Linux packet sniffer from scratch: part two- BPF</a>
          </li>
        
          <li>
            <a href="/2022/02/22/how-to-implement-libpcap-on-linux-with-raw-socket-part1/">Write a Linux packet sniffer from scratch: part one- PF_PACKET socket and promiscuous mode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>