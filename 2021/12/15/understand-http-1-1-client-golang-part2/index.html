<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>How  HTTP1.1 protocol is implemented in Golang net/http package: part two -  write HTTP message to socket | Chris Bao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="BackgroundIn the previous article, I introduced the main workflow of an HTTP request implemented inside Golang net&#x2F;http package. As the second article of this series, I’ll focus on how to pass the HTT">
<meta property="og:type" content="article">
<meta property="og:title" content="How  HTTP1.1 protocol is implemented in Golang net&#x2F;http package: part two -  write HTTP message to socket">
<meta property="og:url" content="https://baoqger.github.io/2021/12/15/understand-http-1-1-client-golang-part2/index.html">
<meta property="og:site_name" content="Chris Bao&#39;s Blog">
<meta property="og:description" content="BackgroundIn the previous article, I introduced the main workflow of an HTTP request implemented inside Golang net&#x2F;http package. As the second article of this series, I’ll focus on how to pass the HTT">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://baoqger.github.io/images/golang-http1-1-flow-write-socket.png">
<meta property="article:published_time" content="2021-12-15T06:01:03.000Z">
<meta property="article:modified_time" content="2021-12-23T12:34:34.799Z">
<meta property="article:author" content="Chris Bao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://baoqger.github.io/images/golang-http1-1-flow-write-socket.png">
  
    <link rel="alternate" href="/atom.xml" title="Chris Bao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chris Bao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/project">Project</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://baoqger.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-understand-http-1-1-client-golang-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/understand-http-1-1-client-golang-part2/" class="article-date">
  <time datetime="2021-12-15T06:01:03.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      How  HTTP1.1 protocol is implemented in Golang net/http package: part two -  write HTTP message to socket
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>In the <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">previous</a> article, I introduced the main workflow of an HTTP request implemented inside Golang <code>net/http</code> package. As the second article of this series, I’ll focus on how to pass the HTTP message to TCP/IP stack, and then it can be transported over the network. </p>
<h3 id="Architecture-diagram"><a href="#Architecture-diagram" class="headerlink" title="Architecture diagram"></a>Architecture diagram</h3><p>When the client application sends an HTTP request, it determines what is next step based on whether there is an available persistent connection in the cached connection pool. If no, then a new TCP connection will be established. If yes, then a persistent connection will be selected. </p>
<p>The details of the connection pool is not in this article’s scope. I’ll discuss it in the next article. For now you can regard it as a block box. </p>
<p>The overall diagram of this article goes as follows, we can review each piece of it in the below sections</p>
<img src="/images/golang-http1-1-flow-write-socket.png" title="write to socket" width="800px" height="600px">

<h3 id="persistConn"><a href="#persistConn" class="headerlink" title="persistConn"></a>persistConn</h3><p>The key structure in this part is <code>persistConn</code>: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> persistConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	alt RoundTripper</span><br><span class="line">	t         *Transport</span><br><span class="line">	cacheKey  connectMethodKey</span><br><span class="line">	conn      net.Conn            <span class="comment">// underlying TCP connection</span></span><br><span class="line">	tlsState  *tls.ConnectionState</span><br><span class="line">	br        *bufio.Reader       </span><br><span class="line">	bw        *bufio.Writer       <span class="comment">// buffer io for writing data</span></span><br><span class="line">	nwrite    <span class="type">int64</span>               </span><br><span class="line">	reqch     <span class="keyword">chan</span> requestAndChan </span><br><span class="line">	writech   <span class="keyword">chan</span> writeRequest   <span class="comment">// channel for writing request</span></span><br><span class="line">	closech   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;      </span><br><span class="line">	isProxy   <span class="type">bool</span></span><br><span class="line">	sawEOF    <span class="type">bool</span>  </span><br><span class="line">	readLimit <span class="type">int64</span> </span><br><span class="line">	writeErrCh <span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line">	writeLoopDone <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; </span><br><span class="line">	idleAt    time.Time   </span><br><span class="line">	idleTimer *time.Timer </span><br><span class="line">	mu                   sync.Mutex </span><br><span class="line">	numExpectedResponses <span class="type">int</span></span><br><span class="line">	closed               <span class="type">error</span> </span><br><span class="line">	canceledErr          <span class="type">error</span> </span><br><span class="line">	broken               <span class="type">bool</span> </span><br><span class="line">	reused               <span class="type">bool</span>  </span><br><span class="line">	mutateHeaderFunc <span class="function"><span class="keyword">func</span><span class="params">(Header)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are many fields defined in <code>persistConn</code>, but we can focus on these three: </p>
<ul>
<li><code>conn</code>: type of <code>net.Conn</code> which defines TCP connection in Golang;</li>
<li><code>bw</code>: type of <code>*bufio.Writer</code> which implements <code>buffer io</code> functionality;</li>
<li><code>writech</code>: type of <code>channel</code> which is used to communicate and sync data among different Goroutines in Golang.</li>
</ul>
<p>In next sections, let’s investigate how <code>persistConn</code> is used to write HTTP message to socket. </p>
<h3 id="New-connection"><a href="#New-connection" class="headerlink" title="New connection"></a>New connection</h3><p>First, let’s see how to establish a new TCP connection and bind it to <code>persistConn</code> structure. The job is done inside <strong>dialConn</strong> method of <strong>Transport</strong></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dialConn in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span></span> dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// construct a new persistConn</span></span><br><span class="line">	pconn = &amp;persistConn&#123;</span><br><span class="line">		t:             t,</span><br><span class="line">		cacheKey:      cm.key(),</span><br><span class="line">		reqch:         <span class="built_in">make</span>(<span class="keyword">chan</span> requestAndChan, <span class="number">1</span>),</span><br><span class="line">		writech:       <span class="built_in">make</span>(<span class="keyword">chan</span> writeRequest, <span class="number">1</span>),</span><br><span class="line">		closech:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		writeErrCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>),</span><br><span class="line">		writeLoopDone: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line">	trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line">	wrapErr := <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;net.OpError&#123;Op: <span class="string">&quot;proxyconnect&quot;</span>, Net: <span class="string">&quot;tcp&quot;</span>, Err: err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> cm.scheme() == <span class="string">&quot;https&quot;</span> &amp;&amp; t.hasCustomTLSDialer() &#123;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="comment">// dial secure TCP connection, assign to field pconn.conn</span></span><br><span class="line">		pconn.conn, err = t.customDialTLS(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tc, ok := pconn.conn.(*tls.Conn); ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeStart != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeStart()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err := tc.Handshake(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> pconn.conn.Close()</span><br><span class="line">				<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">					trace.TLSHandshakeDone(tls.ConnectionState&#123;&#125;, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			cs := tc.ConnectionState()</span><br><span class="line">			<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.TLSHandshakeDone != <span class="literal">nil</span> &#123;</span><br><span class="line">				trace.TLSHandshakeDone(cs, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pconn.tlsState = &amp;cs</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// dial TCP connection</span></span><br><span class="line">		conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// assign to pconn.conn</span></span><br><span class="line">		pconn.conn = conn</span><br><span class="line">		<span class="keyword">if</span> cm.scheme() == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> firstTLSHost <span class="type">string</span></span><br><span class="line">			<span class="keyword">if</span> firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err = pconn.addTLS(firstTLSHost, trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, wrapErr(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL == <span class="literal">nil</span>:</span><br><span class="line">	<span class="keyword">case</span> cm.proxyURL.Scheme == <span class="string">&quot;socks5&quot;</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		d := socksNewDialer(<span class="string">&quot;tcp&quot;</span>, conn.RemoteAddr().String())</span><br><span class="line">		<span class="keyword">if</span> u := cm.proxyURL.User; u != <span class="literal">nil</span> &#123;</span><br><span class="line">			auth := &amp;socksUsernamePassword&#123;</span><br><span class="line">				Username: u.Username(),</span><br><span class="line">			&#125;</span><br><span class="line">			auth.Password, _ = u.Password()</span><br><span class="line">			d.AuthMethods = []socksAuthMethod&#123;</span><br><span class="line">				socksAuthMethodNotRequired,</span><br><span class="line">				socksAuthMethodUsernamePassword,</span><br><span class="line">			&#125;</span><br><span class="line">			d.Authenticate = auth.Authenticate</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _, err := d.DialWithConn(ctx, conn, <span class="string">&quot;tcp&quot;</span>, cm.targetAddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">&quot;http&quot;</span>:</span><br><span class="line">		pconn.isProxy = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			pconn.mutateHeaderFunc = <span class="function"><span class="keyword">func</span><span class="params">(h Header)</span></span> &#123;</span><br><span class="line">				h.Set(<span class="string">&quot;Proxy-Authorization&quot;</span>, pa)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> cm.targetScheme == <span class="string">&quot;https&quot;</span>:</span><br><span class="line">		conn := pconn.conn</span><br><span class="line">		hdr := t.ProxyConnectHeader</span><br><span class="line">		<span class="keyword">if</span> hdr == <span class="literal">nil</span> &#123;</span><br><span class="line">			hdr = <span class="built_in">make</span>(Header)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pa := cm.proxyAuth(); pa != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			hdr = hdr.Clone()</span><br><span class="line">			hdr.Set(<span class="string">&quot;Proxy-Authorization&quot;</span>, pa)</span><br><span class="line">		&#125;</span><br><span class="line">		connectReq := &amp;Request&#123;</span><br><span class="line">			Method: <span class="string">&quot;CONNECT&quot;</span>,</span><br><span class="line">			URL:    &amp;url.URL&#123;Opaque: cm.targetAddr&#125;,</span><br><span class="line">			Host:   cm.targetAddr,</span><br><span class="line">			Header: hdr,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		connectCtx := ctx</span><br><span class="line">		<span class="keyword">if</span> ctx.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line">			newCtx, cancel := context.WithTimeout(ctx, <span class="number">1</span>*time.Minute)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line">			connectCtx = newCtx</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		didReadResponse := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) </span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			resp *Response</span><br><span class="line">			err  <span class="type">error</span> </span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">close</span>(didReadResponse)</span><br><span class="line">			err = connectReq.Write(conn)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			br := bufio.NewReader(conn)</span><br><span class="line">			resp, err = ReadResponse(br, connectReq)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-connectCtx.Done():</span><br><span class="line">			conn.Close()</span><br><span class="line">			&lt;-didReadResponse</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, connectCtx.Err()</span><br><span class="line">		<span class="keyword">case</span> &lt;-didReadResponse:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">			f := strings.SplitN(resp.Status, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">			conn.Close()</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f) &lt; <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;unknown status code&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(f[<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cm.proxyURL != <span class="literal">nil</span> &amp;&amp; cm.targetScheme == <span class="string">&quot;https&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := pconn.addTLS(cm.tlsHost(), trace); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s := pconn.tlsState; s != <span class="literal">nil</span> &amp;&amp; s.NegotiatedProtocolIsMutual &amp;&amp; s.NegotiatedProtocol != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> next, ok := t.TLSNextProto[s.NegotiatedProtocol]; ok &#123;</span><br><span class="line">			alt := next(cm.targetAddr, pconn.conn.(*tls.Conn))</span><br><span class="line">			<span class="keyword">if</span> e, ok := alt.(http2erringRoundTripper); ok &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, e.err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> &amp;persistConn&#123;t: t, cacheKey: pconn.cacheKey, alt: alt&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())</span><br><span class="line">	<span class="comment">// buffer io wrapper for writing request</span></span><br><span class="line">	pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br><span class="line">	<span class="comment">// read loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">	<span class="comment">// write loop</span></span><br><span class="line">	<span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">	<span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At <strong>line 4</strong>, it creates a new <code>persistConn</code> object, which is also the return value for this method. </p>
<p>At <strong>line 22</strong> and <strong>line 46</strong>, it calls <code>dial</code> method to establish a new TCP connection (note line 22 handles <code>TLS</code> case). In Golang a TCP connection is represented as <code>net.Conn</code> type. And then the underlying TCP connection is bound to the <code>conn</code> field of <code>persistConn</code>. </p>
<p>Now that we have the TCP connection, how can we use it? We’ll skip the many lines of code and go to the end to this function. </p>
<p>At <strong>line 166</strong>,  it creates <code>bufio.Writer</code> based on <code>persistConn</code>. <code>Buffer IO</code> is an interesting topic, in detail you can refer to my previous <a href="https://baoqger.github.io/2021/04/04/golang-bytes-buffer/">article</a>. In one word, it can optimize the performance by reducing the number of system calls. For example in the current case, it can avoid too many <code>socket</code> system calls. </p>
<p>At <strong>line 171</strong>, it creates a Goroutine and execute <code>writeLoop</code> method. Let’s take a look at it. </p>
<h3 id="writeLoop"><a href="#writeLoop" class="headerlink" title="writeLoop"></a>writeLoop</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writeLoop method in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> writeLoop() &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(pc.writeLoopDone)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// receive request from writech channel</span></span><br><span class="line">		<span class="keyword">case</span> wr := &lt;-pc.writech:</span><br><span class="line">			startBytesWritten := pc.nwrite</span><br><span class="line">			<span class="comment">// call write method</span></span><br><span class="line">			err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br><span class="line">			<span class="keyword">if</span> bre, ok := err.(requestBodyReadError); ok &#123;</span><br><span class="line">				err = bre.<span class="type">error</span></span><br><span class="line">				wr.req.setError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				err = pc.bw.Flush()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				wr.req.Request.closeBody()</span><br><span class="line">				<span class="keyword">if</span> pc.nwrite == startBytesWritten &#123;</span><br><span class="line">					err = nothingWrittenError&#123;err&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pc.writeErrCh &lt;- err <span class="comment">// to the body reader, which might recycle us</span></span><br><span class="line">			wr.ch &lt;- err         <span class="comment">// to the roundTrip function</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As the function name <strong>writeLoop</strong> implies, there is a <strong>for</strong> loop, and it keeps receiving data from the <strong>writech</strong> channel. Everytime it receive a request from the channel, call the <code>write</code> method at <strong>line 10</strong>. Then let’s review what message it actually writes:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method in request.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> write(w io.Writer, usingProxy <span class="type">bool</span>, extraHeaders Header, waitForContinue <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">	trace := httptrace.ContextClientTrace(r.Context())</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteRequest != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			trace.WroteRequest(httptrace.WroteRequestInfo&#123;</span><br><span class="line">				Err: err,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	host := cleanHost(r.Host)</span><br><span class="line">	<span class="keyword">if</span> host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.URL == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errMissingHost</span><br><span class="line">		&#125;</span><br><span class="line">		host = cleanHost(r.URL.Host)</span><br><span class="line">	&#125;</span><br><span class="line">	host = removeZone(host)</span><br><span class="line">	ruri := r.URL.RequestURI()</span><br><span class="line">	<span class="keyword">if</span> usingProxy &amp;&amp; r.URL.Scheme != <span class="string">&quot;&quot;</span> &amp;&amp; r.URL.Opaque == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ruri = r.URL.Scheme + <span class="string">&quot;://&quot;</span> + host + ruri</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> r.Method == <span class="string">&quot;CONNECT&quot;</span> &amp;&amp; r.URL.Path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ruri = host</span><br><span class="line">		<span class="keyword">if</span> r.URL.Opaque != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			ruri = r.URL.Opaque</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> stringContainsCTLByte(ruri) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;net/http: can&#x27;t write control character in Request.URL&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> bw *bufio.Writer</span><br><span class="line">	<span class="keyword">if</span> _, ok := w.(io.ByteWriter); !ok &#123;</span><br><span class="line">		bw = bufio.NewWriter(w)</span><br><span class="line">		w = bw</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request line</span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">&quot;%s %s HTTP/1.1\r\n&quot;</span>, valueOrDefault(r.Method, <span class="string">&quot;GET&quot;</span>), ruri)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write HTTP request Host header </span></span><br><span class="line">	_, err = fmt.Fprintf(w, <span class="string">&quot;Host: %s\r\n&quot;</span>, host)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaderField(<span class="string">&quot;Host&quot;</span>, []<span class="type">string</span>&#123;host&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	userAgent := defaultUserAgent</span><br><span class="line">	<span class="keyword">if</span> r.Header.has(<span class="string">&quot;User-Agent&quot;</span>) &#123;</span><br><span class="line">		userAgent = r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> userAgent != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// write HTTP request User-Agent header </span></span><br><span class="line">		_, err = fmt.Fprintf(w, <span class="string">&quot;User-Agent: %s\r\n&quot;</span>, userAgent)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaderField != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.WroteHeaderField(<span class="string">&quot;User-Agent&quot;</span>, []<span class="type">string</span>&#123;userAgent&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tw, err := newTransferWriter(r)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeHeader(w, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = r.Header.writeSubset(w, reqWriteExcludeHeader, trace)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> extraHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = extraHeaders.write(w, trace)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// write blank line after HTTP request headers</span></span><br><span class="line">	_, err = io.WriteString(w, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.WroteHeaders != <span class="literal">nil</span> &#123;</span><br><span class="line">		trace.WroteHeaders()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> waitForContinue != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &#123;</span><br><span class="line">			err = bw.Flush()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace != <span class="literal">nil</span> &amp;&amp; trace.Wait100Continue != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.Wait100Continue()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !waitForContinue() &#123;</span><br><span class="line">			r.closeBody()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw, ok := w.(*bufio.Writer); ok &amp;&amp; tw.FlushHeaders &#123;</span><br><span class="line">		<span class="keyword">if</span> err := bw.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	err = tw.writeBody(w)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> tw.bodyReadError == err &#123;</span><br><span class="line">			err = requestBodyReadError&#123;err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> bw != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bw.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We will not go through every line of code in above function. But I bet you find many familiar information, for example, at line 37 it write <strong>HTTP request line</strong> as the first information in the HTTP message. Then it continues writing <strong>HTTP headers</strong> such as <strong>Host</strong> and <strong>User-Agent</strong>(at line 42 and line 56), and finally add the <strong>blank line</strong> after the headers (at line 86). An HTTP request message is built up bit by bit. All right.  </p>
<h3 id="Bufio-and-underlying-writer"><a href="#Bufio-and-underlying-writer" class="headerlink" title="Bufio and underlying writer"></a>Bufio and underlying writer</h3><p>Next piece of this puzzle is how it’s related to the underlying TCP connection. </p>
<p>Note this method call in the write loop: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write method call in writeLoop</span></span><br><span class="line">wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))</span><br></pre></td></tr></table></figure>
<p>The first parameter is <code>pc.bw</code> mentioned above. It’s time to take a deep look at it. <code>pc.bw</code>, a <strong>bufio.Write</strong>, is created by calling the following method from <code>bufio</code> package: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pconn.bw is created by this method call</span></span><br><span class="line">pconn.bw = bufio.NewWriterSize(persistConnWriter&#123;pconn&#125;, t.writeBufferSize())</span><br></pre></td></tr></table></figure>

<p>Note that this <strong>bufio.Writer</strong> isn’t based on <code>persistConn</code> directly, instead a simple wrapper over <code>persistConn</code> called <code>persistConnWriter</code> is used here. </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="keyword">type</span> persistConnWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	pc *persistConn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we need to understand is <strong>bufio.Writer wraps an io.Writer object, creating another Writer that also implements the interface but provides buffering functionality.</strong> And <strong>bufio.Writer’s Flush method writes the buffered data to the underlying io.Writer.</strong></p>
<p>In this case, the underlying io.Writer is <code>persistConnWriter</code>. Its <code>Write</code> method will be used to write the buffered data: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistConnWriter in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w persistConnWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	n, err = w.pc.conn.Write(p) <span class="comment">// TCP socket Write system call is called here!</span></span><br><span class="line">	w.pc.nwrite += <span class="type">int64</span>(n)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internally it delegates the task to the TCP connection bond to <code>pconn.conn</code>! </p>
<h3 id="roundTrip"><a href="#roundTrip" class="headerlink" title="roundTrip"></a>roundTrip</h3><p>As we mentioned above, <code>writeLoop</code> keeps receiving reqeusts from <code>writech</code> channel. So on the other hand, it means the requests should be sent to this channel somewhere. This is implemented inside the <code>roundTrip</code> method: </p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundTrip in transport.go file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span></span> roundTrip(req *transportRequest) (resp *Response, err <span class="type">error</span>) &#123;</span><br><span class="line">	testHookEnterRoundTrip()</span><br><span class="line">	<span class="keyword">if</span> !pc.t.replaceReqCanceler(req.cancelKey, pc.cancelRequest) &#123;</span><br><span class="line">		pc.t.putOrCloseIdleConn(pc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errRequestCanceled</span><br><span class="line">	&#125;</span><br><span class="line">	pc.mu.Lock()</span><br><span class="line">	pc.numExpectedResponses++</span><br><span class="line">	headerFn := pc.mutateHeaderFunc</span><br><span class="line">	pc.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> headerFn != <span class="literal">nil</span> &#123;</span><br><span class="line">		headerFn(req.extraHeaders())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	requestedGzip := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> !pc.t.DisableCompression &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">		req.Header.Get(<span class="string">&quot;Range&quot;</span>) == <span class="string">&quot;&quot;</span> &amp;&amp;</span><br><span class="line">		req.Method != <span class="string">&quot;HEAD&quot;</span> &#123;</span><br><span class="line">		requestedGzip = <span class="literal">true</span></span><br><span class="line">		req.extraHeaders().Set(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> continueCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.Body != <span class="literal">nil</span> &amp;&amp; req.expectsContinue() &#123;</span><br><span class="line">		continueCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pc.t.DisableKeepAlives &amp;&amp; !req.wantsClose() &#123;</span><br><span class="line">		req.extraHeaders().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(gone)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			pc.t.setReqCanceler(req.cancelKey, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> debugRoundTrip = <span class="literal">false</span></span><br><span class="line">	startBytesWritten := pc.nwrite</span><br><span class="line">	writeErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// send requet to pc.writech channel </span></span><br><span class="line">	pc.writech &lt;- writeRequest&#123;req, writeErrCh, continueCh&#125;</span><br><span class="line"></span><br><span class="line">	resc := <span class="built_in">make</span>(<span class="keyword">chan</span> responseAndError)</span><br><span class="line">	pc.reqch &lt;- requestAndChan&#123;</span><br><span class="line">		req:        req.Request,</span><br><span class="line">		cancelKey:  req.cancelKey,</span><br><span class="line">		ch:         resc,</span><br><span class="line">		addedGzip:  requestedGzip,</span><br><span class="line">		continueCh: continueCh,</span><br><span class="line">		callerGone: gone,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> respHeaderTimer &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	cancelChan := req.Request.Cancel</span><br><span class="line">	ctxDoneChan := req.Context().Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		testHookWaitResLoop()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err := &lt;-writeErrCh:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;writeErrCh resv: %T/%#v&quot;</span>, err, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				pc.<span class="built_in">close</span>(fmt.Errorf(<span class="string">&quot;write error: %v&quot;</span>, err))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> d := pc.t.ResponseHeaderTimeout; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">					req.logf(<span class="string">&quot;starting timer for %v&quot;</span>, d)</span><br><span class="line">				&#125;</span><br><span class="line">				timer := time.NewTimer(d)</span><br><span class="line">				<span class="keyword">defer</span> timer.Stop() </span><br><span class="line">				respHeaderTimer = timer.C</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;closech recv: %T %#v&quot;</span>, pc.closed, pc.closed)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, pc.closed)</span><br><span class="line">		<span class="keyword">case</span> &lt;-respHeaderTimer:</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;timeout waiting for response headers.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			pc.<span class="built_in">close</span>(errTimeout)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errTimeout</span><br><span class="line">		<span class="keyword">case</span> re := &lt;-resc:</span><br><span class="line">			<span class="keyword">if</span> (re.res == <span class="literal">nil</span>) == (re.err == <span class="literal">nil</span>) &#123;</span><br><span class="line">				<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;internal error: exactly one of res or err should be set; nil=%v&quot;</span>, re.res == <span class="literal">nil</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> debugRoundTrip &#123;</span><br><span class="line">				req.logf(<span class="string">&quot;resc recv: %p, %T/%#v&quot;</span>, re.res, re.err, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> re.err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, pc.mapRoundTripError(req, startBytesWritten, re.err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> re.res, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-cancelChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, errRequestCanceled)</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ctxDoneChan:</span><br><span class="line">			pc.t.cancelRequest(req.cancelKey, req.Context().Err())</span><br><span class="line">			cancelChan = <span class="literal">nil</span></span><br><span class="line">			ctxDoneChan = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At line 48, you can find it clearly. In <a href="https://baoqger.github.io/2021/12/01/understand-http1-1-client-golang/">last article</a>, you can see that <code>pconn.roundTrip</code> is the end of the HTTP request workflow. Now we had put all parts together. Great. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>In this article (as the second part of this series), we reviewed how the HTTP request message is written to TCP/IP stack via socket system call.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://baoqger.github.io/2021/12/15/understand-http-1-1-client-golang-part2/" data-id="clghbdujh003kn4mmcfrmag17" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/12/24/how-traceroute-works/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          how-traceroute-works
        
      </div>
    </a>
  
  
    <a href="/2021/12/01/understand-http-1-1-client-golang/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">How  HTTP1.1 protocol is implemented in Golang net/http package: part one - request workflow</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" rel="tag">Algorithm, Data structure, Tree, Red Black Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BPF-JIT-virtual-machine/" rel="tag">BPF, JIT, virtual machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Best-practice/" rel="tag">Best practice,</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabio-Golang-Source-code/" rel="tag">Fabio, Golang, Source code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-bufio-bytes-buffer/" rel="tag">Golang, bufio, bytes, buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang-package-workspace-vendor/" rel="tag">Golang, package, workspace, vendor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-protocol-Golang-TCP-socket/" rel="tag">HTTP protocol, Golang, TCP, socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-system-call-Linux-Golang/" rel="tag">HTTP, system call, Linux, Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-concurrent/" rel="tag">HTTP/1.1, concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" rel="tag">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS-TLS-handshake-SSL-TLS/" rel="tag">HTTPS, TLS handshake, SSL/TLS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-module-Netfilter-firewall/" rel="tag">Linux module, Netfilter, firewall</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-gdb/" rel="tag">Linux, memory layout, heap, gdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-memory-layout-heap-stack/" rel="tag">Linux, memory layout, heap, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" rel="tag">Linux, system programming, Windows Subsystem for Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/" rel="tag">TCP, IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm-external-disk/" rel="tag">algorithm, external, disk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apt-Ubuntu-Linux-package-management/" rel="tag">apt, Ubuntu, Linux, package management</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certificate-digital-signature-hashing/" rel="tag">certificate, digital signature, hashing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/digital-signature-hash-function/" rel="tag">digital signature, hash function</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-c-linux/" rel="tag">docker, c++, linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang-concurrent-shared-memory-message-pass/" rel="tag">golang, concurrent, shared memory, message pass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory-management-stack/" rel="tag">memory management, stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" rel="tag">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" rel="tag">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" rel="tag">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operating-system-xv6-Unix/" rel="tag">operating system, xv6, Unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/packet-sniffer-socket-PF-PACKET/" rel="tag">packet sniffer, socket, PF_PACKET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" rel="tag">priority queue, data structure, algorithm, time complexity, Big O notation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming-c-array-pointer/" rel="tag">programming c, array, pointer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/public-key-man-in-the-middle-certificate/" rel="tag">public key, man-in-the-middle, certificate</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm-Data-structure-Tree-Red-Black-Tree/" style="font-size: 10px;">Algorithm, Data structure, Tree, Red Black Tree</a> <a href="/tags/BPF-JIT-virtual-machine/" style="font-size: 10px;">BPF, JIT, virtual machine</a> <a href="/tags/Best-practice/" style="font-size: 10px;">Best practice,</a> <a href="/tags/Fabio-Golang-Source-code/" style="font-size: 10px;">Fabio, Golang, Source code</a> <a href="/tags/Golang-bufio-bytes-buffer/" style="font-size: 10px;">Golang, bufio, bytes, buffer</a> <a href="/tags/Golang-package-workspace-vendor/" style="font-size: 10px;">Golang, package, workspace, vendor</a> <a href="/tags/HTTP-protocol-Golang-TCP-socket/" style="font-size: 10px;">HTTP protocol, Golang, TCP, socket</a> <a href="/tags/HTTP-system-call-Linux-Golang/" style="font-size: 10px;">HTTP, system call, Linux, Golang</a> <a href="/tags/HTTP-1-1-concurrent/" style="font-size: 10px;">HTTP/1.1, concurrent</a> <a href="/tags/HTTP-1-1-persistent-connection-keep-alive-TCP-netstat-tcpdump-Golang-connection-pool/" style="font-size: 10px;">HTTP/1.1, persistent connection, keep-alive, TCP, netstat, tcpdump, Golang, connection pool</a> <a href="/tags/HTTPS-TLS-handshake-SSL-TLS/" style="font-size: 10px;">HTTPS, TLS handshake, SSL/TLS</a> <a href="/tags/Linux-module-Netfilter-firewall/" style="font-size: 20px;">Linux module, Netfilter, firewall</a> <a href="/tags/Linux-memory-layout-heap-gdb/" style="font-size: 15px;">Linux, memory layout, heap, gdb</a> <a href="/tags/Linux-memory-layout-heap-stack/" style="font-size: 10px;">Linux, memory layout, heap, stack</a> <a href="/tags/Linux-system-programming-Windows-Subsystem-for-Linux/" style="font-size: 10px;">Linux, system programming, Windows Subsystem for Linux</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP, IP</a> <a href="/tags/algorithm-external-disk/" style="font-size: 15px;">algorithm, external, disk</a> <a href="/tags/apt-Ubuntu-Linux-package-management/" style="font-size: 10px;">apt, Ubuntu, Linux, package management</a> <a href="/tags/certificate-digital-signature-hashing/" style="font-size: 10px;">certificate, digital signature, hashing</a> <a href="/tags/digital-signature-hash-function/" style="font-size: 15px;">digital signature, hash function</a> <a href="/tags/docker-c-linux/" style="font-size: 10px;">docker, c++, linux</a> <a href="/tags/golang-concurrent-shared-memory-message-pass/" style="font-size: 10px;">golang, concurrent, shared memory, message pass</a> <a href="/tags/memory-management-stack/" style="font-size: 10px;">memory management, stack</a> <a href="/tags/microservice-Load-balancing-Consul-Fabio-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, Load balancing, Consul, Fabio Golang, Cloud-Native, Docker</a> <a href="/tags/microservice-service-registration-service-discovery-Consul-Golang-Cloud-Native-Docker/" style="font-size: 10px;">microservice, service registration, service discovery, Consul, Golang, Cloud-Native, Docker</a> <a href="/tags/network-packet-capture-libpcap-analyze-and-track-network-traffics-detect-network-security-attacks-Linux-system-programming/" style="font-size: 10px;">network packet capture, libpcap, analyze and track network traffics, detect network security attacks, Linux system programming</a> <a href="/tags/operating-system-xv6-Unix/" style="font-size: 10px;">operating system, xv6, Unix</a> <a href="/tags/packet-sniffer-socket-PF-PACKET/" style="font-size: 10px;">packet sniffer, socket, PF_PACKET</a> <a href="/tags/priority-queue-data-structure-algorithm-time-complexity-Big-O-notation/" style="font-size: 10px;">priority queue, data structure, algorithm, time complexity, Big O notation</a> <a href="/tags/programming-c-array-pointer/" style="font-size: 10px;">programming c, array, pointer</a> <a href="/tags/public-key-man-in-the-middle-certificate/" style="font-size: 10px;">public key, man-in-the-middle, certificate</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/13/note-on-red-black-tree/">Note on Red Black Tree: part one</a>
          </li>
        
          <li>
            <a href="/2022/12/06/external-sorting-two/">External Mergesort: part two</a>
          </li>
        
          <li>
            <a href="/2022/11/02/external-sorting-one/">External Mergesort: part one</a>
          </li>
        
          <li>
            <a href="/2022/10/10/userland-memory-allocation-three/">Understand userland heap memory allocation: part three - free chunk</a>
          </li>
        
          <li>
            <a href="/2022/09/08/userland-memory-allocation-two/">Understand userland heap memory allocation: part two - allocate chunk</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Chris Bao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/project" class="mobile-nav-link">Project</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>